/*
Copyright 2016 Game Server Services, Inc. or its affiliates. All Rights
Reserved.

Licensed under the Apache License, Version 2.0 (the "License").
You may not use this file except in compliance with the License.
A copy of the License is located at

 http://www.apache.org/licenses/LICENSE-2.0

or in the "license" file accompanying this file. This file is distributed
on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
express or implied. See the License for the specific language governing
permissions and limitations under the License.
*/

package watch

import (
	"encoding/json"
	"strconv"

	"github.com/gs2io/gs2-golang-sdk/core"
)

type Chart struct {
	Timestamp *int64    `json:"timestamp"`
	Value     *int64    `json:"value"`
	GroupBys  []*string `json:"groupBys"`
}

func (p *Chart) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = Chart{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = Chart{}
	} else {
		*p = Chart{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["timestamp"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Timestamp)
		}
		if v, ok := d["value"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Value)
		}
		if v, ok := d["groupBys"]; ok && v != nil {
			var v2 []interface{}
			if err := json.Unmarshal(*v, &v2); err == nil {
				l := make([]*string, len(v2))
				for i, v3 := range v2 {
					switch v4 := v3.(type) {
					case string:
						l[i] = &v4
					case float64:
						strValue := strconv.FormatFloat(v4, 'f', -1, 64)
						l[i] = &strValue
					case int:
						strValue := strconv.Itoa(v4)
						l[i] = &strValue
					case int32:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					case int64:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					default:
					}
				}
				p.GroupBys = l
			}
		}
	}
	return nil
}

func NewChartFromJson(data string) Chart {
	req := Chart{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChartFromDict(data map[string]interface{}) Chart {
	return Chart{
		Timestamp: core.CastInt64(data["timestamp"]),
		Value:     core.CastInt64(data["value"]),
		GroupBys:  core.CastStrings(core.CastArray(data["groupBys"])),
	}
}

func (p Chart) ToDict() map[string]interface{} {

	var timestamp *int64
	if p.Timestamp != nil {
		timestamp = p.Timestamp
	}
	var value *int64
	if p.Value != nil {
		value = p.Value
	}
	var groupBys []interface{}
	if p.GroupBys != nil {
		groupBys = core.CastStringsFromDict(
			p.GroupBys,
		)
	}
	return map[string]interface{}{
		"timestamp": timestamp,
		"value":     value,
		"groupBys":  groupBys,
	}
}

func (p Chart) Pointer() *Chart {
	return &p
}

func CastCharts(data []interface{}) []Chart {
	v := make([]Chart, 0)
	for _, d := range data {
		v = append(v, NewChartFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChartsFromDict(data []Chart) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type Distribution struct {
	Value    *int64    `json:"value"`
	Count    *int64    `json:"count"`
	GroupBys []*string `json:"groupBys"`
}

func (p *Distribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = Distribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = Distribution{}
	} else {
		*p = Distribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["value"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Value)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["groupBys"]; ok && v != nil {
			var v2 []interface{}
			if err := json.Unmarshal(*v, &v2); err == nil {
				l := make([]*string, len(v2))
				for i, v3 := range v2 {
					switch v4 := v3.(type) {
					case string:
						l[i] = &v4
					case float64:
						strValue := strconv.FormatFloat(v4, 'f', -1, 64)
						l[i] = &strValue
					case int:
						strValue := strconv.Itoa(v4)
						l[i] = &strValue
					case int32:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					case int64:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					default:
					}
				}
				p.GroupBys = l
			}
		}
	}
	return nil
}

func NewDistributionFromJson(data string) Distribution {
	req := Distribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDistributionFromDict(data map[string]interface{}) Distribution {
	return Distribution{
		Value:    core.CastInt64(data["value"]),
		Count:    core.CastInt64(data["count"]),
		GroupBys: core.CastStrings(core.CastArray(data["groupBys"])),
	}
}

func (p Distribution) ToDict() map[string]interface{} {

	var value *int64
	if p.Value != nil {
		value = p.Value
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var groupBys []interface{}
	if p.GroupBys != nil {
		groupBys = core.CastStringsFromDict(
			p.GroupBys,
		)
	}
	return map[string]interface{}{
		"value":    value,
		"count":    count,
		"groupBys": groupBys,
	}
}

func (p Distribution) Pointer() *Distribution {
	return &p
}

func CastDistributions(data []interface{}) []Distribution {
	v := make([]Distribution, 0)
	for _, d := range data {
		v = append(v, NewDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDistributionsFromDict(data []Distribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type Cumulative struct {
	CumulativeId *string `json:"cumulativeId"`
	ResourceGrn  *string `json:"resourceGrn"`
	Name         *string `json:"name"`
	Value        *int64  `json:"value"`
	UpdatedAt    *int64  `json:"updatedAt"`
	Revision     *int64  `json:"revision"`
}

func (p *Cumulative) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = Cumulative{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = Cumulative{}
	} else {
		*p = Cumulative{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["cumulativeId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CumulativeId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CumulativeId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CumulativeId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CumulativeId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CumulativeId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CumulativeId)
				}
			}
		}
		if v, ok := d["resourceGrn"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ResourceGrn = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ResourceGrn = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ResourceGrn = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ResourceGrn = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ResourceGrn = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ResourceGrn)
				}
			}
		}
		if v, ok := d["name"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Name = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Name = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Name = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Name = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Name = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Name)
				}
			}
		}
		if v, ok := d["value"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Value)
		}
		if v, ok := d["updatedAt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.UpdatedAt)
		}
		if v, ok := d["revision"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Revision)
		}
	}
	return nil
}

func NewCumulativeFromJson(data string) Cumulative {
	req := Cumulative{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewCumulativeFromDict(data map[string]interface{}) Cumulative {
	return Cumulative{
		CumulativeId: core.CastString(data["cumulativeId"]),
		ResourceGrn:  core.CastString(data["resourceGrn"]),
		Name:         core.CastString(data["name"]),
		Value:        core.CastInt64(data["value"]),
		UpdatedAt:    core.CastInt64(data["updatedAt"]),
		Revision:     core.CastInt64(data["revision"]),
	}
}

func (p Cumulative) ToDict() map[string]interface{} {

	var cumulativeId *string
	if p.CumulativeId != nil {
		cumulativeId = p.CumulativeId
	}
	var resourceGrn *string
	if p.ResourceGrn != nil {
		resourceGrn = p.ResourceGrn
	}
	var name *string
	if p.Name != nil {
		name = p.Name
	}
	var value *int64
	if p.Value != nil {
		value = p.Value
	}
	var updatedAt *int64
	if p.UpdatedAt != nil {
		updatedAt = p.UpdatedAt
	}
	var revision *int64
	if p.Revision != nil {
		revision = p.Revision
	}
	return map[string]interface{}{
		"cumulativeId": cumulativeId,
		"resourceGrn":  resourceGrn,
		"name":         name,
		"value":        value,
		"updatedAt":    updatedAt,
		"revision":     revision,
	}
}

func (p Cumulative) Pointer() *Cumulative {
	return &p
}

func CastCumulatives(data []interface{}) []Cumulative {
	v := make([]Cumulative, 0)
	for _, d := range data {
		v = append(v, NewCumulativeFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastCumulativesFromDict(data []Cumulative) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type BillingActivity struct {
	BillingActivityId *string `json:"billingActivityId"`
	Year              *int32  `json:"year"`
	Month             *int32  `json:"month"`
	Service           *string `json:"service"`
	ActivityType      *string `json:"activityType"`
	Value             *int64  `json:"value"`
	Revision          *int64  `json:"revision"`
}

func (p *BillingActivity) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = BillingActivity{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = BillingActivity{}
	} else {
		*p = BillingActivity{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["billingActivityId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.BillingActivityId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.BillingActivityId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.BillingActivityId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.BillingActivityId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.BillingActivityId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.BillingActivityId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["service"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Service = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Service = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Service = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Service = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Service = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Service)
				}
			}
		}
		if v, ok := d["activityType"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ActivityType = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ActivityType = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ActivityType = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ActivityType = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ActivityType = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ActivityType)
				}
			}
		}
		if v, ok := d["value"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Value)
		}
		if v, ok := d["revision"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Revision)
		}
	}
	return nil
}

func NewBillingActivityFromJson(data string) BillingActivity {
	req := BillingActivity{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewBillingActivityFromDict(data map[string]interface{}) BillingActivity {
	return BillingActivity{
		BillingActivityId: core.CastString(data["billingActivityId"]),
		Year:              core.CastInt32(data["year"]),
		Month:             core.CastInt32(data["month"]),
		Service:           core.CastString(data["service"]),
		ActivityType:      core.CastString(data["activityType"]),
		Value:             core.CastInt64(data["value"]),
		Revision:          core.CastInt64(data["revision"]),
	}
}

func (p BillingActivity) ToDict() map[string]interface{} {

	var billingActivityId *string
	if p.BillingActivityId != nil {
		billingActivityId = p.BillingActivityId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var service *string
	if p.Service != nil {
		service = p.Service
	}
	var activityType *string
	if p.ActivityType != nil {
		activityType = p.ActivityType
	}
	var value *int64
	if p.Value != nil {
		value = p.Value
	}
	var revision *int64
	if p.Revision != nil {
		revision = p.Revision
	}
	return map[string]interface{}{
		"billingActivityId": billingActivityId,
		"year":              year,
		"month":             month,
		"service":           service,
		"activityType":      activityType,
		"value":             value,
		"revision":          revision,
	}
}

func (p BillingActivity) Pointer() *BillingActivity {
	return &p
}

func CastBillingActivities(data []interface{}) []BillingActivity {
	v := make([]BillingActivity, 0)
	for _, d := range data {
		v = append(v, NewBillingActivityFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastBillingActivitiesFromDict(data []BillingActivity) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StatsEvent struct {
	Grn        *string   `json:"grn"`
	Service    *string   `json:"service"`
	Method     *string   `json:"method"`
	Metric     *string   `json:"metric"`
	Cumulative *bool     `json:"cumulative"`
	Value      *float64  `json:"value"`
	Tags       []*string `json:"tags"`
	CallAt     *int64    `json:"callAt"`
}

func (p *StatsEvent) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StatsEvent{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StatsEvent{}
	} else {
		*p = StatsEvent{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["grn"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Grn = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Grn = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Grn = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Grn = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Grn = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Grn)
				}
			}
		}
		if v, ok := d["service"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Service = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Service = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Service = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Service = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Service = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Service)
				}
			}
		}
		if v, ok := d["method"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Method = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Method = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Method = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Method = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Method = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Method)
				}
			}
		}
		if v, ok := d["metric"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Metric = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Metric = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Metric = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Metric = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Metric = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Metric)
				}
			}
		}
		if v, ok := d["cumulative"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Cumulative)
		}
		if v, ok := d["value"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Value)
		}
		if v, ok := d["tags"]; ok && v != nil {
			var v2 []interface{}
			if err := json.Unmarshal(*v, &v2); err == nil {
				l := make([]*string, len(v2))
				for i, v3 := range v2 {
					switch v4 := v3.(type) {
					case string:
						l[i] = &v4
					case float64:
						strValue := strconv.FormatFloat(v4, 'f', -1, 64)
						l[i] = &strValue
					case int:
						strValue := strconv.Itoa(v4)
						l[i] = &strValue
					case int32:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					case int64:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					default:
					}
				}
				p.Tags = l
			}
		}
		if v, ok := d["callAt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CallAt)
		}
	}
	return nil
}

func NewStatsEventFromJson(data string) StatsEvent {
	req := StatsEvent{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStatsEventFromDict(data map[string]interface{}) StatsEvent {
	return StatsEvent{
		Grn:        core.CastString(data["grn"]),
		Service:    core.CastString(data["service"]),
		Method:     core.CastString(data["method"]),
		Metric:     core.CastString(data["metric"]),
		Cumulative: core.CastBool(data["cumulative"]),
		Value:      core.CastFloat64(data["value"]),
		Tags:       core.CastStrings(core.CastArray(data["tags"])),
		CallAt:     core.CastInt64(data["callAt"]),
	}
}

func (p StatsEvent) ToDict() map[string]interface{} {

	var grn *string
	if p.Grn != nil {
		grn = p.Grn
	}
	var service *string
	if p.Service != nil {
		service = p.Service
	}
	var method *string
	if p.Method != nil {
		method = p.Method
	}
	var metric *string
	if p.Metric != nil {
		metric = p.Metric
	}
	var cumulative *bool
	if p.Cumulative != nil {
		cumulative = p.Cumulative
	}
	var value *float64
	if p.Value != nil {
		value = p.Value
	}
	var tags []interface{}
	if p.Tags != nil {
		tags = core.CastStringsFromDict(
			p.Tags,
		)
	}
	var callAt *int64
	if p.CallAt != nil {
		callAt = p.CallAt
	}
	return map[string]interface{}{
		"grn":        grn,
		"service":    service,
		"method":     method,
		"metric":     metric,
		"cumulative": cumulative,
		"value":      value,
		"tags":       tags,
		"callAt":     callAt,
	}
}

func (p StatsEvent) Pointer() *StatsEvent {
	return &p
}

func CastStatsEvents(data []interface{}) []StatsEvent {
	v := make([]StatsEvent, 0)
	for _, d := range data {
		v = append(v, NewStatsEventFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStatsEventsFromDict(data []StatsEvent) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type Filter struct {
	Key   *string `json:"key"`
	Value *string `json:"value"`
}

func (p *Filter) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = Filter{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = Filter{}
	} else {
		*p = Filter{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["key"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Key = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Key = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Key = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Key = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Key = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Key)
				}
			}
		}
		if v, ok := d["value"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Value = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Value = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Value = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Value = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Value = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Value)
				}
			}
		}
	}
	return nil
}

func NewFilterFromJson(data string) Filter {
	req := Filter{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFilterFromDict(data map[string]interface{}) Filter {
	return Filter{
		Key:   core.CastString(data["key"]),
		Value: core.CastString(data["value"]),
	}
}

func (p Filter) ToDict() map[string]interface{} {

	var key *string
	if p.Key != nil {
		key = p.Key
	}
	var value *string
	if p.Value != nil {
		value = p.Value
	}
	return map[string]interface{}{
		"key":   key,
		"value": value,
	}
}

func (p Filter) Pointer() *Filter {
	return &p
}

func CastFilters(data []interface{}) []Filter {
	v := make([]Filter, 0)
	for _, d := range data {
		v = append(v, NewFilterFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFiltersFromDict(data []Filter) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type GeneralDauWauMauHistory struct {
	Date                *string `json:"date"`
	Dau                 *int64  `json:"dau"`
	WauLast7Days        *int64  `json:"wauLast7Days"`
	WauTargetWeekSunday *int64  `json:"wauTargetWeekSunday"`
	WauTargetWeekMonday *int64  `json:"wauTargetWeekMonday"`
	MauLast30Days       *int64  `json:"mauLast30Days"`
	MauTargetMonth      *int64  `json:"mauTargetMonth"`
}

func (p *GeneralDauWauMauHistory) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = GeneralDauWauMauHistory{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = GeneralDauWauMauHistory{}
	} else {
		*p = GeneralDauWauMauHistory{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["date"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Date = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Date = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Date = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Date)
				}
			}
		}
		if v, ok := d["dau"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Dau)
		}
		if v, ok := d["wauLast7Days"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.WauLast7Days)
		}
		if v, ok := d["wauTargetWeekSunday"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.WauTargetWeekSunday)
		}
		if v, ok := d["wauTargetWeekMonday"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.WauTargetWeekMonday)
		}
		if v, ok := d["mauLast30Days"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.MauLast30Days)
		}
		if v, ok := d["mauTargetMonth"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.MauTargetMonth)
		}
	}
	return nil
}

func NewGeneralDauWauMauHistoryFromJson(data string) GeneralDauWauMauHistory {
	req := GeneralDauWauMauHistory{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewGeneralDauWauMauHistoryFromDict(data map[string]interface{}) GeneralDauWauMauHistory {
	return GeneralDauWauMauHistory{
		Date:                core.CastString(data["date"]),
		Dau:                 core.CastInt64(data["dau"]),
		WauLast7Days:        core.CastInt64(data["wauLast7Days"]),
		WauTargetWeekSunday: core.CastInt64(data["wauTargetWeekSunday"]),
		WauTargetWeekMonday: core.CastInt64(data["wauTargetWeekMonday"]),
		MauLast30Days:       core.CastInt64(data["mauLast30Days"]),
		MauTargetMonth:      core.CastInt64(data["mauTargetMonth"]),
	}
}

func (p GeneralDauWauMauHistory) ToDict() map[string]interface{} {

	var date *string
	if p.Date != nil {
		date = p.Date
	}
	var dau *int64
	if p.Dau != nil {
		dau = p.Dau
	}
	var wauLast7Days *int64
	if p.WauLast7Days != nil {
		wauLast7Days = p.WauLast7Days
	}
	var wauTargetWeekSunday *int64
	if p.WauTargetWeekSunday != nil {
		wauTargetWeekSunday = p.WauTargetWeekSunday
	}
	var wauTargetWeekMonday *int64
	if p.WauTargetWeekMonday != nil {
		wauTargetWeekMonday = p.WauTargetWeekMonday
	}
	var mauLast30Days *int64
	if p.MauLast30Days != nil {
		mauLast30Days = p.MauLast30Days
	}
	var mauTargetMonth *int64
	if p.MauTargetMonth != nil {
		mauTargetMonth = p.MauTargetMonth
	}
	return map[string]interface{}{
		"date":                date,
		"dau":                 dau,
		"wauLast7Days":        wauLast7Days,
		"wauTargetWeekSunday": wauTargetWeekSunday,
		"wauTargetWeekMonday": wauTargetWeekMonday,
		"mauLast30Days":       mauLast30Days,
		"mauTargetMonth":      mauTargetMonth,
	}
}

func (p GeneralDauWauMauHistory) Pointer() *GeneralDauWauMauHistory {
	return &p
}

func CastGeneralDauWauMauHistories(data []interface{}) []GeneralDauWauMauHistory {
	v := make([]GeneralDauWauMauHistory, 0)
	for _, d := range data {
		v = append(v, NewGeneralDauWauMauHistoryFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastGeneralDauWauMauHistoriesFromDict(data []GeneralDauWauMauHistory) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type GeneralDauWauMauAverage struct {
	Dau *float32 `json:"dau"`
	Wau *float32 `json:"wau"`
	Mau *float32 `json:"mau"`
}

func (p *GeneralDauWauMauAverage) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = GeneralDauWauMauAverage{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = GeneralDauWauMauAverage{}
	} else {
		*p = GeneralDauWauMauAverage{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["dau"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Dau)
		}
		if v, ok := d["wau"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Wau)
		}
		if v, ok := d["mau"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Mau)
		}
	}
	return nil
}

func NewGeneralDauWauMauAverageFromJson(data string) GeneralDauWauMauAverage {
	req := GeneralDauWauMauAverage{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewGeneralDauWauMauAverageFromDict(data map[string]interface{}) GeneralDauWauMauAverage {
	return GeneralDauWauMauAverage{
		Dau: core.CastFloat32(data["dau"]),
		Wau: core.CastFloat32(data["wau"]),
		Mau: core.CastFloat32(data["mau"]),
	}
}

func (p GeneralDauWauMauAverage) ToDict() map[string]interface{} {

	var dau *float32
	if p.Dau != nil {
		dau = p.Dau
	}
	var wau *float32
	if p.Wau != nil {
		wau = p.Wau
	}
	var mau *float32
	if p.Mau != nil {
		mau = p.Mau
	}
	return map[string]interface{}{
		"dau": dau,
		"wau": wau,
		"mau": mau,
	}
}

func (p GeneralDauWauMauAverage) Pointer() *GeneralDauWauMauAverage {
	return &p
}

func CastGeneralDauWauMauAverages(data []interface{}) []GeneralDauWauMauAverage {
	v := make([]GeneralDauWauMauAverage, 0)
	for _, d := range data {
		v = append(v, NewGeneralDauWauMauAverageFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastGeneralDauWauMauAveragesFromDict(data []GeneralDauWauMauAverage) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type GeneralDauWauMau struct {
	History []GeneralDauWauMauHistory `json:"history"`
	Avg     *GeneralDauWauMauAverage  `json:"avg"`
}

func (p *GeneralDauWauMau) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = GeneralDauWauMau{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = GeneralDauWauMau{}
	} else {
		*p = GeneralDauWauMau{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["history"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.History)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
	}
	return nil
}

func NewGeneralDauWauMauFromJson(data string) GeneralDauWauMau {
	req := GeneralDauWauMau{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewGeneralDauWauMauFromDict(data map[string]interface{}) GeneralDauWauMau {
	return GeneralDauWauMau{
		History: CastGeneralDauWauMauHistories(core.CastArray(data["history"])),
		Avg:     NewGeneralDauWauMauAverageFromDict(core.CastMap(data["avg"])).Pointer(),
	}
}

func (p GeneralDauWauMau) ToDict() map[string]interface{} {

	var history []interface{}
	if p.History != nil {
		history = CastGeneralDauWauMauHistoriesFromDict(
			p.History,
		)
	}
	var avg map[string]interface{}
	if p.Avg != nil {
		avg = p.Avg.ToDict()
	}
	return map[string]interface{}{
		"history": history,
		"avg":     avg,
	}
}

func (p GeneralDauWauMau) Pointer() *GeneralDauWauMau {
	return &p
}

func CastGeneralDauWauMaus(data []interface{}) []GeneralDauWauMau {
	v := make([]GeneralDauWauMau, 0)
	for _, d := range data {
		v = append(v, NewGeneralDauWauMauFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastGeneralDauWauMausFromDict(data []GeneralDauWauMau) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FirstEngagementStatisticsLoginDays struct {
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FirstEngagementStatisticsLoginDays) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FirstEngagementStatisticsLoginDays{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FirstEngagementStatisticsLoginDays{}
	} else {
		*p = FirstEngagementStatisticsLoginDays{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFirstEngagementStatisticsLoginDaysFromJson(data string) FirstEngagementStatisticsLoginDays {
	req := FirstEngagementStatisticsLoginDays{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFirstEngagementStatisticsLoginDaysFromDict(data map[string]interface{}) FirstEngagementStatisticsLoginDays {
	return FirstEngagementStatisticsLoginDays{
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FirstEngagementStatisticsLoginDays) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FirstEngagementStatisticsLoginDays) Pointer() *FirstEngagementStatisticsLoginDays {
	return &p
}

func CastFirstEngagementStatisticsLoginDayses(data []interface{}) []FirstEngagementStatisticsLoginDays {
	v := make([]FirstEngagementStatisticsLoginDays, 0)
	for _, d := range data {
		v = append(v, NewFirstEngagementStatisticsLoginDaysFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFirstEngagementStatisticsLoginDaysesFromDict(data []FirstEngagementStatisticsLoginDays) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FirstEngagementStatistics struct {
	LoginDays *FirstEngagementStatisticsLoginDays `json:"loginDays"`
}

func (p *FirstEngagementStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FirstEngagementStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FirstEngagementStatistics{}
	} else {
		*p = FirstEngagementStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["loginDays"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.LoginDays)
		}
	}
	return nil
}

func NewFirstEngagementStatisticsFromJson(data string) FirstEngagementStatistics {
	req := FirstEngagementStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFirstEngagementStatisticsFromDict(data map[string]interface{}) FirstEngagementStatistics {
	return FirstEngagementStatistics{
		LoginDays: NewFirstEngagementStatisticsLoginDaysFromDict(core.CastMap(data["loginDays"])).Pointer(),
	}
}

func (p FirstEngagementStatistics) ToDict() map[string]interface{} {

	var loginDays map[string]interface{}
	if p.LoginDays != nil {
		loginDays = p.LoginDays.ToDict()
	}
	return map[string]interface{}{
		"loginDays": loginDays,
	}
}

func (p FirstEngagementStatistics) Pointer() *FirstEngagementStatistics {
	return &p
}

func CastFirstEngagementStatisticses(data []interface{}) []FirstEngagementStatistics {
	v := make([]FirstEngagementStatistics, 0)
	for _, d := range data {
		v = append(v, NewFirstEngagementStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFirstEngagementStatisticsesFromDict(data []FirstEngagementStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FirstEngagementDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FirstEngagementDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FirstEngagementDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FirstEngagementDistributionSegment{}
	} else {
		*p = FirstEngagementDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFirstEngagementDistributionSegmentFromJson(data string) FirstEngagementDistributionSegment {
	req := FirstEngagementDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFirstEngagementDistributionSegmentFromDict(data map[string]interface{}) FirstEngagementDistributionSegment {
	return FirstEngagementDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p FirstEngagementDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p FirstEngagementDistributionSegment) Pointer() *FirstEngagementDistributionSegment {
	return &p
}

func CastFirstEngagementDistributionSegments(data []interface{}) []FirstEngagementDistributionSegment {
	v := make([]FirstEngagementDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFirstEngagementDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFirstEngagementDistributionSegmentsFromDict(data []FirstEngagementDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FirstEngagement struct {
	Statistics   *FirstEngagementStatistics           `json:"statistics"`
	Distribution []FirstEngagementDistributionSegment `json:"distribution"`
}

func (p *FirstEngagement) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FirstEngagement{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FirstEngagement{}
	} else {
		*p = FirstEngagement{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFirstEngagementFromJson(data string) FirstEngagement {
	req := FirstEngagement{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFirstEngagementFromDict(data map[string]interface{}) FirstEngagement {
	return FirstEngagement{
		Statistics:   NewFirstEngagementStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFirstEngagementDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FirstEngagement) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFirstEngagementDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FirstEngagement) Pointer() *FirstEngagement {
	return &p
}

func CastFirstEngagements(data []interface{}) []FirstEngagement {
	v := make([]FirstEngagement, 0)
	for _, d := range data {
		v = append(v, NewFirstEngagementFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFirstEngagementsFromDict(data []FirstEngagement) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type SessionDurationStatistics struct {
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *SessionDurationStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = SessionDurationStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = SessionDurationStatistics{}
	} else {
		*p = SessionDurationStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewSessionDurationStatisticsFromJson(data string) SessionDurationStatistics {
	req := SessionDurationStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewSessionDurationStatisticsFromDict(data map[string]interface{}) SessionDurationStatistics {
	return SessionDurationStatistics{
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p SessionDurationStatistics) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p SessionDurationStatistics) Pointer() *SessionDurationStatistics {
	return &p
}

func CastSessionDurationStatisticses(data []interface{}) []SessionDurationStatistics {
	v := make([]SessionDurationStatistics, 0)
	for _, d := range data {
		v = append(v, NewSessionDurationStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastSessionDurationStatisticsesFromDict(data []SessionDurationStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type SessionDurationDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *SessionDurationDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = SessionDurationDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = SessionDurationDistributionSegment{}
	} else {
		*p = SessionDurationDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewSessionDurationDistributionSegmentFromJson(data string) SessionDurationDistributionSegment {
	req := SessionDurationDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewSessionDurationDistributionSegmentFromDict(data map[string]interface{}) SessionDurationDistributionSegment {
	return SessionDurationDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p SessionDurationDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p SessionDurationDistributionSegment) Pointer() *SessionDurationDistributionSegment {
	return &p
}

func CastSessionDurationDistributionSegments(data []interface{}) []SessionDurationDistributionSegment {
	v := make([]SessionDurationDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewSessionDurationDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastSessionDurationDistributionSegmentsFromDict(data []SessionDurationDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type EngagementHistory struct {
	Date            *string  `json:"date"`
	NewUserRate     *float32 `json:"newUserRate"`
	ReturnUserRate  *float32 `json:"returnUserRate"`
	EngagedUserRate *float32 `json:"engagedUserRate"`
}

func (p *EngagementHistory) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = EngagementHistory{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = EngagementHistory{}
	} else {
		*p = EngagementHistory{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["date"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Date = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Date = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Date = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Date)
				}
			}
		}
		if v, ok := d["newUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.NewUserRate)
		}
		if v, ok := d["returnUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ReturnUserRate)
		}
		if v, ok := d["engagedUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EngagedUserRate)
		}
	}
	return nil
}

func NewEngagementHistoryFromJson(data string) EngagementHistory {
	req := EngagementHistory{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewEngagementHistoryFromDict(data map[string]interface{}) EngagementHistory {
	return EngagementHistory{
		Date:            core.CastString(data["date"]),
		NewUserRate:     core.CastFloat32(data["newUserRate"]),
		ReturnUserRate:  core.CastFloat32(data["returnUserRate"]),
		EngagedUserRate: core.CastFloat32(data["engagedUserRate"]),
	}
}

func (p EngagementHistory) ToDict() map[string]interface{} {

	var date *string
	if p.Date != nil {
		date = p.Date
	}
	var newUserRate *float32
	if p.NewUserRate != nil {
		newUserRate = p.NewUserRate
	}
	var returnUserRate *float32
	if p.ReturnUserRate != nil {
		returnUserRate = p.ReturnUserRate
	}
	var engagedUserRate *float32
	if p.EngagedUserRate != nil {
		engagedUserRate = p.EngagedUserRate
	}
	return map[string]interface{}{
		"date":            date,
		"newUserRate":     newUserRate,
		"returnUserRate":  returnUserRate,
		"engagedUserRate": engagedUserRate,
	}
}

func (p EngagementHistory) Pointer() *EngagementHistory {
	return &p
}

func CastEngagementHistories(data []interface{}) []EngagementHistory {
	v := make([]EngagementHistory, 0)
	for _, d := range data {
		v = append(v, NewEngagementHistoryFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastEngagementHistoriesFromDict(data []EngagementHistory) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type EngagementAverage struct {
	NewUserRate     *float32 `json:"newUserRate"`
	ReturnUserRate  *float32 `json:"returnUserRate"`
	EngagedUserRate *float32 `json:"engagedUserRate"`
}

func (p *EngagementAverage) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = EngagementAverage{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = EngagementAverage{}
	} else {
		*p = EngagementAverage{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["newUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.NewUserRate)
		}
		if v, ok := d["returnUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ReturnUserRate)
		}
		if v, ok := d["engagedUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EngagedUserRate)
		}
	}
	return nil
}

func NewEngagementAverageFromJson(data string) EngagementAverage {
	req := EngagementAverage{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewEngagementAverageFromDict(data map[string]interface{}) EngagementAverage {
	return EngagementAverage{
		NewUserRate:     core.CastFloat32(data["newUserRate"]),
		ReturnUserRate:  core.CastFloat32(data["returnUserRate"]),
		EngagedUserRate: core.CastFloat32(data["engagedUserRate"]),
	}
}

func (p EngagementAverage) ToDict() map[string]interface{} {

	var newUserRate *float32
	if p.NewUserRate != nil {
		newUserRate = p.NewUserRate
	}
	var returnUserRate *float32
	if p.ReturnUserRate != nil {
		returnUserRate = p.ReturnUserRate
	}
	var engagedUserRate *float32
	if p.EngagedUserRate != nil {
		engagedUserRate = p.EngagedUserRate
	}
	return map[string]interface{}{
		"newUserRate":     newUserRate,
		"returnUserRate":  returnUserRate,
		"engagedUserRate": engagedUserRate,
	}
}

func (p EngagementAverage) Pointer() *EngagementAverage {
	return &p
}

func CastEngagementAverages(data []interface{}) []EngagementAverage {
	v := make([]EngagementAverage, 0)
	for _, d := range data {
		v = append(v, NewEngagementAverageFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastEngagementAveragesFromDict(data []EngagementAverage) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type Engagements struct {
	History []EngagementHistory `json:"history"`
	Avg     *EngagementAverage  `json:"avg"`
}

func (p *Engagements) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = Engagements{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = Engagements{}
	} else {
		*p = Engagements{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["history"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.History)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
	}
	return nil
}

func NewEngagementsFromJson(data string) Engagements {
	req := Engagements{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewEngagementsFromDict(data map[string]interface{}) Engagements {
	return Engagements{
		History: CastEngagementHistories(core.CastArray(data["history"])),
		Avg:     NewEngagementAverageFromDict(core.CastMap(data["avg"])).Pointer(),
	}
}

func (p Engagements) ToDict() map[string]interface{} {

	var history []interface{}
	if p.History != nil {
		history = CastEngagementHistoriesFromDict(
			p.History,
		)
	}
	var avg map[string]interface{}
	if p.Avg != nil {
		avg = p.Avg.ToDict()
	}
	return map[string]interface{}{
		"history": history,
		"avg":     avg,
	}
}

func (p Engagements) Pointer() *Engagements {
	return &p
}

func CastEngagementses(data []interface{}) []Engagements {
	v := make([]Engagements, 0)
	for _, d := range data {
		v = append(v, NewEngagementsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastEngagementsesFromDict(data []Engagements) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChurnRateHistory struct {
	Date      *string  `json:"date"`
	ChurnRate *float32 `json:"churnRate"`
}

func (p *ChurnRateHistory) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChurnRateHistory{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChurnRateHistory{}
	} else {
		*p = ChurnRateHistory{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["date"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Date = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Date = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Date = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Date)
				}
			}
		}
		if v, ok := d["churnRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ChurnRate)
		}
	}
	return nil
}

func NewChurnRateHistoryFromJson(data string) ChurnRateHistory {
	req := ChurnRateHistory{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChurnRateHistoryFromDict(data map[string]interface{}) ChurnRateHistory {
	return ChurnRateHistory{
		Date:      core.CastString(data["date"]),
		ChurnRate: core.CastFloat32(data["churnRate"]),
	}
}

func (p ChurnRateHistory) ToDict() map[string]interface{} {

	var date *string
	if p.Date != nil {
		date = p.Date
	}
	var churnRate *float32
	if p.ChurnRate != nil {
		churnRate = p.ChurnRate
	}
	return map[string]interface{}{
		"date":      date,
		"churnRate": churnRate,
	}
}

func (p ChurnRateHistory) Pointer() *ChurnRateHistory {
	return &p
}

func CastChurnRateHistories(data []interface{}) []ChurnRateHistory {
	v := make([]ChurnRateHistory, 0)
	for _, d := range data {
		v = append(v, NewChurnRateHistoryFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChurnRateHistoriesFromDict(data []ChurnRateHistory) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChurnRateAverage struct {
	ChurnRate *float32 `json:"churnRate"`
}

func (p *ChurnRateAverage) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChurnRateAverage{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChurnRateAverage{}
	} else {
		*p = ChurnRateAverage{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["churnRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ChurnRate)
		}
	}
	return nil
}

func NewChurnRateAverageFromJson(data string) ChurnRateAverage {
	req := ChurnRateAverage{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChurnRateAverageFromDict(data map[string]interface{}) ChurnRateAverage {
	return ChurnRateAverage{
		ChurnRate: core.CastFloat32(data["churnRate"]),
	}
}

func (p ChurnRateAverage) ToDict() map[string]interface{} {

	var churnRate *float32
	if p.ChurnRate != nil {
		churnRate = p.ChurnRate
	}
	return map[string]interface{}{
		"churnRate": churnRate,
	}
}

func (p ChurnRateAverage) Pointer() *ChurnRateAverage {
	return &p
}

func CastChurnRateAverages(data []interface{}) []ChurnRateAverage {
	v := make([]ChurnRateAverage, 0)
	for _, d := range data {
		v = append(v, NewChurnRateAverageFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChurnRateAveragesFromDict(data []ChurnRateAverage) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChurnRateAggregate struct {
	History []ChurnRateHistory `json:"history"`
	Avg     *ChurnRateAverage  `json:"avg"`
}

func (p *ChurnRateAggregate) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChurnRateAggregate{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChurnRateAggregate{}
	} else {
		*p = ChurnRateAggregate{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["history"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.History)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
	}
	return nil
}

func NewChurnRateAggregateFromJson(data string) ChurnRateAggregate {
	req := ChurnRateAggregate{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChurnRateAggregateFromDict(data map[string]interface{}) ChurnRateAggregate {
	return ChurnRateAggregate{
		History: CastChurnRateHistories(core.CastArray(data["history"])),
		Avg:     NewChurnRateAverageFromDict(core.CastMap(data["avg"])).Pointer(),
	}
}

func (p ChurnRateAggregate) ToDict() map[string]interface{} {

	var history []interface{}
	if p.History != nil {
		history = CastChurnRateHistoriesFromDict(
			p.History,
		)
	}
	var avg map[string]interface{}
	if p.Avg != nil {
		avg = p.Avg.ToDict()
	}
	return map[string]interface{}{
		"history": history,
		"avg":     avg,
	}
}

func (p ChurnRateAggregate) Pointer() *ChurnRateAggregate {
	return &p
}

func CastChurnRateAggregates(data []interface{}) []ChurnRateAggregate {
	v := make([]ChurnRateAggregate, 0)
	for _, d := range data {
		v = append(v, NewChurnRateAggregateFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChurnRateAggregatesFromDict(data []ChurnRateAggregate) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type SessionDuration struct {
	Statistics   *SessionDurationStatistics           `json:"statistics"`
	Distribution []SessionDurationDistributionSegment `json:"distribution"`
}

func (p *SessionDuration) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = SessionDuration{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = SessionDuration{}
	} else {
		*p = SessionDuration{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewSessionDurationFromJson(data string) SessionDuration {
	req := SessionDuration{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewSessionDurationFromDict(data map[string]interface{}) SessionDuration {
	return SessionDuration{
		Statistics:   NewSessionDurationStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastSessionDurationDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p SessionDuration) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastSessionDurationDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p SessionDuration) Pointer() *SessionDuration {
	return &p
}

func CastSessionDurations(data []interface{}) []SessionDuration {
	v := make([]SessionDuration, 0)
	for _, d := range data {
		v = append(v, NewSessionDurationFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastSessionDurationsFromDict(data []SessionDuration) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type UseServices struct {
	Account     *bool `json:"account"`
	Chat        *bool `json:"chat"`
	Datastore   *bool `json:"datastore"`
	Dictionary  *bool `json:"dictionary"`
	Exchange    *bool `json:"exchange"`
	Experience  *bool `json:"experience"`
	Formation   *bool `json:"formation"`
	Friend      *bool `json:"friend"`
	Inbox       *bool `json:"inbox"`
	Inventory   *bool `json:"inventory"`
	Key         *bool `json:"key"`
	Limit       *bool `json:"limit"`
	Lottery     *bool `json:"lottery"`
	Matchmaking *bool `json:"matchmaking"`
	Mission     *bool `json:"mission"`
	Money       *bool `json:"money"`
	Quest       *bool `json:"quest"`
	Ranking     *bool `json:"ranking"`
	Showcase    *bool `json:"showcase"`
	Stamina     *bool `json:"stamina"`
}

func (p *UseServices) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = UseServices{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = UseServices{}
	} else {
		*p = UseServices{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["account"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Account)
		}
		if v, ok := d["chat"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Chat)
		}
		if v, ok := d["datastore"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Datastore)
		}
		if v, ok := d["dictionary"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Dictionary)
		}
		if v, ok := d["exchange"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Exchange)
		}
		if v, ok := d["experience"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Experience)
		}
		if v, ok := d["formation"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Formation)
		}
		if v, ok := d["friend"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Friend)
		}
		if v, ok := d["inbox"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Inbox)
		}
		if v, ok := d["inventory"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Inventory)
		}
		if v, ok := d["key"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Key)
		}
		if v, ok := d["limit"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Limit)
		}
		if v, ok := d["lottery"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Lottery)
		}
		if v, ok := d["matchmaking"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Matchmaking)
		}
		if v, ok := d["mission"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Mission)
		}
		if v, ok := d["money"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Money)
		}
		if v, ok := d["quest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Quest)
		}
		if v, ok := d["ranking"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Ranking)
		}
		if v, ok := d["showcase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Showcase)
		}
		if v, ok := d["stamina"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stamina)
		}
	}
	return nil
}

func NewUseServicesFromJson(data string) UseServices {
	req := UseServices{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewUseServicesFromDict(data map[string]interface{}) UseServices {
	return UseServices{
		Account:     core.CastBool(data["account"]),
		Chat:        core.CastBool(data["chat"]),
		Datastore:   core.CastBool(data["datastore"]),
		Dictionary:  core.CastBool(data["dictionary"]),
		Exchange:    core.CastBool(data["exchange"]),
		Experience:  core.CastBool(data["experience"]),
		Formation:   core.CastBool(data["formation"]),
		Friend:      core.CastBool(data["friend"]),
		Inbox:       core.CastBool(data["inbox"]),
		Inventory:   core.CastBool(data["inventory"]),
		Key:         core.CastBool(data["key"]),
		Limit:       core.CastBool(data["limit"]),
		Lottery:     core.CastBool(data["lottery"]),
		Matchmaking: core.CastBool(data["matchmaking"]),
		Mission:     core.CastBool(data["mission"]),
		Money:       core.CastBool(data["money"]),
		Quest:       core.CastBool(data["quest"]),
		Ranking:     core.CastBool(data["ranking"]),
		Showcase:    core.CastBool(data["showcase"]),
		Stamina:     core.CastBool(data["stamina"]),
	}
}

func (p UseServices) ToDict() map[string]interface{} {

	var account *bool
	if p.Account != nil {
		account = p.Account
	}
	var chat *bool
	if p.Chat != nil {
		chat = p.Chat
	}
	var datastore *bool
	if p.Datastore != nil {
		datastore = p.Datastore
	}
	var dictionary *bool
	if p.Dictionary != nil {
		dictionary = p.Dictionary
	}
	var exchange *bool
	if p.Exchange != nil {
		exchange = p.Exchange
	}
	var experience *bool
	if p.Experience != nil {
		experience = p.Experience
	}
	var formation *bool
	if p.Formation != nil {
		formation = p.Formation
	}
	var friend *bool
	if p.Friend != nil {
		friend = p.Friend
	}
	var inbox *bool
	if p.Inbox != nil {
		inbox = p.Inbox
	}
	var inventory *bool
	if p.Inventory != nil {
		inventory = p.Inventory
	}
	var key *bool
	if p.Key != nil {
		key = p.Key
	}
	var limit *bool
	if p.Limit != nil {
		limit = p.Limit
	}
	var lottery *bool
	if p.Lottery != nil {
		lottery = p.Lottery
	}
	var matchmaking *bool
	if p.Matchmaking != nil {
		matchmaking = p.Matchmaking
	}
	var mission *bool
	if p.Mission != nil {
		mission = p.Mission
	}
	var money *bool
	if p.Money != nil {
		money = p.Money
	}
	var quest *bool
	if p.Quest != nil {
		quest = p.Quest
	}
	var ranking *bool
	if p.Ranking != nil {
		ranking = p.Ranking
	}
	var showcase *bool
	if p.Showcase != nil {
		showcase = p.Showcase
	}
	var stamina *bool
	if p.Stamina != nil {
		stamina = p.Stamina
	}
	return map[string]interface{}{
		"account":     account,
		"chat":        chat,
		"datastore":   datastore,
		"dictionary":  dictionary,
		"exchange":    exchange,
		"experience":  experience,
		"formation":   formation,
		"friend":      friend,
		"inbox":       inbox,
		"inventory":   inventory,
		"key":         key,
		"limit":       limit,
		"lottery":     lottery,
		"matchmaking": matchmaking,
		"mission":     mission,
		"money":       money,
		"quest":       quest,
		"ranking":     ranking,
		"showcase":    showcase,
		"stamina":     stamina,
	}
}

func (p UseServices) Pointer() *UseServices {
	return &p
}

func CastUseServiceses(data []interface{}) []UseServices {
	v := make([]UseServices, 0)
	for _, d := range data {
		v = append(v, NewUseServicesFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastUseServicesesFromDict(data []UseServices) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type GeneralMetrics struct {
	DauWauMau       *GeneralDauWauMau   `json:"dauWauMau"`
	SessionDuration *SessionDuration    `json:"sessionDuration"`
	FirstEngagement *FirstEngagement    `json:"firstEngagement"`
	Engagements     *Engagements        `json:"engagements"`
	ChurnRates      *ChurnRateAggregate `json:"churnRates"`
	UseServices     *UseServices        `json:"useServices"`
}

func (p *GeneralMetrics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = GeneralMetrics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = GeneralMetrics{}
	} else {
		*p = GeneralMetrics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["dauWauMau"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DauWauMau)
		}
		if v, ok := d["sessionDuration"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SessionDuration)
		}
		if v, ok := d["firstEngagement"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.FirstEngagement)
		}
		if v, ok := d["engagements"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Engagements)
		}
		if v, ok := d["churnRates"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ChurnRates)
		}
		if v, ok := d["useServices"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.UseServices)
		}
	}
	return nil
}

func NewGeneralMetricsFromJson(data string) GeneralMetrics {
	req := GeneralMetrics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewGeneralMetricsFromDict(data map[string]interface{}) GeneralMetrics {
	return GeneralMetrics{
		DauWauMau:       NewGeneralDauWauMauFromDict(core.CastMap(data["dauWauMau"])).Pointer(),
		SessionDuration: NewSessionDurationFromDict(core.CastMap(data["sessionDuration"])).Pointer(),
		FirstEngagement: NewFirstEngagementFromDict(core.CastMap(data["firstEngagement"])).Pointer(),
		Engagements:     NewEngagementsFromDict(core.CastMap(data["engagements"])).Pointer(),
		ChurnRates:      NewChurnRateAggregateFromDict(core.CastMap(data["churnRates"])).Pointer(),
		UseServices:     NewUseServicesFromDict(core.CastMap(data["useServices"])).Pointer(),
	}
}

func (p GeneralMetrics) ToDict() map[string]interface{} {

	var dauWauMau map[string]interface{}
	if p.DauWauMau != nil {
		dauWauMau = p.DauWauMau.ToDict()
	}
	var sessionDuration map[string]interface{}
	if p.SessionDuration != nil {
		sessionDuration = p.SessionDuration.ToDict()
	}
	var firstEngagement map[string]interface{}
	if p.FirstEngagement != nil {
		firstEngagement = p.FirstEngagement.ToDict()
	}
	var engagements map[string]interface{}
	if p.Engagements != nil {
		engagements = p.Engagements.ToDict()
	}
	var churnRates map[string]interface{}
	if p.ChurnRates != nil {
		churnRates = p.ChurnRates.ToDict()
	}
	var useServices map[string]interface{}
	if p.UseServices != nil {
		useServices = p.UseServices.ToDict()
	}
	return map[string]interface{}{
		"dauWauMau":       dauWauMau,
		"sessionDuration": sessionDuration,
		"firstEngagement": firstEngagement,
		"engagements":     engagements,
		"churnRates":      churnRates,
		"useServices":     useServices,
	}
}

func (p GeneralMetrics) Pointer() *GeneralMetrics {
	return &p
}

func CastGeneralMetricses(data []interface{}) []GeneralMetrics {
	v := make([]GeneralMetrics, 0)
	for _, d := range data {
		v = append(v, NewGeneralMetricsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastGeneralMetricsesFromDict(data []GeneralMetrics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespaceStatistics struct {
	Signup             *int64 `json:"signup"`
	Authentication     *int64 `json:"authentication"`
	RegisteredTakeOver *int64 `json:"registeredTakeOver"`
	RemoveTakeOver     *int64 `json:"removeTakeOver"`
	ExecuteTakeOver    *int64 `json:"executeTakeOver"`
}

func (p *AccountNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespaceStatistics{}
	} else {
		*p = AccountNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["signup"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Signup)
		}
		if v, ok := d["authentication"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Authentication)
		}
		if v, ok := d["registeredTakeOver"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RegisteredTakeOver)
		}
		if v, ok := d["removeTakeOver"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RemoveTakeOver)
		}
		if v, ok := d["executeTakeOver"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExecuteTakeOver)
		}
	}
	return nil
}

func NewAccountNamespaceStatisticsFromJson(data string) AccountNamespaceStatistics {
	req := AccountNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceStatisticsFromDict(data map[string]interface{}) AccountNamespaceStatistics {
	return AccountNamespaceStatistics{
		Signup:             core.CastInt64(data["signup"]),
		Authentication:     core.CastInt64(data["authentication"]),
		RegisteredTakeOver: core.CastInt64(data["registeredTakeOver"]),
		RemoveTakeOver:     core.CastInt64(data["removeTakeOver"]),
		ExecuteTakeOver:    core.CastInt64(data["executeTakeOver"]),
	}
}

func (p AccountNamespaceStatistics) ToDict() map[string]interface{} {

	var signup *int64
	if p.Signup != nil {
		signup = p.Signup
	}
	var authentication *int64
	if p.Authentication != nil {
		authentication = p.Authentication
	}
	var registeredTakeOver *int64
	if p.RegisteredTakeOver != nil {
		registeredTakeOver = p.RegisteredTakeOver
	}
	var removeTakeOver *int64
	if p.RemoveTakeOver != nil {
		removeTakeOver = p.RemoveTakeOver
	}
	var executeTakeOver *int64
	if p.ExecuteTakeOver != nil {
		executeTakeOver = p.ExecuteTakeOver
	}
	return map[string]interface{}{
		"signup":             signup,
		"authentication":     authentication,
		"registeredTakeOver": registeredTakeOver,
		"removeTakeOver":     removeTakeOver,
		"executeTakeOver":    executeTakeOver,
	}
}

func (p AccountNamespaceStatistics) Pointer() *AccountNamespaceStatistics {
	return &p
}

func CastAccountNamespaceStatisticses(data []interface{}) []AccountNamespaceStatistics {
	v := make([]AccountNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespaceStatisticsesFromDict(data []AccountNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespaceTypeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *AccountNamespaceTypeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespaceTypeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespaceTypeDistributionStatistics{}
	} else {
		*p = AccountNamespaceTypeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewAccountNamespaceTypeDistributionStatisticsFromJson(data string) AccountNamespaceTypeDistributionStatistics {
	req := AccountNamespaceTypeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceTypeDistributionStatisticsFromDict(data map[string]interface{}) AccountNamespaceTypeDistributionStatistics {
	return AccountNamespaceTypeDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p AccountNamespaceTypeDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p AccountNamespaceTypeDistributionStatistics) Pointer() *AccountNamespaceTypeDistributionStatistics {
	return &p
}

func CastAccountNamespaceTypeDistributionStatisticses(data []interface{}) []AccountNamespaceTypeDistributionStatistics {
	v := make([]AccountNamespaceTypeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceTypeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespaceTypeDistributionStatisticsesFromDict(data []AccountNamespaceTypeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespaceTypeDistributionSegment struct {
	Type  *int64 `json:"type"`
	Count *int64 `json:"count"`
}

func (p *AccountNamespaceTypeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespaceTypeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespaceTypeDistributionSegment{}
	} else {
		*p = AccountNamespaceTypeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["type"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Type)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewAccountNamespaceTypeDistributionSegmentFromJson(data string) AccountNamespaceTypeDistributionSegment {
	req := AccountNamespaceTypeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceTypeDistributionSegmentFromDict(data map[string]interface{}) AccountNamespaceTypeDistributionSegment {
	return AccountNamespaceTypeDistributionSegment{
		Type:  core.CastInt64(data["type"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p AccountNamespaceTypeDistributionSegment) ToDict() map[string]interface{} {

	var _type *int64
	if p.Type != nil {
		_type = p.Type
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"type":  _type,
		"count": count,
	}
}

func (p AccountNamespaceTypeDistributionSegment) Pointer() *AccountNamespaceTypeDistributionSegment {
	return &p
}

func CastAccountNamespaceTypeDistributionSegments(data []interface{}) []AccountNamespaceTypeDistributionSegment {
	v := make([]AccountNamespaceTypeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceTypeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespaceTypeDistributionSegmentsFromDict(data []AccountNamespaceTypeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespaceTypeDistribution struct {
	Statistics   *AccountNamespaceTypeDistributionStatistics `json:"statistics"`
	Distribution []AccountNamespaceTypeDistributionSegment   `json:"distribution"`
}

func (p *AccountNamespaceTypeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespaceTypeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespaceTypeDistribution{}
	} else {
		*p = AccountNamespaceTypeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewAccountNamespaceTypeDistributionFromJson(data string) AccountNamespaceTypeDistribution {
	req := AccountNamespaceTypeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceTypeDistributionFromDict(data map[string]interface{}) AccountNamespaceTypeDistribution {
	return AccountNamespaceTypeDistribution{
		Statistics:   NewAccountNamespaceTypeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastAccountNamespaceTypeDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p AccountNamespaceTypeDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastAccountNamespaceTypeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p AccountNamespaceTypeDistribution) Pointer() *AccountNamespaceTypeDistribution {
	return &p
}

func CastAccountNamespaceTypeDistributions(data []interface{}) []AccountNamespaceTypeDistribution {
	v := make([]AccountNamespaceTypeDistribution, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceTypeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespaceTypeDistributionsFromDict(data []AccountNamespaceTypeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespaceDistributions struct {
	Type *AccountNamespaceTypeDistribution `json:"type"`
}

func (p *AccountNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespaceDistributions{}
	} else {
		*p = AccountNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["type"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Type)
		}
	}
	return nil
}

func NewAccountNamespaceDistributionsFromJson(data string) AccountNamespaceDistributions {
	req := AccountNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceDistributionsFromDict(data map[string]interface{}) AccountNamespaceDistributions {
	return AccountNamespaceDistributions{
		Type: NewAccountNamespaceTypeDistributionFromDict(core.CastMap(data["type"])).Pointer(),
	}
}

func (p AccountNamespaceDistributions) ToDict() map[string]interface{} {

	var _type map[string]interface{}
	if p.Type != nil {
		_type = p.Type.ToDict()
	}
	return map[string]interface{}{
		"type": _type,
	}
}

func (p AccountNamespaceDistributions) Pointer() *AccountNamespaceDistributions {
	return &p
}

func CastAccountNamespaceDistributionses(data []interface{}) []AccountNamespaceDistributions {
	v := make([]AccountNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespaceDistributionsesFromDict(data []AccountNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespace struct {
	NamespaceId   *string                        `json:"namespaceId"`
	Year          *int32                         `json:"year"`
	Month         *int32                         `json:"month"`
	Day           *int32                         `json:"day"`
	NamespaceName *string                        `json:"namespaceName"`
	Statistics    *AccountNamespaceStatistics    `json:"statistics"`
	Distributions *AccountNamespaceDistributions `json:"distributions"`
}

func (p *AccountNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespace{}
	} else {
		*p = AccountNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewAccountNamespaceFromJson(data string) AccountNamespace {
	req := AccountNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceFromDict(data map[string]interface{}) AccountNamespace {
	return AccountNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewAccountNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewAccountNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p AccountNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p AccountNamespace) Pointer() *AccountNamespace {
	return &p
}

func CastAccountNamespaces(data []interface{}) []AccountNamespace {
	v := make([]AccountNamespace, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespacesFromDict(data []AccountNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespaceStatistics struct {
	Post            *int64 `json:"post"`
	CreateRoom      *int64 `json:"createRoom"`
	DeleteRoom      *int64 `json:"deleteRoom"`
	CreateSubscribe *int64 `json:"createSubscribe"`
	DeleteSubscribe *int64 `json:"deleteSubscribe"`
}

func (p *ChatNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespaceStatistics{}
	} else {
		*p = ChatNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["post"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Post)
		}
		if v, ok := d["createRoom"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CreateRoom)
		}
		if v, ok := d["deleteRoom"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DeleteRoom)
		}
		if v, ok := d["createSubscribe"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CreateSubscribe)
		}
		if v, ok := d["deleteSubscribe"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DeleteSubscribe)
		}
	}
	return nil
}

func NewChatNamespaceStatisticsFromJson(data string) ChatNamespaceStatistics {
	req := ChatNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespaceStatisticsFromDict(data map[string]interface{}) ChatNamespaceStatistics {
	return ChatNamespaceStatistics{
		Post:            core.CastInt64(data["post"]),
		CreateRoom:      core.CastInt64(data["createRoom"]),
		DeleteRoom:      core.CastInt64(data["deleteRoom"]),
		CreateSubscribe: core.CastInt64(data["createSubscribe"]),
		DeleteSubscribe: core.CastInt64(data["deleteSubscribe"]),
	}
}

func (p ChatNamespaceStatistics) ToDict() map[string]interface{} {

	var post *int64
	if p.Post != nil {
		post = p.Post
	}
	var createRoom *int64
	if p.CreateRoom != nil {
		createRoom = p.CreateRoom
	}
	var deleteRoom *int64
	if p.DeleteRoom != nil {
		deleteRoom = p.DeleteRoom
	}
	var createSubscribe *int64
	if p.CreateSubscribe != nil {
		createSubscribe = p.CreateSubscribe
	}
	var deleteSubscribe *int64
	if p.DeleteSubscribe != nil {
		deleteSubscribe = p.DeleteSubscribe
	}
	return map[string]interface{}{
		"post":            post,
		"createRoom":      createRoom,
		"deleteRoom":      deleteRoom,
		"createSubscribe": createSubscribe,
		"deleteSubscribe": deleteSubscribe,
	}
}

func (p ChatNamespaceStatistics) Pointer() *ChatNamespaceStatistics {
	return &p
}

func CastChatNamespaceStatisticses(data []interface{}) []ChatNamespaceStatistics {
	v := make([]ChatNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewChatNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespaceStatisticsesFromDict(data []ChatNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByRoomDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ChatNamespacePostByRoomDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByRoomDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByRoomDistributionStatistics{}
	} else {
		*p = ChatNamespacePostByRoomDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewChatNamespacePostByRoomDistributionStatisticsFromJson(data string) ChatNamespacePostByRoomDistributionStatistics {
	req := ChatNamespacePostByRoomDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByRoomDistributionStatisticsFromDict(data map[string]interface{}) ChatNamespacePostByRoomDistributionStatistics {
	return ChatNamespacePostByRoomDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ChatNamespacePostByRoomDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ChatNamespacePostByRoomDistributionStatistics) Pointer() *ChatNamespacePostByRoomDistributionStatistics {
	return &p
}

func CastChatNamespacePostByRoomDistributionStatisticses(data []interface{}) []ChatNamespacePostByRoomDistributionStatistics {
	v := make([]ChatNamespacePostByRoomDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByRoomDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByRoomDistributionStatisticsesFromDict(data []ChatNamespacePostByRoomDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByRoomDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ChatNamespacePostByRoomDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByRoomDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByRoomDistributionSegment{}
	} else {
		*p = ChatNamespacePostByRoomDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewChatNamespacePostByRoomDistributionSegmentFromJson(data string) ChatNamespacePostByRoomDistributionSegment {
	req := ChatNamespacePostByRoomDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByRoomDistributionSegmentFromDict(data map[string]interface{}) ChatNamespacePostByRoomDistributionSegment {
	return ChatNamespacePostByRoomDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ChatNamespacePostByRoomDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ChatNamespacePostByRoomDistributionSegment) Pointer() *ChatNamespacePostByRoomDistributionSegment {
	return &p
}

func CastChatNamespacePostByRoomDistributionSegments(data []interface{}) []ChatNamespacePostByRoomDistributionSegment {
	v := make([]ChatNamespacePostByRoomDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByRoomDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByRoomDistributionSegmentsFromDict(data []ChatNamespacePostByRoomDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByRoomDistribution struct {
	Statistics   *ChatNamespacePostByRoomDistributionStatistics `json:"statistics"`
	Distribution []ChatNamespacePostByRoomDistributionSegment   `json:"distribution"`
}

func (p *ChatNamespacePostByRoomDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByRoomDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByRoomDistribution{}
	} else {
		*p = ChatNamespacePostByRoomDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewChatNamespacePostByRoomDistributionFromJson(data string) ChatNamespacePostByRoomDistribution {
	req := ChatNamespacePostByRoomDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByRoomDistributionFromDict(data map[string]interface{}) ChatNamespacePostByRoomDistribution {
	return ChatNamespacePostByRoomDistribution{
		Statistics:   NewChatNamespacePostByRoomDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastChatNamespacePostByRoomDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ChatNamespacePostByRoomDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastChatNamespacePostByRoomDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ChatNamespacePostByRoomDistribution) Pointer() *ChatNamespacePostByRoomDistribution {
	return &p
}

func CastChatNamespacePostByRoomDistributions(data []interface{}) []ChatNamespacePostByRoomDistribution {
	v := make([]ChatNamespacePostByRoomDistribution, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByRoomDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByRoomDistributionsFromDict(data []ChatNamespacePostByRoomDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ChatNamespacePostByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByUserDistributionStatistics{}
	} else {
		*p = ChatNamespacePostByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewChatNamespacePostByUserDistributionStatisticsFromJson(data string) ChatNamespacePostByUserDistributionStatistics {
	req := ChatNamespacePostByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByUserDistributionStatisticsFromDict(data map[string]interface{}) ChatNamespacePostByUserDistributionStatistics {
	return ChatNamespacePostByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ChatNamespacePostByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ChatNamespacePostByUserDistributionStatistics) Pointer() *ChatNamespacePostByUserDistributionStatistics {
	return &p
}

func CastChatNamespacePostByUserDistributionStatisticses(data []interface{}) []ChatNamespacePostByUserDistributionStatistics {
	v := make([]ChatNamespacePostByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByUserDistributionStatisticsesFromDict(data []ChatNamespacePostByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ChatNamespacePostByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByUserDistributionSegment{}
	} else {
		*p = ChatNamespacePostByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewChatNamespacePostByUserDistributionSegmentFromJson(data string) ChatNamespacePostByUserDistributionSegment {
	req := ChatNamespacePostByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByUserDistributionSegmentFromDict(data map[string]interface{}) ChatNamespacePostByUserDistributionSegment {
	return ChatNamespacePostByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ChatNamespacePostByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ChatNamespacePostByUserDistributionSegment) Pointer() *ChatNamespacePostByUserDistributionSegment {
	return &p
}

func CastChatNamespacePostByUserDistributionSegments(data []interface{}) []ChatNamespacePostByUserDistributionSegment {
	v := make([]ChatNamespacePostByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByUserDistributionSegmentsFromDict(data []ChatNamespacePostByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByUserDistribution struct {
	Statistics   *ChatNamespacePostByUserDistributionStatistics `json:"statistics"`
	Distribution []ChatNamespacePostByUserDistributionSegment   `json:"distribution"`
}

func (p *ChatNamespacePostByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByUserDistribution{}
	} else {
		*p = ChatNamespacePostByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewChatNamespacePostByUserDistributionFromJson(data string) ChatNamespacePostByUserDistribution {
	req := ChatNamespacePostByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByUserDistributionFromDict(data map[string]interface{}) ChatNamespacePostByUserDistribution {
	return ChatNamespacePostByUserDistribution{
		Statistics:   NewChatNamespacePostByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastChatNamespacePostByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ChatNamespacePostByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastChatNamespacePostByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ChatNamespacePostByUserDistribution) Pointer() *ChatNamespacePostByUserDistribution {
	return &p
}

func CastChatNamespacePostByUserDistributions(data []interface{}) []ChatNamespacePostByUserDistribution {
	v := make([]ChatNamespacePostByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByUserDistributionsFromDict(data []ChatNamespacePostByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByCategoryDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ChatNamespacePostByCategoryDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByCategoryDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByCategoryDistributionStatistics{}
	} else {
		*p = ChatNamespacePostByCategoryDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewChatNamespacePostByCategoryDistributionStatisticsFromJson(data string) ChatNamespacePostByCategoryDistributionStatistics {
	req := ChatNamespacePostByCategoryDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByCategoryDistributionStatisticsFromDict(data map[string]interface{}) ChatNamespacePostByCategoryDistributionStatistics {
	return ChatNamespacePostByCategoryDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ChatNamespacePostByCategoryDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ChatNamespacePostByCategoryDistributionStatistics) Pointer() *ChatNamespacePostByCategoryDistributionStatistics {
	return &p
}

func CastChatNamespacePostByCategoryDistributionStatisticses(data []interface{}) []ChatNamespacePostByCategoryDistributionStatistics {
	v := make([]ChatNamespacePostByCategoryDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByCategoryDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByCategoryDistributionStatisticsesFromDict(data []ChatNamespacePostByCategoryDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByCategoryDistributionSegment struct {
	Category *int64 `json:"category"`
	Count    *int64 `json:"count"`
}

func (p *ChatNamespacePostByCategoryDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByCategoryDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByCategoryDistributionSegment{}
	} else {
		*p = ChatNamespacePostByCategoryDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["category"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Category)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewChatNamespacePostByCategoryDistributionSegmentFromJson(data string) ChatNamespacePostByCategoryDistributionSegment {
	req := ChatNamespacePostByCategoryDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByCategoryDistributionSegmentFromDict(data map[string]interface{}) ChatNamespacePostByCategoryDistributionSegment {
	return ChatNamespacePostByCategoryDistributionSegment{
		Category: core.CastInt64(data["category"]),
		Count:    core.CastInt64(data["count"]),
	}
}

func (p ChatNamespacePostByCategoryDistributionSegment) ToDict() map[string]interface{} {

	var category *int64
	if p.Category != nil {
		category = p.Category
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"category": category,
		"count":    count,
	}
}

func (p ChatNamespacePostByCategoryDistributionSegment) Pointer() *ChatNamespacePostByCategoryDistributionSegment {
	return &p
}

func CastChatNamespacePostByCategoryDistributionSegments(data []interface{}) []ChatNamespacePostByCategoryDistributionSegment {
	v := make([]ChatNamespacePostByCategoryDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByCategoryDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByCategoryDistributionSegmentsFromDict(data []ChatNamespacePostByCategoryDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByCategoryDistribution struct {
	Statistics   *ChatNamespacePostByCategoryDistributionStatistics `json:"statistics"`
	Distribution []ChatNamespacePostByCategoryDistributionSegment   `json:"distribution"`
}

func (p *ChatNamespacePostByCategoryDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByCategoryDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByCategoryDistribution{}
	} else {
		*p = ChatNamespacePostByCategoryDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewChatNamespacePostByCategoryDistributionFromJson(data string) ChatNamespacePostByCategoryDistribution {
	req := ChatNamespacePostByCategoryDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByCategoryDistributionFromDict(data map[string]interface{}) ChatNamespacePostByCategoryDistribution {
	return ChatNamespacePostByCategoryDistribution{
		Statistics:   NewChatNamespacePostByCategoryDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastChatNamespacePostByCategoryDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ChatNamespacePostByCategoryDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastChatNamespacePostByCategoryDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ChatNamespacePostByCategoryDistribution) Pointer() *ChatNamespacePostByCategoryDistribution {
	return &p
}

func CastChatNamespacePostByCategoryDistributions(data []interface{}) []ChatNamespacePostByCategoryDistribution {
	v := make([]ChatNamespacePostByCategoryDistribution, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByCategoryDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByCategoryDistributionsFromDict(data []ChatNamespacePostByCategoryDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespaceDistributions struct {
	PostByRoom     *ChatNamespacePostByRoomDistribution     `json:"postByRoom"`
	PostByUser     *ChatNamespacePostByUserDistribution     `json:"postByUser"`
	PostByCategory *ChatNamespacePostByCategoryDistribution `json:"postByCategory"`
}

func (p *ChatNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespaceDistributions{}
	} else {
		*p = ChatNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["postByRoom"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.PostByRoom)
		}
		if v, ok := d["postByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.PostByUser)
		}
		if v, ok := d["postByCategory"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.PostByCategory)
		}
	}
	return nil
}

func NewChatNamespaceDistributionsFromJson(data string) ChatNamespaceDistributions {
	req := ChatNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespaceDistributionsFromDict(data map[string]interface{}) ChatNamespaceDistributions {
	return ChatNamespaceDistributions{
		PostByRoom:     NewChatNamespacePostByRoomDistributionFromDict(core.CastMap(data["postByRoom"])).Pointer(),
		PostByUser:     NewChatNamespacePostByUserDistributionFromDict(core.CastMap(data["postByUser"])).Pointer(),
		PostByCategory: NewChatNamespacePostByCategoryDistributionFromDict(core.CastMap(data["postByCategory"])).Pointer(),
	}
}

func (p ChatNamespaceDistributions) ToDict() map[string]interface{} {

	var postByRoom map[string]interface{}
	if p.PostByRoom != nil {
		postByRoom = p.PostByRoom.ToDict()
	}
	var postByUser map[string]interface{}
	if p.PostByUser != nil {
		postByUser = p.PostByUser.ToDict()
	}
	var postByCategory map[string]interface{}
	if p.PostByCategory != nil {
		postByCategory = p.PostByCategory.ToDict()
	}
	return map[string]interface{}{
		"postByRoom":     postByRoom,
		"postByUser":     postByUser,
		"postByCategory": postByCategory,
	}
}

func (p ChatNamespaceDistributions) Pointer() *ChatNamespaceDistributions {
	return &p
}

func CastChatNamespaceDistributionses(data []interface{}) []ChatNamespaceDistributions {
	v := make([]ChatNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewChatNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespaceDistributionsesFromDict(data []ChatNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespace struct {
	NamespaceId   *string                     `json:"namespaceId"`
	Year          *int32                      `json:"year"`
	Month         *int32                      `json:"month"`
	Day           *int32                      `json:"day"`
	NamespaceName *string                     `json:"namespaceName"`
	Statistics    *ChatNamespaceStatistics    `json:"statistics"`
	Distributions *ChatNamespaceDistributions `json:"distributions"`
}

func (p *ChatNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespace{}
	} else {
		*p = ChatNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewChatNamespaceFromJson(data string) ChatNamespace {
	req := ChatNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespaceFromDict(data map[string]interface{}) ChatNamespace {
	return ChatNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewChatNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewChatNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p ChatNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p ChatNamespace) Pointer() *ChatNamespace {
	return &p
}

func CastChatNamespaces(data []interface{}) []ChatNamespace {
	v := make([]ChatNamespace, 0)
	for _, d := range data {
		v = append(v, NewChatNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacesFromDict(data []ChatNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceStatistics struct {
	Upload   *int64 `json:"upload"`
	Download *int64 `json:"download"`
}

func (p *DatastoreNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceStatistics{}
	} else {
		*p = DatastoreNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["upload"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Upload)
		}
		if v, ok := d["download"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Download)
		}
	}
	return nil
}

func NewDatastoreNamespaceStatisticsFromJson(data string) DatastoreNamespaceStatistics {
	req := DatastoreNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceStatisticsFromDict(data map[string]interface{}) DatastoreNamespaceStatistics {
	return DatastoreNamespaceStatistics{
		Upload:   core.CastInt64(data["upload"]),
		Download: core.CastInt64(data["download"]),
	}
}

func (p DatastoreNamespaceStatistics) ToDict() map[string]interface{} {

	var upload *int64
	if p.Upload != nil {
		upload = p.Upload
	}
	var download *int64
	if p.Download != nil {
		download = p.Download
	}
	return map[string]interface{}{
		"upload":   upload,
		"download": download,
	}
}

func (p DatastoreNamespaceStatistics) Pointer() *DatastoreNamespaceStatistics {
	return &p
}

func CastDatastoreNamespaceStatisticses(data []interface{}) []DatastoreNamespaceStatistics {
	v := make([]DatastoreNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceStatisticsesFromDict(data []DatastoreNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDownloadByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *DatastoreNamespaceDownloadByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDownloadByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDownloadByUserDistributionStatistics{}
	} else {
		*p = DatastoreNamespaceDownloadByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewDatastoreNamespaceDownloadByUserDistributionStatisticsFromJson(data string) DatastoreNamespaceDownloadByUserDistributionStatistics {
	req := DatastoreNamespaceDownloadByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDownloadByUserDistributionStatisticsFromDict(data map[string]interface{}) DatastoreNamespaceDownloadByUserDistributionStatistics {
	return DatastoreNamespaceDownloadByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p DatastoreNamespaceDownloadByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p DatastoreNamespaceDownloadByUserDistributionStatistics) Pointer() *DatastoreNamespaceDownloadByUserDistributionStatistics {
	return &p
}

func CastDatastoreNamespaceDownloadByUserDistributionStatisticses(data []interface{}) []DatastoreNamespaceDownloadByUserDistributionStatistics {
	v := make([]DatastoreNamespaceDownloadByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDownloadByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDownloadByUserDistributionStatisticsesFromDict(data []DatastoreNamespaceDownloadByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDownloadByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *DatastoreNamespaceDownloadByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDownloadByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDownloadByUserDistributionSegment{}
	} else {
		*p = DatastoreNamespaceDownloadByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewDatastoreNamespaceDownloadByUserDistributionSegmentFromJson(data string) DatastoreNamespaceDownloadByUserDistributionSegment {
	req := DatastoreNamespaceDownloadByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDownloadByUserDistributionSegmentFromDict(data map[string]interface{}) DatastoreNamespaceDownloadByUserDistributionSegment {
	return DatastoreNamespaceDownloadByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p DatastoreNamespaceDownloadByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p DatastoreNamespaceDownloadByUserDistributionSegment) Pointer() *DatastoreNamespaceDownloadByUserDistributionSegment {
	return &p
}

func CastDatastoreNamespaceDownloadByUserDistributionSegments(data []interface{}) []DatastoreNamespaceDownloadByUserDistributionSegment {
	v := make([]DatastoreNamespaceDownloadByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDownloadByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDownloadByUserDistributionSegmentsFromDict(data []DatastoreNamespaceDownloadByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDownloadByUserDistribution struct {
	Statistics   *DatastoreNamespaceDownloadByUserDistributionStatistics `json:"statistics"`
	Distribution []DatastoreNamespaceDownloadByUserDistributionSegment   `json:"distribution"`
}

func (p *DatastoreNamespaceDownloadByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDownloadByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDownloadByUserDistribution{}
	} else {
		*p = DatastoreNamespaceDownloadByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewDatastoreNamespaceDownloadByUserDistributionFromJson(data string) DatastoreNamespaceDownloadByUserDistribution {
	req := DatastoreNamespaceDownloadByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDownloadByUserDistributionFromDict(data map[string]interface{}) DatastoreNamespaceDownloadByUserDistribution {
	return DatastoreNamespaceDownloadByUserDistribution{
		Statistics:   NewDatastoreNamespaceDownloadByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastDatastoreNamespaceDownloadByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p DatastoreNamespaceDownloadByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastDatastoreNamespaceDownloadByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p DatastoreNamespaceDownloadByUserDistribution) Pointer() *DatastoreNamespaceDownloadByUserDistribution {
	return &p
}

func CastDatastoreNamespaceDownloadByUserDistributions(data []interface{}) []DatastoreNamespaceDownloadByUserDistribution {
	v := make([]DatastoreNamespaceDownloadByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDownloadByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDownloadByUserDistributionsFromDict(data []DatastoreNamespaceDownloadByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceUploadByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *DatastoreNamespaceUploadByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceUploadByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceUploadByUserDistributionStatistics{}
	} else {
		*p = DatastoreNamespaceUploadByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewDatastoreNamespaceUploadByUserDistributionStatisticsFromJson(data string) DatastoreNamespaceUploadByUserDistributionStatistics {
	req := DatastoreNamespaceUploadByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceUploadByUserDistributionStatisticsFromDict(data map[string]interface{}) DatastoreNamespaceUploadByUserDistributionStatistics {
	return DatastoreNamespaceUploadByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p DatastoreNamespaceUploadByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p DatastoreNamespaceUploadByUserDistributionStatistics) Pointer() *DatastoreNamespaceUploadByUserDistributionStatistics {
	return &p
}

func CastDatastoreNamespaceUploadByUserDistributionStatisticses(data []interface{}) []DatastoreNamespaceUploadByUserDistributionStatistics {
	v := make([]DatastoreNamespaceUploadByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceUploadByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceUploadByUserDistributionStatisticsesFromDict(data []DatastoreNamespaceUploadByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceUploadByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *DatastoreNamespaceUploadByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceUploadByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceUploadByUserDistributionSegment{}
	} else {
		*p = DatastoreNamespaceUploadByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewDatastoreNamespaceUploadByUserDistributionSegmentFromJson(data string) DatastoreNamespaceUploadByUserDistributionSegment {
	req := DatastoreNamespaceUploadByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceUploadByUserDistributionSegmentFromDict(data map[string]interface{}) DatastoreNamespaceUploadByUserDistributionSegment {
	return DatastoreNamespaceUploadByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p DatastoreNamespaceUploadByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p DatastoreNamespaceUploadByUserDistributionSegment) Pointer() *DatastoreNamespaceUploadByUserDistributionSegment {
	return &p
}

func CastDatastoreNamespaceUploadByUserDistributionSegments(data []interface{}) []DatastoreNamespaceUploadByUserDistributionSegment {
	v := make([]DatastoreNamespaceUploadByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceUploadByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceUploadByUserDistributionSegmentsFromDict(data []DatastoreNamespaceUploadByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceUploadByUserDistribution struct {
	Statistics   *DatastoreNamespaceUploadByUserDistributionStatistics `json:"statistics"`
	Distribution []DatastoreNamespaceUploadByUserDistributionSegment   `json:"distribution"`
}

func (p *DatastoreNamespaceUploadByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceUploadByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceUploadByUserDistribution{}
	} else {
		*p = DatastoreNamespaceUploadByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewDatastoreNamespaceUploadByUserDistributionFromJson(data string) DatastoreNamespaceUploadByUserDistribution {
	req := DatastoreNamespaceUploadByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceUploadByUserDistributionFromDict(data map[string]interface{}) DatastoreNamespaceUploadByUserDistribution {
	return DatastoreNamespaceUploadByUserDistribution{
		Statistics:   NewDatastoreNamespaceUploadByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastDatastoreNamespaceUploadByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p DatastoreNamespaceUploadByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastDatastoreNamespaceUploadByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p DatastoreNamespaceUploadByUserDistribution) Pointer() *DatastoreNamespaceUploadByUserDistribution {
	return &p
}

func CastDatastoreNamespaceUploadByUserDistributions(data []interface{}) []DatastoreNamespaceUploadByUserDistribution {
	v := make([]DatastoreNamespaceUploadByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceUploadByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceUploadByUserDistributionsFromDict(data []DatastoreNamespaceUploadByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDataSizeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *DatastoreNamespaceDataSizeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDataSizeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDataSizeDistributionStatistics{}
	} else {
		*p = DatastoreNamespaceDataSizeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewDatastoreNamespaceDataSizeDistributionStatisticsFromJson(data string) DatastoreNamespaceDataSizeDistributionStatistics {
	req := DatastoreNamespaceDataSizeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDataSizeDistributionStatisticsFromDict(data map[string]interface{}) DatastoreNamespaceDataSizeDistributionStatistics {
	return DatastoreNamespaceDataSizeDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p DatastoreNamespaceDataSizeDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p DatastoreNamespaceDataSizeDistributionStatistics) Pointer() *DatastoreNamespaceDataSizeDistributionStatistics {
	return &p
}

func CastDatastoreNamespaceDataSizeDistributionStatisticses(data []interface{}) []DatastoreNamespaceDataSizeDistributionStatistics {
	v := make([]DatastoreNamespaceDataSizeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDataSizeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDataSizeDistributionStatisticsesFromDict(data []DatastoreNamespaceDataSizeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDataSizeDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *DatastoreNamespaceDataSizeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDataSizeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDataSizeDistributionSegment{}
	} else {
		*p = DatastoreNamespaceDataSizeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewDatastoreNamespaceDataSizeDistributionSegmentFromJson(data string) DatastoreNamespaceDataSizeDistributionSegment {
	req := DatastoreNamespaceDataSizeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDataSizeDistributionSegmentFromDict(data map[string]interface{}) DatastoreNamespaceDataSizeDistributionSegment {
	return DatastoreNamespaceDataSizeDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p DatastoreNamespaceDataSizeDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p DatastoreNamespaceDataSizeDistributionSegment) Pointer() *DatastoreNamespaceDataSizeDistributionSegment {
	return &p
}

func CastDatastoreNamespaceDataSizeDistributionSegments(data []interface{}) []DatastoreNamespaceDataSizeDistributionSegment {
	v := make([]DatastoreNamespaceDataSizeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDataSizeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDataSizeDistributionSegmentsFromDict(data []DatastoreNamespaceDataSizeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDataSizeDistribution struct {
	Statistics   *DatastoreNamespaceDataSizeDistributionStatistics `json:"statistics"`
	Distribution []DatastoreNamespaceDataSizeDistributionSegment   `json:"distribution"`
}

func (p *DatastoreNamespaceDataSizeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDataSizeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDataSizeDistribution{}
	} else {
		*p = DatastoreNamespaceDataSizeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewDatastoreNamespaceDataSizeDistributionFromJson(data string) DatastoreNamespaceDataSizeDistribution {
	req := DatastoreNamespaceDataSizeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDataSizeDistributionFromDict(data map[string]interface{}) DatastoreNamespaceDataSizeDistribution {
	return DatastoreNamespaceDataSizeDistribution{
		Statistics:   NewDatastoreNamespaceDataSizeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastDatastoreNamespaceDataSizeDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p DatastoreNamespaceDataSizeDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastDatastoreNamespaceDataSizeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p DatastoreNamespaceDataSizeDistribution) Pointer() *DatastoreNamespaceDataSizeDistribution {
	return &p
}

func CastDatastoreNamespaceDataSizeDistributions(data []interface{}) []DatastoreNamespaceDataSizeDistribution {
	v := make([]DatastoreNamespaceDataSizeDistribution, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDataSizeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDataSizeDistributionsFromDict(data []DatastoreNamespaceDataSizeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDistributions struct {
	DownloadByUser *DatastoreNamespaceDownloadByUserDistribution `json:"downloadByUser"`
	UploadByUser   *DatastoreNamespaceUploadByUserDistribution   `json:"uploadByUser"`
	DataSize       *DatastoreNamespaceDataSizeDistribution       `json:"dataSize"`
}

func (p *DatastoreNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDistributions{}
	} else {
		*p = DatastoreNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["downloadByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DownloadByUser)
		}
		if v, ok := d["uploadByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.UploadByUser)
		}
		if v, ok := d["dataSize"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DataSize)
		}
	}
	return nil
}

func NewDatastoreNamespaceDistributionsFromJson(data string) DatastoreNamespaceDistributions {
	req := DatastoreNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDistributionsFromDict(data map[string]interface{}) DatastoreNamespaceDistributions {
	return DatastoreNamespaceDistributions{
		DownloadByUser: NewDatastoreNamespaceDownloadByUserDistributionFromDict(core.CastMap(data["downloadByUser"])).Pointer(),
		UploadByUser:   NewDatastoreNamespaceUploadByUserDistributionFromDict(core.CastMap(data["uploadByUser"])).Pointer(),
		DataSize:       NewDatastoreNamespaceDataSizeDistributionFromDict(core.CastMap(data["dataSize"])).Pointer(),
	}
}

func (p DatastoreNamespaceDistributions) ToDict() map[string]interface{} {

	var downloadByUser map[string]interface{}
	if p.DownloadByUser != nil {
		downloadByUser = p.DownloadByUser.ToDict()
	}
	var uploadByUser map[string]interface{}
	if p.UploadByUser != nil {
		uploadByUser = p.UploadByUser.ToDict()
	}
	var dataSize map[string]interface{}
	if p.DataSize != nil {
		dataSize = p.DataSize.ToDict()
	}
	return map[string]interface{}{
		"downloadByUser": downloadByUser,
		"uploadByUser":   uploadByUser,
		"dataSize":       dataSize,
	}
}

func (p DatastoreNamespaceDistributions) Pointer() *DatastoreNamespaceDistributions {
	return &p
}

func CastDatastoreNamespaceDistributionses(data []interface{}) []DatastoreNamespaceDistributions {
	v := make([]DatastoreNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDistributionsesFromDict(data []DatastoreNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespace struct {
	NamespaceId   *string                          `json:"namespaceId"`
	Year          *int32                           `json:"year"`
	Month         *int32                           `json:"month"`
	Day           *int32                           `json:"day"`
	NamespaceName *string                          `json:"namespaceName"`
	Statistics    *DatastoreNamespaceStatistics    `json:"statistics"`
	Distributions *DatastoreNamespaceDistributions `json:"distributions"`
}

func (p *DatastoreNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespace{}
	} else {
		*p = DatastoreNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewDatastoreNamespaceFromJson(data string) DatastoreNamespace {
	req := DatastoreNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceFromDict(data map[string]interface{}) DatastoreNamespace {
	return DatastoreNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewDatastoreNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewDatastoreNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p DatastoreNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p DatastoreNamespace) Pointer() *DatastoreNamespace {
	return &p
}

func CastDatastoreNamespaces(data []interface{}) []DatastoreNamespace {
	v := make([]DatastoreNamespace, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespacesFromDict(data []DatastoreNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceStatistics struct {
	Register *int64 `json:"register"`
}

func (p *DictionaryNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceStatistics{}
	} else {
		*p = DictionaryNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["register"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Register)
		}
	}
	return nil
}

func NewDictionaryNamespaceStatisticsFromJson(data string) DictionaryNamespaceStatistics {
	req := DictionaryNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceStatisticsFromDict(data map[string]interface{}) DictionaryNamespaceStatistics {
	return DictionaryNamespaceStatistics{
		Register: core.CastInt64(data["register"]),
	}
}

func (p DictionaryNamespaceStatistics) ToDict() map[string]interface{} {

	var register *int64
	if p.Register != nil {
		register = p.Register
	}
	return map[string]interface{}{
		"register": register,
	}
}

func (p DictionaryNamespaceStatistics) Pointer() *DictionaryNamespaceStatistics {
	return &p
}

func CastDictionaryNamespaceStatisticses(data []interface{}) []DictionaryNamespaceStatistics {
	v := make([]DictionaryNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceStatisticsesFromDict(data []DictionaryNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByNameDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *DictionaryNamespaceEntryByNameDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByNameDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByNameDistributionStatistics{}
	} else {
		*p = DictionaryNamespaceEntryByNameDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByNameDistributionStatisticsFromJson(data string) DictionaryNamespaceEntryByNameDistributionStatistics {
	req := DictionaryNamespaceEntryByNameDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByNameDistributionStatisticsFromDict(data map[string]interface{}) DictionaryNamespaceEntryByNameDistributionStatistics {
	return DictionaryNamespaceEntryByNameDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p DictionaryNamespaceEntryByNameDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p DictionaryNamespaceEntryByNameDistributionStatistics) Pointer() *DictionaryNamespaceEntryByNameDistributionStatistics {
	return &p
}

func CastDictionaryNamespaceEntryByNameDistributionStatisticses(data []interface{}) []DictionaryNamespaceEntryByNameDistributionStatistics {
	v := make([]DictionaryNamespaceEntryByNameDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByNameDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByNameDistributionStatisticsesFromDict(data []DictionaryNamespaceEntryByNameDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByNameDistributionSegment struct {
	EntryModelName *string `json:"entryModelName"`
	Count          *int64  `json:"count"`
}

func (p *DictionaryNamespaceEntryByNameDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByNameDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByNameDistributionSegment{}
	} else {
		*p = DictionaryNamespaceEntryByNameDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["entryModelName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.EntryModelName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.EntryModelName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.EntryModelName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.EntryModelName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.EntryModelName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.EntryModelName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByNameDistributionSegmentFromJson(data string) DictionaryNamespaceEntryByNameDistributionSegment {
	req := DictionaryNamespaceEntryByNameDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByNameDistributionSegmentFromDict(data map[string]interface{}) DictionaryNamespaceEntryByNameDistributionSegment {
	return DictionaryNamespaceEntryByNameDistributionSegment{
		EntryModelName: core.CastString(data["entryModelName"]),
		Count:          core.CastInt64(data["count"]),
	}
}

func (p DictionaryNamespaceEntryByNameDistributionSegment) ToDict() map[string]interface{} {

	var entryModelName *string
	if p.EntryModelName != nil {
		entryModelName = p.EntryModelName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"entryModelName": entryModelName,
		"count":          count,
	}
}

func (p DictionaryNamespaceEntryByNameDistributionSegment) Pointer() *DictionaryNamespaceEntryByNameDistributionSegment {
	return &p
}

func CastDictionaryNamespaceEntryByNameDistributionSegments(data []interface{}) []DictionaryNamespaceEntryByNameDistributionSegment {
	v := make([]DictionaryNamespaceEntryByNameDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByNameDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByNameDistributionSegmentsFromDict(data []DictionaryNamespaceEntryByNameDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByNameDistribution struct {
	Statistics   *DictionaryNamespaceEntryByNameDistributionStatistics `json:"statistics"`
	Distribution []DictionaryNamespaceEntryByNameDistributionSegment   `json:"distribution"`
}

func (p *DictionaryNamespaceEntryByNameDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByNameDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByNameDistribution{}
	} else {
		*p = DictionaryNamespaceEntryByNameDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByNameDistributionFromJson(data string) DictionaryNamespaceEntryByNameDistribution {
	req := DictionaryNamespaceEntryByNameDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByNameDistributionFromDict(data map[string]interface{}) DictionaryNamespaceEntryByNameDistribution {
	return DictionaryNamespaceEntryByNameDistribution{
		Statistics:   NewDictionaryNamespaceEntryByNameDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastDictionaryNamespaceEntryByNameDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p DictionaryNamespaceEntryByNameDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastDictionaryNamespaceEntryByNameDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p DictionaryNamespaceEntryByNameDistribution) Pointer() *DictionaryNamespaceEntryByNameDistribution {
	return &p
}

func CastDictionaryNamespaceEntryByNameDistributions(data []interface{}) []DictionaryNamespaceEntryByNameDistribution {
	v := make([]DictionaryNamespaceEntryByNameDistribution, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByNameDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByNameDistributionsFromDict(data []DictionaryNamespaceEntryByNameDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *DictionaryNamespaceEntryByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByUserDistributionStatistics{}
	} else {
		*p = DictionaryNamespaceEntryByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByUserDistributionStatisticsFromJson(data string) DictionaryNamespaceEntryByUserDistributionStatistics {
	req := DictionaryNamespaceEntryByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByUserDistributionStatisticsFromDict(data map[string]interface{}) DictionaryNamespaceEntryByUserDistributionStatistics {
	return DictionaryNamespaceEntryByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p DictionaryNamespaceEntryByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p DictionaryNamespaceEntryByUserDistributionStatistics) Pointer() *DictionaryNamespaceEntryByUserDistributionStatistics {
	return &p
}

func CastDictionaryNamespaceEntryByUserDistributionStatisticses(data []interface{}) []DictionaryNamespaceEntryByUserDistributionStatistics {
	v := make([]DictionaryNamespaceEntryByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByUserDistributionStatisticsesFromDict(data []DictionaryNamespaceEntryByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *DictionaryNamespaceEntryByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByUserDistributionSegment{}
	} else {
		*p = DictionaryNamespaceEntryByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByUserDistributionSegmentFromJson(data string) DictionaryNamespaceEntryByUserDistributionSegment {
	req := DictionaryNamespaceEntryByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByUserDistributionSegmentFromDict(data map[string]interface{}) DictionaryNamespaceEntryByUserDistributionSegment {
	return DictionaryNamespaceEntryByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p DictionaryNamespaceEntryByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p DictionaryNamespaceEntryByUserDistributionSegment) Pointer() *DictionaryNamespaceEntryByUserDistributionSegment {
	return &p
}

func CastDictionaryNamespaceEntryByUserDistributionSegments(data []interface{}) []DictionaryNamespaceEntryByUserDistributionSegment {
	v := make([]DictionaryNamespaceEntryByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByUserDistributionSegmentsFromDict(data []DictionaryNamespaceEntryByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByUserDistribution struct {
	Statistics   *DictionaryNamespaceEntryByUserDistributionStatistics `json:"statistics"`
	Distribution []DictionaryNamespaceEntryByUserDistributionSegment   `json:"distribution"`
}

func (p *DictionaryNamespaceEntryByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByUserDistribution{}
	} else {
		*p = DictionaryNamespaceEntryByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByUserDistributionFromJson(data string) DictionaryNamespaceEntryByUserDistribution {
	req := DictionaryNamespaceEntryByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByUserDistributionFromDict(data map[string]interface{}) DictionaryNamespaceEntryByUserDistribution {
	return DictionaryNamespaceEntryByUserDistribution{
		Statistics:   NewDictionaryNamespaceEntryByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastDictionaryNamespaceEntryByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p DictionaryNamespaceEntryByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastDictionaryNamespaceEntryByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p DictionaryNamespaceEntryByUserDistribution) Pointer() *DictionaryNamespaceEntryByUserDistribution {
	return &p
}

func CastDictionaryNamespaceEntryByUserDistributions(data []interface{}) []DictionaryNamespaceEntryByUserDistribution {
	v := make([]DictionaryNamespaceEntryByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByUserDistributionsFromDict(data []DictionaryNamespaceEntryByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceDistributions struct {
	EntryByName *DictionaryNamespaceEntryByNameDistribution `json:"entryByName"`
	EntryByUser *DictionaryNamespaceEntryByUserDistribution `json:"entryByUser"`
}

func (p *DictionaryNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceDistributions{}
	} else {
		*p = DictionaryNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["entryByName"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EntryByName)
		}
		if v, ok := d["entryByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EntryByUser)
		}
	}
	return nil
}

func NewDictionaryNamespaceDistributionsFromJson(data string) DictionaryNamespaceDistributions {
	req := DictionaryNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceDistributionsFromDict(data map[string]interface{}) DictionaryNamespaceDistributions {
	return DictionaryNamespaceDistributions{
		EntryByName: NewDictionaryNamespaceEntryByNameDistributionFromDict(core.CastMap(data["entryByName"])).Pointer(),
		EntryByUser: NewDictionaryNamespaceEntryByUserDistributionFromDict(core.CastMap(data["entryByUser"])).Pointer(),
	}
}

func (p DictionaryNamespaceDistributions) ToDict() map[string]interface{} {

	var entryByName map[string]interface{}
	if p.EntryByName != nil {
		entryByName = p.EntryByName.ToDict()
	}
	var entryByUser map[string]interface{}
	if p.EntryByUser != nil {
		entryByUser = p.EntryByUser.ToDict()
	}
	return map[string]interface{}{
		"entryByName": entryByName,
		"entryByUser": entryByUser,
	}
}

func (p DictionaryNamespaceDistributions) Pointer() *DictionaryNamespaceDistributions {
	return &p
}

func CastDictionaryNamespaceDistributionses(data []interface{}) []DictionaryNamespaceDistributions {
	v := make([]DictionaryNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceDistributionsesFromDict(data []DictionaryNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespace struct {
	NamespaceId   *string                           `json:"namespaceId"`
	Year          *int32                            `json:"year"`
	Month         *int32                            `json:"month"`
	Day           *int32                            `json:"day"`
	NamespaceName *string                           `json:"namespaceName"`
	Statistics    *DictionaryNamespaceStatistics    `json:"statistics"`
	Distributions *DictionaryNamespaceDistributions `json:"distributions"`
}

func (p *DictionaryNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespace{}
	} else {
		*p = DictionaryNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewDictionaryNamespaceFromJson(data string) DictionaryNamespace {
	req := DictionaryNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceFromDict(data map[string]interface{}) DictionaryNamespace {
	return DictionaryNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewDictionaryNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewDictionaryNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p DictionaryNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p DictionaryNamespace) Pointer() *DictionaryNamespace {
	return &p
}

func CastDictionaryNamespaces(data []interface{}) []DictionaryNamespace {
	v := make([]DictionaryNamespace, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespacesFromDict(data []DictionaryNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryEntryModel struct {
	EntryModelModelId *string `json:"entryModelModelId"`
	EntryName         *string `json:"entryName"`
}

func (p *DictionaryEntryModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryEntryModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryEntryModel{}
	} else {
		*p = DictionaryEntryModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["entryModelModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.EntryModelModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.EntryModelModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.EntryModelModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.EntryModelModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.EntryModelModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.EntryModelModelId)
				}
			}
		}
		if v, ok := d["entryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.EntryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.EntryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.EntryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.EntryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.EntryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.EntryName)
				}
			}
		}
	}
	return nil
}

func NewDictionaryEntryModelFromJson(data string) DictionaryEntryModel {
	req := DictionaryEntryModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryEntryModelFromDict(data map[string]interface{}) DictionaryEntryModel {
	return DictionaryEntryModel{
		EntryModelModelId: core.CastString(data["entryModelModelId"]),
		EntryName:         core.CastString(data["entryName"]),
	}
}

func (p DictionaryEntryModel) ToDict() map[string]interface{} {

	var entryModelModelId *string
	if p.EntryModelModelId != nil {
		entryModelModelId = p.EntryModelModelId
	}
	var entryName *string
	if p.EntryName != nil {
		entryName = p.EntryName
	}
	return map[string]interface{}{
		"entryModelModelId": entryModelModelId,
		"entryName":         entryName,
	}
}

func (p DictionaryEntryModel) Pointer() *DictionaryEntryModel {
	return &p
}

func CastDictionaryEntryModels(data []interface{}) []DictionaryEntryModel {
	v := make([]DictionaryEntryModel, 0)
	for _, d := range data {
		v = append(v, NewDictionaryEntryModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryEntryModelsFromDict(data []DictionaryEntryModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModelStatistics struct {
	Exchange *int64 `json:"exchange"`
	Amount   *int64 `json:"amount"`
}

func (p *ExchangeRateModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModelStatistics{}
	} else {
		*p = ExchangeRateModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["exchange"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Exchange)
		}
		if v, ok := d["amount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Amount)
		}
	}
	return nil
}

func NewExchangeRateModelStatisticsFromJson(data string) ExchangeRateModelStatistics {
	req := ExchangeRateModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelStatisticsFromDict(data map[string]interface{}) ExchangeRateModelStatistics {
	return ExchangeRateModelStatistics{
		Exchange: core.CastInt64(data["exchange"]),
		Amount:   core.CastInt64(data["amount"]),
	}
}

func (p ExchangeRateModelStatistics) ToDict() map[string]interface{} {

	var exchange *int64
	if p.Exchange != nil {
		exchange = p.Exchange
	}
	var amount *int64
	if p.Amount != nil {
		amount = p.Amount
	}
	return map[string]interface{}{
		"exchange": exchange,
		"amount":   amount,
	}
}

func (p ExchangeRateModelStatistics) Pointer() *ExchangeRateModelStatistics {
	return &p
}

func CastExchangeRateModelStatisticses(data []interface{}) []ExchangeRateModelStatistics {
	v := make([]ExchangeRateModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelStatisticsesFromDict(data []ExchangeRateModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModelAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExchangeRateModelAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModelAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModelAmountDistributionStatistics{}
	} else {
		*p = ExchangeRateModelAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExchangeRateModelAmountDistributionStatisticsFromJson(data string) ExchangeRateModelAmountDistributionStatistics {
	req := ExchangeRateModelAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelAmountDistributionStatisticsFromDict(data map[string]interface{}) ExchangeRateModelAmountDistributionStatistics {
	return ExchangeRateModelAmountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExchangeRateModelAmountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExchangeRateModelAmountDistributionStatistics) Pointer() *ExchangeRateModelAmountDistributionStatistics {
	return &p
}

func CastExchangeRateModelAmountDistributionStatisticses(data []interface{}) []ExchangeRateModelAmountDistributionStatistics {
	v := make([]ExchangeRateModelAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelAmountDistributionStatisticsesFromDict(data []ExchangeRateModelAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModelAmountDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExchangeRateModelAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModelAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModelAmountDistributionSegment{}
	} else {
		*p = ExchangeRateModelAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExchangeRateModelAmountDistributionSegmentFromJson(data string) ExchangeRateModelAmountDistributionSegment {
	req := ExchangeRateModelAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelAmountDistributionSegmentFromDict(data map[string]interface{}) ExchangeRateModelAmountDistributionSegment {
	return ExchangeRateModelAmountDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ExchangeRateModelAmountDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ExchangeRateModelAmountDistributionSegment) Pointer() *ExchangeRateModelAmountDistributionSegment {
	return &p
}

func CastExchangeRateModelAmountDistributionSegments(data []interface{}) []ExchangeRateModelAmountDistributionSegment {
	v := make([]ExchangeRateModelAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelAmountDistributionSegmentsFromDict(data []ExchangeRateModelAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModelAmountDistribution struct {
	Statistics   *ExchangeRateModelAmountDistributionStatistics `json:"statistics"`
	Distribution []ExchangeRateModelAmountDistributionSegment   `json:"distribution"`
}

func (p *ExchangeRateModelAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModelAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModelAmountDistribution{}
	} else {
		*p = ExchangeRateModelAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExchangeRateModelAmountDistributionFromJson(data string) ExchangeRateModelAmountDistribution {
	req := ExchangeRateModelAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelAmountDistributionFromDict(data map[string]interface{}) ExchangeRateModelAmountDistribution {
	return ExchangeRateModelAmountDistribution{
		Statistics:   NewExchangeRateModelAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExchangeRateModelAmountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExchangeRateModelAmountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExchangeRateModelAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExchangeRateModelAmountDistribution) Pointer() *ExchangeRateModelAmountDistribution {
	return &p
}

func CastExchangeRateModelAmountDistributions(data []interface{}) []ExchangeRateModelAmountDistribution {
	v := make([]ExchangeRateModelAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelAmountDistributionsFromDict(data []ExchangeRateModelAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModelDistributions struct {
	Amount *ExchangeRateModelAmountDistribution `json:"amount"`
}

func (p *ExchangeRateModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModelDistributions{}
	} else {
		*p = ExchangeRateModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["amount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Amount)
		}
	}
	return nil
}

func NewExchangeRateModelDistributionsFromJson(data string) ExchangeRateModelDistributions {
	req := ExchangeRateModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelDistributionsFromDict(data map[string]interface{}) ExchangeRateModelDistributions {
	return ExchangeRateModelDistributions{
		Amount: NewExchangeRateModelAmountDistributionFromDict(core.CastMap(data["amount"])).Pointer(),
	}
}

func (p ExchangeRateModelDistributions) ToDict() map[string]interface{} {

	var amount map[string]interface{}
	if p.Amount != nil {
		amount = p.Amount.ToDict()
	}
	return map[string]interface{}{
		"amount": amount,
	}
}

func (p ExchangeRateModelDistributions) Pointer() *ExchangeRateModelDistributions {
	return &p
}

func CastExchangeRateModelDistributionses(data []interface{}) []ExchangeRateModelDistributions {
	v := make([]ExchangeRateModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelDistributionsesFromDict(data []ExchangeRateModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModel struct {
	RateModelId   *string                         `json:"rateModelId"`
	RateName      *string                         `json:"rateName"`
	Statistics    *ExchangeRateModelStatistics    `json:"statistics"`
	Distributions *ExchangeRateModelDistributions `json:"distributions"`
}

func (p *ExchangeRateModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModel{}
	} else {
		*p = ExchangeRateModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["rateModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.RateModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.RateModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.RateModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.RateModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.RateModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.RateModelId)
				}
			}
		}
		if v, ok := d["rateName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.RateName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.RateName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.RateName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.RateName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewExchangeRateModelFromJson(data string) ExchangeRateModel {
	req := ExchangeRateModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelFromDict(data map[string]interface{}) ExchangeRateModel {
	return ExchangeRateModel{
		RateModelId:   core.CastString(data["rateModelId"]),
		RateName:      core.CastString(data["rateName"]),
		Statistics:    NewExchangeRateModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewExchangeRateModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p ExchangeRateModel) ToDict() map[string]interface{} {

	var rateModelId *string
	if p.RateModelId != nil {
		rateModelId = p.RateModelId
	}
	var rateName *string
	if p.RateName != nil {
		rateName = p.RateName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"rateModelId":   rateModelId,
		"rateName":      rateName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p ExchangeRateModel) Pointer() *ExchangeRateModel {
	return &p
}

func CastExchangeRateModels(data []interface{}) []ExchangeRateModel {
	v := make([]ExchangeRateModel, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelsFromDict(data []ExchangeRateModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceStatistics struct {
	Exchange *int64 `json:"exchange"`
	Amount   *int64 `json:"amount"`
}

func (p *ExchangeNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceStatistics{}
	} else {
		*p = ExchangeNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["exchange"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Exchange)
		}
		if v, ok := d["amount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Amount)
		}
	}
	return nil
}

func NewExchangeNamespaceStatisticsFromJson(data string) ExchangeNamespaceStatistics {
	req := ExchangeNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceStatisticsFromDict(data map[string]interface{}) ExchangeNamespaceStatistics {
	return ExchangeNamespaceStatistics{
		Exchange: core.CastInt64(data["exchange"]),
		Amount:   core.CastInt64(data["amount"]),
	}
}

func (p ExchangeNamespaceStatistics) ToDict() map[string]interface{} {

	var exchange *int64
	if p.Exchange != nil {
		exchange = p.Exchange
	}
	var amount *int64
	if p.Amount != nil {
		amount = p.Amount
	}
	return map[string]interface{}{
		"exchange": exchange,
		"amount":   amount,
	}
}

func (p ExchangeNamespaceStatistics) Pointer() *ExchangeNamespaceStatistics {
	return &p
}

func CastExchangeNamespaceStatisticses(data []interface{}) []ExchangeNamespaceStatistics {
	v := make([]ExchangeNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceStatisticsesFromDict(data []ExchangeNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExchangeNamespaceExchangeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeDistributionStatistics{}
	} else {
		*p = ExchangeNamespaceExchangeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeDistributionStatisticsFromJson(data string) ExchangeNamespaceExchangeDistributionStatistics {
	req := ExchangeNamespaceExchangeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeDistributionStatisticsFromDict(data map[string]interface{}) ExchangeNamespaceExchangeDistributionStatistics {
	return ExchangeNamespaceExchangeDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExchangeNamespaceExchangeDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExchangeNamespaceExchangeDistributionStatistics) Pointer() *ExchangeNamespaceExchangeDistributionStatistics {
	return &p
}

func CastExchangeNamespaceExchangeDistributionStatisticses(data []interface{}) []ExchangeNamespaceExchangeDistributionStatistics {
	v := make([]ExchangeNamespaceExchangeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeDistributionStatisticsesFromDict(data []ExchangeNamespaceExchangeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeDistributionSegment struct {
	RateName *string `json:"rateName"`
	Count    *int64  `json:"count"`
}

func (p *ExchangeNamespaceExchangeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeDistributionSegment{}
	} else {
		*p = ExchangeNamespaceExchangeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["rateName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.RateName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.RateName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.RateName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.RateName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeDistributionSegmentFromJson(data string) ExchangeNamespaceExchangeDistributionSegment {
	req := ExchangeNamespaceExchangeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeDistributionSegmentFromDict(data map[string]interface{}) ExchangeNamespaceExchangeDistributionSegment {
	return ExchangeNamespaceExchangeDistributionSegment{
		RateName: core.CastString(data["rateName"]),
		Count:    core.CastInt64(data["count"]),
	}
}

func (p ExchangeNamespaceExchangeDistributionSegment) ToDict() map[string]interface{} {

	var rateName *string
	if p.RateName != nil {
		rateName = p.RateName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"rateName": rateName,
		"count":    count,
	}
}

func (p ExchangeNamespaceExchangeDistributionSegment) Pointer() *ExchangeNamespaceExchangeDistributionSegment {
	return &p
}

func CastExchangeNamespaceExchangeDistributionSegments(data []interface{}) []ExchangeNamespaceExchangeDistributionSegment {
	v := make([]ExchangeNamespaceExchangeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeDistributionSegmentsFromDict(data []ExchangeNamespaceExchangeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeDistribution struct {
	Statistics   *ExchangeNamespaceExchangeDistributionStatistics `json:"statistics"`
	Distribution []ExchangeNamespaceExchangeDistributionSegment   `json:"distribution"`
}

func (p *ExchangeNamespaceExchangeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeDistribution{}
	} else {
		*p = ExchangeNamespaceExchangeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeDistributionFromJson(data string) ExchangeNamespaceExchangeDistribution {
	req := ExchangeNamespaceExchangeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeDistributionFromDict(data map[string]interface{}) ExchangeNamespaceExchangeDistribution {
	return ExchangeNamespaceExchangeDistribution{
		Statistics:   NewExchangeNamespaceExchangeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExchangeNamespaceExchangeDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExchangeNamespaceExchangeDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExchangeNamespaceExchangeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExchangeNamespaceExchangeDistribution) Pointer() *ExchangeNamespaceExchangeDistribution {
	return &p
}

func CastExchangeNamespaceExchangeDistributions(data []interface{}) []ExchangeNamespaceExchangeDistribution {
	v := make([]ExchangeNamespaceExchangeDistribution, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeDistributionsFromDict(data []ExchangeNamespaceExchangeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExchangeNamespaceExchangeAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountDistributionStatistics{}
	} else {
		*p = ExchangeNamespaceExchangeAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountDistributionStatisticsFromJson(data string) ExchangeNamespaceExchangeAmountDistributionStatistics {
	req := ExchangeNamespaceExchangeAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountDistributionStatisticsFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountDistributionStatistics {
	return ExchangeNamespaceExchangeAmountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExchangeNamespaceExchangeAmountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExchangeNamespaceExchangeAmountDistributionStatistics) Pointer() *ExchangeNamespaceExchangeAmountDistributionStatistics {
	return &p
}

func CastExchangeNamespaceExchangeAmountDistributionStatisticses(data []interface{}) []ExchangeNamespaceExchangeAmountDistributionStatistics {
	v := make([]ExchangeNamespaceExchangeAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountDistributionStatisticsesFromDict(data []ExchangeNamespaceExchangeAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountDistributionSegment struct {
	RateName *string `json:"rateName"`
	Sum      *int64  `json:"sum"`
}

func (p *ExchangeNamespaceExchangeAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountDistributionSegment{}
	} else {
		*p = ExchangeNamespaceExchangeAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["rateName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.RateName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.RateName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.RateName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.RateName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountDistributionSegmentFromJson(data string) ExchangeNamespaceExchangeAmountDistributionSegment {
	req := ExchangeNamespaceExchangeAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountDistributionSegmentFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountDistributionSegment {
	return ExchangeNamespaceExchangeAmountDistributionSegment{
		RateName: core.CastString(data["rateName"]),
		Sum:      core.CastInt64(data["sum"]),
	}
}

func (p ExchangeNamespaceExchangeAmountDistributionSegment) ToDict() map[string]interface{} {

	var rateName *string
	if p.RateName != nil {
		rateName = p.RateName
	}
	var sum *int64
	if p.Sum != nil {
		sum = p.Sum
	}
	return map[string]interface{}{
		"rateName": rateName,
		"sum":      sum,
	}
}

func (p ExchangeNamespaceExchangeAmountDistributionSegment) Pointer() *ExchangeNamespaceExchangeAmountDistributionSegment {
	return &p
}

func CastExchangeNamespaceExchangeAmountDistributionSegments(data []interface{}) []ExchangeNamespaceExchangeAmountDistributionSegment {
	v := make([]ExchangeNamespaceExchangeAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountDistributionSegmentsFromDict(data []ExchangeNamespaceExchangeAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountDistribution struct {
	Statistics   *ExchangeNamespaceExchangeAmountDistributionStatistics `json:"statistics"`
	Distribution []ExchangeNamespaceExchangeAmountDistributionSegment   `json:"distribution"`
}

func (p *ExchangeNamespaceExchangeAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountDistribution{}
	} else {
		*p = ExchangeNamespaceExchangeAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountDistributionFromJson(data string) ExchangeNamespaceExchangeAmountDistribution {
	req := ExchangeNamespaceExchangeAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountDistributionFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountDistribution {
	return ExchangeNamespaceExchangeAmountDistribution{
		Statistics:   NewExchangeNamespaceExchangeAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExchangeNamespaceExchangeAmountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExchangeNamespaceExchangeAmountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExchangeNamespaceExchangeAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExchangeNamespaceExchangeAmountDistribution) Pointer() *ExchangeNamespaceExchangeAmountDistribution {
	return &p
}

func CastExchangeNamespaceExchangeAmountDistributions(data []interface{}) []ExchangeNamespaceExchangeAmountDistribution {
	v := make([]ExchangeNamespaceExchangeAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountDistributionsFromDict(data []ExchangeNamespaceExchangeAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExchangeNamespaceExchangeByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeByUserDistributionStatistics{}
	} else {
		*p = ExchangeNamespaceExchangeByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeByUserDistributionStatisticsFromJson(data string) ExchangeNamespaceExchangeByUserDistributionStatistics {
	req := ExchangeNamespaceExchangeByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeByUserDistributionStatisticsFromDict(data map[string]interface{}) ExchangeNamespaceExchangeByUserDistributionStatistics {
	return ExchangeNamespaceExchangeByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExchangeNamespaceExchangeByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExchangeNamespaceExchangeByUserDistributionStatistics) Pointer() *ExchangeNamespaceExchangeByUserDistributionStatistics {
	return &p
}

func CastExchangeNamespaceExchangeByUserDistributionStatisticses(data []interface{}) []ExchangeNamespaceExchangeByUserDistributionStatistics {
	v := make([]ExchangeNamespaceExchangeByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeByUserDistributionStatisticsesFromDict(data []ExchangeNamespaceExchangeByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExchangeNamespaceExchangeByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeByUserDistributionSegment{}
	} else {
		*p = ExchangeNamespaceExchangeByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeByUserDistributionSegmentFromJson(data string) ExchangeNamespaceExchangeByUserDistributionSegment {
	req := ExchangeNamespaceExchangeByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeByUserDistributionSegmentFromDict(data map[string]interface{}) ExchangeNamespaceExchangeByUserDistributionSegment {
	return ExchangeNamespaceExchangeByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ExchangeNamespaceExchangeByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ExchangeNamespaceExchangeByUserDistributionSegment) Pointer() *ExchangeNamespaceExchangeByUserDistributionSegment {
	return &p
}

func CastExchangeNamespaceExchangeByUserDistributionSegments(data []interface{}) []ExchangeNamespaceExchangeByUserDistributionSegment {
	v := make([]ExchangeNamespaceExchangeByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeByUserDistributionSegmentsFromDict(data []ExchangeNamespaceExchangeByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeByUserDistribution struct {
	Statistics   *ExchangeNamespaceExchangeByUserDistributionStatistics `json:"statistics"`
	Distribution []ExchangeNamespaceExchangeByUserDistributionSegment   `json:"distribution"`
}

func (p *ExchangeNamespaceExchangeByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeByUserDistribution{}
	} else {
		*p = ExchangeNamespaceExchangeByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeByUserDistributionFromJson(data string) ExchangeNamespaceExchangeByUserDistribution {
	req := ExchangeNamespaceExchangeByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeByUserDistributionFromDict(data map[string]interface{}) ExchangeNamespaceExchangeByUserDistribution {
	return ExchangeNamespaceExchangeByUserDistribution{
		Statistics:   NewExchangeNamespaceExchangeByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExchangeNamespaceExchangeByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExchangeNamespaceExchangeByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExchangeNamespaceExchangeByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExchangeNamespaceExchangeByUserDistribution) Pointer() *ExchangeNamespaceExchangeByUserDistribution {
	return &p
}

func CastExchangeNamespaceExchangeByUserDistributions(data []interface{}) []ExchangeNamespaceExchangeByUserDistribution {
	v := make([]ExchangeNamespaceExchangeByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeByUserDistributionsFromDict(data []ExchangeNamespaceExchangeByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExchangeNamespaceExchangeAmountByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionStatistics{}
	} else {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountByUserDistributionStatisticsFromJson(data string) ExchangeNamespaceExchangeAmountByUserDistributionStatistics {
	req := ExchangeNamespaceExchangeAmountByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountByUserDistributionStatisticsFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountByUserDistributionStatistics {
	return ExchangeNamespaceExchangeAmountByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExchangeNamespaceExchangeAmountByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExchangeNamespaceExchangeAmountByUserDistributionStatistics) Pointer() *ExchangeNamespaceExchangeAmountByUserDistributionStatistics {
	return &p
}

func CastExchangeNamespaceExchangeAmountByUserDistributionStatisticses(data []interface{}) []ExchangeNamespaceExchangeAmountByUserDistributionStatistics {
	v := make([]ExchangeNamespaceExchangeAmountByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountByUserDistributionStatisticsesFromDict(data []ExchangeNamespaceExchangeAmountByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExchangeNamespaceExchangeAmountByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionSegment{}
	} else {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountByUserDistributionSegmentFromJson(data string) ExchangeNamespaceExchangeAmountByUserDistributionSegment {
	req := ExchangeNamespaceExchangeAmountByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountByUserDistributionSegmentFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountByUserDistributionSegment {
	return ExchangeNamespaceExchangeAmountByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ExchangeNamespaceExchangeAmountByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ExchangeNamespaceExchangeAmountByUserDistributionSegment) Pointer() *ExchangeNamespaceExchangeAmountByUserDistributionSegment {
	return &p
}

func CastExchangeNamespaceExchangeAmountByUserDistributionSegments(data []interface{}) []ExchangeNamespaceExchangeAmountByUserDistributionSegment {
	v := make([]ExchangeNamespaceExchangeAmountByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountByUserDistributionSegmentsFromDict(data []ExchangeNamespaceExchangeAmountByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountByUserDistribution struct {
	Statistics   *ExchangeNamespaceExchangeAmountByUserDistributionStatistics `json:"statistics"`
	Distribution []ExchangeNamespaceExchangeAmountByUserDistributionSegment   `json:"distribution"`
}

func (p *ExchangeNamespaceExchangeAmountByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountByUserDistribution{}
	} else {
		*p = ExchangeNamespaceExchangeAmountByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountByUserDistributionFromJson(data string) ExchangeNamespaceExchangeAmountByUserDistribution {
	req := ExchangeNamespaceExchangeAmountByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountByUserDistributionFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountByUserDistribution {
	return ExchangeNamespaceExchangeAmountByUserDistribution{
		Statistics:   NewExchangeNamespaceExchangeAmountByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExchangeNamespaceExchangeAmountByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExchangeNamespaceExchangeAmountByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExchangeNamespaceExchangeAmountByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExchangeNamespaceExchangeAmountByUserDistribution) Pointer() *ExchangeNamespaceExchangeAmountByUserDistribution {
	return &p
}

func CastExchangeNamespaceExchangeAmountByUserDistributions(data []interface{}) []ExchangeNamespaceExchangeAmountByUserDistribution {
	v := make([]ExchangeNamespaceExchangeAmountByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountByUserDistributionsFromDict(data []ExchangeNamespaceExchangeAmountByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceDistributions struct {
	Exchange             *ExchangeNamespaceExchangeDistribution             `json:"exchange"`
	ExchangeAmount       *ExchangeNamespaceExchangeAmountDistribution       `json:"exchangeAmount"`
	ExchangeByUser       *ExchangeNamespaceExchangeByUserDistribution       `json:"exchangeByUser"`
	ExchangeAmountByUser *ExchangeNamespaceExchangeAmountByUserDistribution `json:"exchangeAmountByUser"`
}

func (p *ExchangeNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceDistributions{}
	} else {
		*p = ExchangeNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["exchange"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Exchange)
		}
		if v, ok := d["exchangeAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExchangeAmount)
		}
		if v, ok := d["exchangeByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExchangeByUser)
		}
		if v, ok := d["exchangeAmountByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExchangeAmountByUser)
		}
	}
	return nil
}

func NewExchangeNamespaceDistributionsFromJson(data string) ExchangeNamespaceDistributions {
	req := ExchangeNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceDistributionsFromDict(data map[string]interface{}) ExchangeNamespaceDistributions {
	return ExchangeNamespaceDistributions{
		Exchange:             NewExchangeNamespaceExchangeDistributionFromDict(core.CastMap(data["exchange"])).Pointer(),
		ExchangeAmount:       NewExchangeNamespaceExchangeAmountDistributionFromDict(core.CastMap(data["exchangeAmount"])).Pointer(),
		ExchangeByUser:       NewExchangeNamespaceExchangeByUserDistributionFromDict(core.CastMap(data["exchangeByUser"])).Pointer(),
		ExchangeAmountByUser: NewExchangeNamespaceExchangeAmountByUserDistributionFromDict(core.CastMap(data["exchangeAmountByUser"])).Pointer(),
	}
}

func (p ExchangeNamespaceDistributions) ToDict() map[string]interface{} {

	var exchange map[string]interface{}
	if p.Exchange != nil {
		exchange = p.Exchange.ToDict()
	}
	var exchangeAmount map[string]interface{}
	if p.ExchangeAmount != nil {
		exchangeAmount = p.ExchangeAmount.ToDict()
	}
	var exchangeByUser map[string]interface{}
	if p.ExchangeByUser != nil {
		exchangeByUser = p.ExchangeByUser.ToDict()
	}
	var exchangeAmountByUser map[string]interface{}
	if p.ExchangeAmountByUser != nil {
		exchangeAmountByUser = p.ExchangeAmountByUser.ToDict()
	}
	return map[string]interface{}{
		"exchange":             exchange,
		"exchangeAmount":       exchangeAmount,
		"exchangeByUser":       exchangeByUser,
		"exchangeAmountByUser": exchangeAmountByUser,
	}
}

func (p ExchangeNamespaceDistributions) Pointer() *ExchangeNamespaceDistributions {
	return &p
}

func CastExchangeNamespaceDistributionses(data []interface{}) []ExchangeNamespaceDistributions {
	v := make([]ExchangeNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceDistributionsesFromDict(data []ExchangeNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespace struct {
	NamespaceId   *string                         `json:"namespaceId"`
	Year          *int32                          `json:"year"`
	Month         *int32                          `json:"month"`
	Day           *int32                          `json:"day"`
	NamespaceName *string                         `json:"namespaceName"`
	Statistics    *ExchangeNamespaceStatistics    `json:"statistics"`
	Distributions *ExchangeNamespaceDistributions `json:"distributions"`
	RateModels    []ExchangeRateModel             `json:"rateModels"`
}

func (p *ExchangeNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespace{}
	} else {
		*p = ExchangeNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["rateModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RateModels)
		}
	}
	return nil
}

func NewExchangeNamespaceFromJson(data string) ExchangeNamespace {
	req := ExchangeNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceFromDict(data map[string]interface{}) ExchangeNamespace {
	return ExchangeNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewExchangeNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewExchangeNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		RateModels:    CastExchangeRateModels(core.CastArray(data["rateModels"])),
	}
}

func (p ExchangeNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var rateModels []interface{}
	if p.RateModels != nil {
		rateModels = CastExchangeRateModelsFromDict(
			p.RateModels,
		)
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
		"rateModels":    rateModels,
	}
}

func (p ExchangeNamespace) Pointer() *ExchangeNamespace {
	return &p
}

func CastExchangeNamespaces(data []interface{}) []ExchangeNamespace {
	v := make([]ExchangeNamespace, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespacesFromDict(data []ExchangeNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceStatusRankDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankDistributionStatistics{}
	} else {
		*p = ExperienceStatusRankDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceStatusRankDistributionStatisticsFromJson(data string) ExperienceStatusRankDistributionStatistics {
	req := ExperienceStatusRankDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankDistributionStatisticsFromDict(data map[string]interface{}) ExperienceStatusRankDistributionStatistics {
	return ExperienceStatusRankDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExperienceStatusRankDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExperienceStatusRankDistributionStatistics) Pointer() *ExperienceStatusRankDistributionStatistics {
	return &p
}

func CastExperienceStatusRankDistributionStatisticses(data []interface{}) []ExperienceStatusRankDistributionStatistics {
	v := make([]ExperienceStatusRankDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankDistributionStatisticsesFromDict(data []ExperienceStatusRankDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceStatusRankDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankDistributionSegment{}
	} else {
		*p = ExperienceStatusRankDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceStatusRankDistributionSegmentFromJson(data string) ExperienceStatusRankDistributionSegment {
	req := ExperienceStatusRankDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankDistributionSegmentFromDict(data map[string]interface{}) ExperienceStatusRankDistributionSegment {
	return ExperienceStatusRankDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ExperienceStatusRankDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ExperienceStatusRankDistributionSegment) Pointer() *ExperienceStatusRankDistributionSegment {
	return &p
}

func CastExperienceStatusRankDistributionSegments(data []interface{}) []ExperienceStatusRankDistributionSegment {
	v := make([]ExperienceStatusRankDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankDistributionSegmentsFromDict(data []ExperienceStatusRankDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankDistribution struct {
	Statistics   *ExperienceStatusRankDistributionStatistics `json:"statistics"`
	Distribution []ExperienceStatusRankDistributionSegment   `json:"distribution"`
}

func (p *ExperienceStatusRankDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankDistribution{}
	} else {
		*p = ExperienceStatusRankDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceStatusRankDistributionFromJson(data string) ExperienceStatusRankDistribution {
	req := ExperienceStatusRankDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankDistributionFromDict(data map[string]interface{}) ExperienceStatusRankDistribution {
	return ExperienceStatusRankDistribution{
		Statistics:   NewExperienceStatusRankDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExperienceStatusRankDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExperienceStatusRankDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExperienceStatusRankDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExperienceStatusRankDistribution) Pointer() *ExperienceStatusRankDistribution {
	return &p
}

func CastExperienceStatusRankDistributions(data []interface{}) []ExperienceStatusRankDistribution {
	v := make([]ExperienceStatusRankDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankDistributionsFromDict(data []ExperienceStatusRankDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankCapDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceStatusRankCapDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankCapDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankCapDistributionStatistics{}
	} else {
		*p = ExperienceStatusRankCapDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceStatusRankCapDistributionStatisticsFromJson(data string) ExperienceStatusRankCapDistributionStatistics {
	req := ExperienceStatusRankCapDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankCapDistributionStatisticsFromDict(data map[string]interface{}) ExperienceStatusRankCapDistributionStatistics {
	return ExperienceStatusRankCapDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExperienceStatusRankCapDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExperienceStatusRankCapDistributionStatistics) Pointer() *ExperienceStatusRankCapDistributionStatistics {
	return &p
}

func CastExperienceStatusRankCapDistributionStatisticses(data []interface{}) []ExperienceStatusRankCapDistributionStatistics {
	v := make([]ExperienceStatusRankCapDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankCapDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankCapDistributionStatisticsesFromDict(data []ExperienceStatusRankCapDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankCapDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceStatusRankCapDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankCapDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankCapDistributionSegment{}
	} else {
		*p = ExperienceStatusRankCapDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceStatusRankCapDistributionSegmentFromJson(data string) ExperienceStatusRankCapDistributionSegment {
	req := ExperienceStatusRankCapDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankCapDistributionSegmentFromDict(data map[string]interface{}) ExperienceStatusRankCapDistributionSegment {
	return ExperienceStatusRankCapDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ExperienceStatusRankCapDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ExperienceStatusRankCapDistributionSegment) Pointer() *ExperienceStatusRankCapDistributionSegment {
	return &p
}

func CastExperienceStatusRankCapDistributionSegments(data []interface{}) []ExperienceStatusRankCapDistributionSegment {
	v := make([]ExperienceStatusRankCapDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankCapDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankCapDistributionSegmentsFromDict(data []ExperienceStatusRankCapDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankCapDistribution struct {
	Statistics   *ExperienceStatusRankCapDistributionStatistics `json:"statistics"`
	Distribution []ExperienceStatusRankCapDistributionSegment   `json:"distribution"`
}

func (p *ExperienceStatusRankCapDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankCapDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankCapDistribution{}
	} else {
		*p = ExperienceStatusRankCapDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceStatusRankCapDistributionFromJson(data string) ExperienceStatusRankCapDistribution {
	req := ExperienceStatusRankCapDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankCapDistributionFromDict(data map[string]interface{}) ExperienceStatusRankCapDistribution {
	return ExperienceStatusRankCapDistribution{
		Statistics:   NewExperienceStatusRankCapDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExperienceStatusRankCapDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExperienceStatusRankCapDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExperienceStatusRankCapDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExperienceStatusRankCapDistribution) Pointer() *ExperienceStatusRankCapDistribution {
	return &p
}

func CastExperienceStatusRankCapDistributions(data []interface{}) []ExperienceStatusRankCapDistribution {
	v := make([]ExperienceStatusRankCapDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankCapDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankCapDistributionsFromDict(data []ExperienceStatusRankCapDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusDistributions struct {
	Rank    *ExperienceStatusRankDistribution    `json:"rank"`
	RankCap *ExperienceStatusRankCapDistribution `json:"rankCap"`
}

func (p *ExperienceStatusDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusDistributions{}
	} else {
		*p = ExperienceStatusDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["rank"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Rank)
		}
		if v, ok := d["rankCap"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RankCap)
		}
	}
	return nil
}

func NewExperienceStatusDistributionsFromJson(data string) ExperienceStatusDistributions {
	req := ExperienceStatusDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusDistributionsFromDict(data map[string]interface{}) ExperienceStatusDistributions {
	return ExperienceStatusDistributions{
		Rank:    NewExperienceStatusRankDistributionFromDict(core.CastMap(data["rank"])).Pointer(),
		RankCap: NewExperienceStatusRankCapDistributionFromDict(core.CastMap(data["rankCap"])).Pointer(),
	}
}

func (p ExperienceStatusDistributions) ToDict() map[string]interface{} {

	var rank map[string]interface{}
	if p.Rank != nil {
		rank = p.Rank.ToDict()
	}
	var rankCap map[string]interface{}
	if p.RankCap != nil {
		rankCap = p.RankCap.ToDict()
	}
	return map[string]interface{}{
		"rank":    rank,
		"rankCap": rankCap,
	}
}

func (p ExperienceStatusDistributions) Pointer() *ExperienceStatusDistributions {
	return &p
}

func CastExperienceStatusDistributionses(data []interface{}) []ExperienceStatusDistributions {
	v := make([]ExperienceStatusDistributions, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusDistributionsesFromDict(data []ExperienceStatusDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatus struct {
	StatusId       *string                        `json:"statusId"`
	ExperienceName *string                        `json:"experienceName"`
	PropertyId     *string                        `json:"propertyId"`
	Distributions  *ExperienceStatusDistributions `json:"distributions"`
}

func (p *ExperienceStatus) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatus{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatus{}
	} else {
		*p = ExperienceStatus{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statusId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.StatusId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.StatusId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.StatusId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.StatusId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.StatusId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.StatusId)
				}
			}
		}
		if v, ok := d["experienceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ExperienceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ExperienceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ExperienceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ExperienceName)
				}
			}
		}
		if v, ok := d["propertyId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.PropertyId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.PropertyId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.PropertyId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.PropertyId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.PropertyId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.PropertyId)
				}
			}
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewExperienceStatusFromJson(data string) ExperienceStatus {
	req := ExperienceStatus{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusFromDict(data map[string]interface{}) ExperienceStatus {
	return ExperienceStatus{
		StatusId:       core.CastString(data["statusId"]),
		ExperienceName: core.CastString(data["experienceName"]),
		PropertyId:     core.CastString(data["propertyId"]),
		Distributions:  NewExperienceStatusDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p ExperienceStatus) ToDict() map[string]interface{} {

	var statusId *string
	if p.StatusId != nil {
		statusId = p.StatusId
	}
	var experienceName *string
	if p.ExperienceName != nil {
		experienceName = p.ExperienceName
	}
	var propertyId *string
	if p.PropertyId != nil {
		propertyId = p.PropertyId
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"statusId":       statusId,
		"experienceName": experienceName,
		"propertyId":     propertyId,
		"distributions":  distributions,
	}
}

func (p ExperienceStatus) Pointer() *ExperienceStatus {
	return &p
}

func CastExperienceStatuses(data []interface{}) []ExperienceStatus {
	v := make([]ExperienceStatus, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusesFromDict(data []ExperienceStatus) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelStatistics struct {
	Experience       *int64 `json:"experience"`
	ExperienceAmount *int64 `json:"experienceAmount"`
	RankCap          *int64 `json:"rankCap"`
	RankCapAmount    *int64 `json:"rankCapAmount"`
}

func (p *ExperienceExperienceModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelStatistics{}
	} else {
		*p = ExperienceExperienceModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["experience"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Experience)
		}
		if v, ok := d["experienceAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExperienceAmount)
		}
		if v, ok := d["rankCap"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RankCap)
		}
		if v, ok := d["rankCapAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RankCapAmount)
		}
	}
	return nil
}

func NewExperienceExperienceModelStatisticsFromJson(data string) ExperienceExperienceModelStatistics {
	req := ExperienceExperienceModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelStatisticsFromDict(data map[string]interface{}) ExperienceExperienceModelStatistics {
	return ExperienceExperienceModelStatistics{
		Experience:       core.CastInt64(data["experience"]),
		ExperienceAmount: core.CastInt64(data["experienceAmount"]),
		RankCap:          core.CastInt64(data["rankCap"]),
		RankCapAmount:    core.CastInt64(data["rankCapAmount"]),
	}
}

func (p ExperienceExperienceModelStatistics) ToDict() map[string]interface{} {

	var experience *int64
	if p.Experience != nil {
		experience = p.Experience
	}
	var experienceAmount *int64
	if p.ExperienceAmount != nil {
		experienceAmount = p.ExperienceAmount
	}
	var rankCap *int64
	if p.RankCap != nil {
		rankCap = p.RankCap
	}
	var rankCapAmount *int64
	if p.RankCapAmount != nil {
		rankCapAmount = p.RankCapAmount
	}
	return map[string]interface{}{
		"experience":       experience,
		"experienceAmount": experienceAmount,
		"rankCap":          rankCap,
		"rankCapAmount":    rankCapAmount,
	}
}

func (p ExperienceExperienceModelStatistics) Pointer() *ExperienceExperienceModelStatistics {
	return &p
}

func CastExperienceExperienceModelStatisticses(data []interface{}) []ExperienceExperienceModelStatistics {
	v := make([]ExperienceExperienceModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelStatisticsesFromDict(data []ExperienceExperienceModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceExperienceModelAddExperienceByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionStatistics{}
	} else {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceByUserDistributionStatisticsFromJson(data string) ExperienceExperienceModelAddExperienceByUserDistributionStatistics {
	req := ExperienceExperienceModelAddExperienceByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceByUserDistributionStatisticsFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceByUserDistributionStatistics {
	return ExperienceExperienceModelAddExperienceByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExperienceExperienceModelAddExperienceByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExperienceExperienceModelAddExperienceByUserDistributionStatistics) Pointer() *ExperienceExperienceModelAddExperienceByUserDistributionStatistics {
	return &p
}

func CastExperienceExperienceModelAddExperienceByUserDistributionStatisticses(data []interface{}) []ExperienceExperienceModelAddExperienceByUserDistributionStatistics {
	v := make([]ExperienceExperienceModelAddExperienceByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceByUserDistributionStatisticsesFromDict(data []ExperienceExperienceModelAddExperienceByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceExperienceModelAddExperienceByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionSegment{}
	} else {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceByUserDistributionSegmentFromJson(data string) ExperienceExperienceModelAddExperienceByUserDistributionSegment {
	req := ExperienceExperienceModelAddExperienceByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceByUserDistributionSegmentFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceByUserDistributionSegment {
	return ExperienceExperienceModelAddExperienceByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ExperienceExperienceModelAddExperienceByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ExperienceExperienceModelAddExperienceByUserDistributionSegment) Pointer() *ExperienceExperienceModelAddExperienceByUserDistributionSegment {
	return &p
}

func CastExperienceExperienceModelAddExperienceByUserDistributionSegments(data []interface{}) []ExperienceExperienceModelAddExperienceByUserDistributionSegment {
	v := make([]ExperienceExperienceModelAddExperienceByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceByUserDistributionSegmentsFromDict(data []ExperienceExperienceModelAddExperienceByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceByUserDistribution struct {
	Statistics   *ExperienceExperienceModelAddExperienceByUserDistributionStatistics `json:"statistics"`
	Distribution []ExperienceExperienceModelAddExperienceByUserDistributionSegment   `json:"distribution"`
}

func (p *ExperienceExperienceModelAddExperienceByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceByUserDistribution{}
	} else {
		*p = ExperienceExperienceModelAddExperienceByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceByUserDistributionFromJson(data string) ExperienceExperienceModelAddExperienceByUserDistribution {
	req := ExperienceExperienceModelAddExperienceByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceByUserDistributionFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceByUserDistribution {
	return ExperienceExperienceModelAddExperienceByUserDistribution{
		Statistics:   NewExperienceExperienceModelAddExperienceByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExperienceExperienceModelAddExperienceByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExperienceExperienceModelAddExperienceByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExperienceExperienceModelAddExperienceByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExperienceExperienceModelAddExperienceByUserDistribution) Pointer() *ExperienceExperienceModelAddExperienceByUserDistribution {
	return &p
}

func CastExperienceExperienceModelAddExperienceByUserDistributions(data []interface{}) []ExperienceExperienceModelAddExperienceByUserDistribution {
	v := make([]ExperienceExperienceModelAddExperienceByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceByUserDistributionsFromDict(data []ExperienceExperienceModelAddExperienceByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics{}
	} else {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticsFromJson(data string) ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics {
	req := ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticsFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics {
	return ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics) Pointer() *ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics {
	return &p
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticses(data []interface{}) []ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics {
	v := make([]ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticsesFromDict(data []ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment{}
	} else {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionSegmentFromJson(data string) ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment {
	req := ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionSegmentFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment {
	return ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment) Pointer() *ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment {
	return &p
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributionSegments(data []interface{}) []ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment {
	v := make([]ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceAmountByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributionSegmentsFromDict(data []ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceAmountByUserDistribution struct {
	Statistics   *ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics `json:"statistics"`
	Distribution []ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment   `json:"distribution"`
}

func (p *ExperienceExperienceModelAddExperienceAmountByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistribution{}
	} else {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionFromJson(data string) ExperienceExperienceModelAddExperienceAmountByUserDistribution {
	req := ExperienceExperienceModelAddExperienceAmountByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceAmountByUserDistribution {
	return ExperienceExperienceModelAddExperienceAmountByUserDistribution{
		Statistics:   NewExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExperienceExperienceModelAddExperienceAmountByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExperienceExperienceModelAddExperienceAmountByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistribution) Pointer() *ExperienceExperienceModelAddExperienceAmountByUserDistribution {
	return &p
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributions(data []interface{}) []ExperienceExperienceModelAddExperienceAmountByUserDistribution {
	v := make([]ExperienceExperienceModelAddExperienceAmountByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceAmountByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributionsFromDict(data []ExperienceExperienceModelAddExperienceAmountByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceExperienceModelAddRankCapByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionStatistics{}
	} else {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapByUserDistributionStatisticsFromJson(data string) ExperienceExperienceModelAddRankCapByUserDistributionStatistics {
	req := ExperienceExperienceModelAddRankCapByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapByUserDistributionStatisticsFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapByUserDistributionStatistics {
	return ExperienceExperienceModelAddRankCapByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExperienceExperienceModelAddRankCapByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExperienceExperienceModelAddRankCapByUserDistributionStatistics) Pointer() *ExperienceExperienceModelAddRankCapByUserDistributionStatistics {
	return &p
}

func CastExperienceExperienceModelAddRankCapByUserDistributionStatisticses(data []interface{}) []ExperienceExperienceModelAddRankCapByUserDistributionStatistics {
	v := make([]ExperienceExperienceModelAddRankCapByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapByUserDistributionStatisticsesFromDict(data []ExperienceExperienceModelAddRankCapByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceExperienceModelAddRankCapByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionSegment{}
	} else {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapByUserDistributionSegmentFromJson(data string) ExperienceExperienceModelAddRankCapByUserDistributionSegment {
	req := ExperienceExperienceModelAddRankCapByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapByUserDistributionSegmentFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapByUserDistributionSegment {
	return ExperienceExperienceModelAddRankCapByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ExperienceExperienceModelAddRankCapByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ExperienceExperienceModelAddRankCapByUserDistributionSegment) Pointer() *ExperienceExperienceModelAddRankCapByUserDistributionSegment {
	return &p
}

func CastExperienceExperienceModelAddRankCapByUserDistributionSegments(data []interface{}) []ExperienceExperienceModelAddRankCapByUserDistributionSegment {
	v := make([]ExperienceExperienceModelAddRankCapByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapByUserDistributionSegmentsFromDict(data []ExperienceExperienceModelAddRankCapByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapByUserDistribution struct {
	Statistics   *ExperienceExperienceModelAddRankCapByUserDistributionStatistics `json:"statistics"`
	Distribution []ExperienceExperienceModelAddRankCapByUserDistributionSegment   `json:"distribution"`
}

func (p *ExperienceExperienceModelAddRankCapByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapByUserDistribution{}
	} else {
		*p = ExperienceExperienceModelAddRankCapByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapByUserDistributionFromJson(data string) ExperienceExperienceModelAddRankCapByUserDistribution {
	req := ExperienceExperienceModelAddRankCapByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapByUserDistributionFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapByUserDistribution {
	return ExperienceExperienceModelAddRankCapByUserDistribution{
		Statistics:   NewExperienceExperienceModelAddRankCapByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExperienceExperienceModelAddRankCapByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExperienceExperienceModelAddRankCapByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExperienceExperienceModelAddRankCapByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExperienceExperienceModelAddRankCapByUserDistribution) Pointer() *ExperienceExperienceModelAddRankCapByUserDistribution {
	return &p
}

func CastExperienceExperienceModelAddRankCapByUserDistributions(data []interface{}) []ExperienceExperienceModelAddRankCapByUserDistribution {
	v := make([]ExperienceExperienceModelAddRankCapByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapByUserDistributionsFromDict(data []ExperienceExperienceModelAddRankCapByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics{}
	} else {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticsFromJson(data string) ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics {
	req := ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticsFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics {
	return ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics) Pointer() *ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics {
	return &p
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticses(data []interface{}) []ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics {
	v := make([]ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticsesFromDict(data []ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment{}
	} else {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionSegmentFromJson(data string) ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment {
	req := ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionSegmentFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment {
	return ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment) Pointer() *ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment {
	return &p
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributionSegments(data []interface{}) []ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment {
	v := make([]ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapAmountByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributionSegmentsFromDict(data []ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapAmountByUserDistribution struct {
	Statistics   *ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics `json:"statistics"`
	Distribution []ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment   `json:"distribution"`
}

func (p *ExperienceExperienceModelAddRankCapAmountByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistribution{}
	} else {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionFromJson(data string) ExperienceExperienceModelAddRankCapAmountByUserDistribution {
	req := ExperienceExperienceModelAddRankCapAmountByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapAmountByUserDistribution {
	return ExperienceExperienceModelAddRankCapAmountByUserDistribution{
		Statistics:   NewExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExperienceExperienceModelAddRankCapAmountByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExperienceExperienceModelAddRankCapAmountByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistribution) Pointer() *ExperienceExperienceModelAddRankCapAmountByUserDistribution {
	return &p
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributions(data []interface{}) []ExperienceExperienceModelAddRankCapAmountByUserDistribution {
	v := make([]ExperienceExperienceModelAddRankCapAmountByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapAmountByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributionsFromDict(data []ExperienceExperienceModelAddRankCapAmountByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelDistributions struct {
	AddExperienceByUser       *ExperienceExperienceModelAddExperienceByUserDistribution       `json:"addExperienceByUser"`
	AddExperienceAmountByUser *ExperienceExperienceModelAddExperienceAmountByUserDistribution `json:"addExperienceAmountByUser"`
	AddRankCapByUser          *ExperienceExperienceModelAddRankCapByUserDistribution          `json:"addRankCapByUser"`
	AddRankCapAmountByUser    *ExperienceExperienceModelAddRankCapAmountByUserDistribution    `json:"addRankCapAmountByUser"`
}

func (p *ExperienceExperienceModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelDistributions{}
	} else {
		*p = ExperienceExperienceModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["addExperienceByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddExperienceByUser)
		}
		if v, ok := d["addExperienceAmountByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddExperienceAmountByUser)
		}
		if v, ok := d["addRankCapByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddRankCapByUser)
		}
		if v, ok := d["addRankCapAmountByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddRankCapAmountByUser)
		}
	}
	return nil
}

func NewExperienceExperienceModelDistributionsFromJson(data string) ExperienceExperienceModelDistributions {
	req := ExperienceExperienceModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelDistributionsFromDict(data map[string]interface{}) ExperienceExperienceModelDistributions {
	return ExperienceExperienceModelDistributions{
		AddExperienceByUser:       NewExperienceExperienceModelAddExperienceByUserDistributionFromDict(core.CastMap(data["addExperienceByUser"])).Pointer(),
		AddExperienceAmountByUser: NewExperienceExperienceModelAddExperienceAmountByUserDistributionFromDict(core.CastMap(data["addExperienceAmountByUser"])).Pointer(),
		AddRankCapByUser:          NewExperienceExperienceModelAddRankCapByUserDistributionFromDict(core.CastMap(data["addRankCapByUser"])).Pointer(),
		AddRankCapAmountByUser:    NewExperienceExperienceModelAddRankCapAmountByUserDistributionFromDict(core.CastMap(data["addRankCapAmountByUser"])).Pointer(),
	}
}

func (p ExperienceExperienceModelDistributions) ToDict() map[string]interface{} {

	var addExperienceByUser map[string]interface{}
	if p.AddExperienceByUser != nil {
		addExperienceByUser = p.AddExperienceByUser.ToDict()
	}
	var addExperienceAmountByUser map[string]interface{}
	if p.AddExperienceAmountByUser != nil {
		addExperienceAmountByUser = p.AddExperienceAmountByUser.ToDict()
	}
	var addRankCapByUser map[string]interface{}
	if p.AddRankCapByUser != nil {
		addRankCapByUser = p.AddRankCapByUser.ToDict()
	}
	var addRankCapAmountByUser map[string]interface{}
	if p.AddRankCapAmountByUser != nil {
		addRankCapAmountByUser = p.AddRankCapAmountByUser.ToDict()
	}
	return map[string]interface{}{
		"addExperienceByUser":       addExperienceByUser,
		"addExperienceAmountByUser": addExperienceAmountByUser,
		"addRankCapByUser":          addRankCapByUser,
		"addRankCapAmountByUser":    addRankCapAmountByUser,
	}
}

func (p ExperienceExperienceModelDistributions) Pointer() *ExperienceExperienceModelDistributions {
	return &p
}

func CastExperienceExperienceModelDistributionses(data []interface{}) []ExperienceExperienceModelDistributions {
	v := make([]ExperienceExperienceModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelDistributionsesFromDict(data []ExperienceExperienceModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModel struct {
	ExperienceModelId *string                                 `json:"experienceModelId"`
	ExperienceName    *string                                 `json:"experienceName"`
	Statistics        *ExperienceExperienceModelStatistics    `json:"statistics"`
	Distributions     *ExperienceExperienceModelDistributions `json:"distributions"`
	Statuses          []ExperienceStatus                      `json:"statuses"`
}

func (p *ExperienceExperienceModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModel{}
	} else {
		*p = ExperienceExperienceModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["experienceModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ExperienceModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ExperienceModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ExperienceModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ExperienceModelId)
				}
			}
		}
		if v, ok := d["experienceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ExperienceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ExperienceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ExperienceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ExperienceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["statuses"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statuses)
		}
	}
	return nil
}

func NewExperienceExperienceModelFromJson(data string) ExperienceExperienceModel {
	req := ExperienceExperienceModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelFromDict(data map[string]interface{}) ExperienceExperienceModel {
	return ExperienceExperienceModel{
		ExperienceModelId: core.CastString(data["experienceModelId"]),
		ExperienceName:    core.CastString(data["experienceName"]),
		Statistics:        NewExperienceExperienceModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions:     NewExperienceExperienceModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		Statuses:          CastExperienceStatuses(core.CastArray(data["statuses"])),
	}
}

func (p ExperienceExperienceModel) ToDict() map[string]interface{} {

	var experienceModelId *string
	if p.ExperienceModelId != nil {
		experienceModelId = p.ExperienceModelId
	}
	var experienceName *string
	if p.ExperienceName != nil {
		experienceName = p.ExperienceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var statuses []interface{}
	if p.Statuses != nil {
		statuses = CastExperienceStatusesFromDict(
			p.Statuses,
		)
	}
	return map[string]interface{}{
		"experienceModelId": experienceModelId,
		"experienceName":    experienceName,
		"statistics":        statistics,
		"distributions":     distributions,
		"statuses":          statuses,
	}
}

func (p ExperienceExperienceModel) Pointer() *ExperienceExperienceModel {
	return &p
}

func CastExperienceExperienceModels(data []interface{}) []ExperienceExperienceModel {
	v := make([]ExperienceExperienceModel, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelsFromDict(data []ExperienceExperienceModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceStatistics struct {
	Experience *int64 `json:"experience"`
	RankCap    *int64 `json:"rankCap"`
}

func (p *ExperienceNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceStatistics{}
	} else {
		*p = ExperienceNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["experience"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Experience)
		}
		if v, ok := d["rankCap"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RankCap)
		}
	}
	return nil
}

func NewExperienceNamespaceStatisticsFromJson(data string) ExperienceNamespaceStatistics {
	req := ExperienceNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceStatisticsFromDict(data map[string]interface{}) ExperienceNamespaceStatistics {
	return ExperienceNamespaceStatistics{
		Experience: core.CastInt64(data["experience"]),
		RankCap:    core.CastInt64(data["rankCap"]),
	}
}

func (p ExperienceNamespaceStatistics) ToDict() map[string]interface{} {

	var experience *int64
	if p.Experience != nil {
		experience = p.Experience
	}
	var rankCap *int64
	if p.RankCap != nil {
		rankCap = p.RankCap
	}
	return map[string]interface{}{
		"experience": experience,
		"rankCap":    rankCap,
	}
}

func (p ExperienceNamespaceStatistics) Pointer() *ExperienceNamespaceStatistics {
	return &p
}

func CastExperienceNamespaceStatisticses(data []interface{}) []ExperienceNamespaceStatistics {
	v := make([]ExperienceNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceStatisticsesFromDict(data []ExperienceNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddExperienceByExperienceDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceNamespaceAddExperienceByExperienceDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionStatistics{}
	} else {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionStatisticsFromJson(data string) ExperienceNamespaceAddExperienceByExperienceDistributionStatistics {
	req := ExperienceNamespaceAddExperienceByExperienceDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionStatisticsFromDict(data map[string]interface{}) ExperienceNamespaceAddExperienceByExperienceDistributionStatistics {
	return ExperienceNamespaceAddExperienceByExperienceDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExperienceNamespaceAddExperienceByExperienceDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExperienceNamespaceAddExperienceByExperienceDistributionStatistics) Pointer() *ExperienceNamespaceAddExperienceByExperienceDistributionStatistics {
	return &p
}

func CastExperienceNamespaceAddExperienceByExperienceDistributionStatisticses(data []interface{}) []ExperienceNamespaceAddExperienceByExperienceDistributionStatistics {
	v := make([]ExperienceNamespaceAddExperienceByExperienceDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddExperienceByExperienceDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddExperienceByExperienceDistributionStatisticsesFromDict(data []ExperienceNamespaceAddExperienceByExperienceDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddExperienceByExperienceDistributionSegment struct {
	ExperienceName *string `json:"experienceName"`
	Count          *int64  `json:"count"`
}

func (p *ExperienceNamespaceAddExperienceByExperienceDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionSegment{}
	} else {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["experienceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ExperienceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ExperienceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ExperienceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ExperienceName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionSegmentFromJson(data string) ExperienceNamespaceAddExperienceByExperienceDistributionSegment {
	req := ExperienceNamespaceAddExperienceByExperienceDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionSegmentFromDict(data map[string]interface{}) ExperienceNamespaceAddExperienceByExperienceDistributionSegment {
	return ExperienceNamespaceAddExperienceByExperienceDistributionSegment{
		ExperienceName: core.CastString(data["experienceName"]),
		Count:          core.CastInt64(data["count"]),
	}
}

func (p ExperienceNamespaceAddExperienceByExperienceDistributionSegment) ToDict() map[string]interface{} {

	var experienceName *string
	if p.ExperienceName != nil {
		experienceName = p.ExperienceName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"experienceName": experienceName,
		"count":          count,
	}
}

func (p ExperienceNamespaceAddExperienceByExperienceDistributionSegment) Pointer() *ExperienceNamespaceAddExperienceByExperienceDistributionSegment {
	return &p
}

func CastExperienceNamespaceAddExperienceByExperienceDistributionSegments(data []interface{}) []ExperienceNamespaceAddExperienceByExperienceDistributionSegment {
	v := make([]ExperienceNamespaceAddExperienceByExperienceDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddExperienceByExperienceDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddExperienceByExperienceDistributionSegmentsFromDict(data []ExperienceNamespaceAddExperienceByExperienceDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddExperienceByExperienceDistribution struct {
	Statistics   *ExperienceNamespaceAddExperienceByExperienceDistributionStatistics `json:"statistics"`
	Distribution []ExperienceNamespaceAddExperienceByExperienceDistributionSegment   `json:"distribution"`
}

func (p *ExperienceNamespaceAddExperienceByExperienceDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddExperienceByExperienceDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddExperienceByExperienceDistribution{}
	} else {
		*p = ExperienceNamespaceAddExperienceByExperienceDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionFromJson(data string) ExperienceNamespaceAddExperienceByExperienceDistribution {
	req := ExperienceNamespaceAddExperienceByExperienceDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionFromDict(data map[string]interface{}) ExperienceNamespaceAddExperienceByExperienceDistribution {
	return ExperienceNamespaceAddExperienceByExperienceDistribution{
		Statistics:   NewExperienceNamespaceAddExperienceByExperienceDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExperienceNamespaceAddExperienceByExperienceDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExperienceNamespaceAddExperienceByExperienceDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExperienceNamespaceAddExperienceByExperienceDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExperienceNamespaceAddExperienceByExperienceDistribution) Pointer() *ExperienceNamespaceAddExperienceByExperienceDistribution {
	return &p
}

func CastExperienceNamespaceAddExperienceByExperienceDistributions(data []interface{}) []ExperienceNamespaceAddExperienceByExperienceDistribution {
	v := make([]ExperienceNamespaceAddExperienceByExperienceDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddExperienceByExperienceDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddExperienceByExperienceDistributionsFromDict(data []ExperienceNamespaceAddExperienceByExperienceDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddRankCapByExperienceDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceNamespaceAddRankCapByExperienceDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionStatistics{}
	} else {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionStatisticsFromJson(data string) ExperienceNamespaceAddRankCapByExperienceDistributionStatistics {
	req := ExperienceNamespaceAddRankCapByExperienceDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionStatisticsFromDict(data map[string]interface{}) ExperienceNamespaceAddRankCapByExperienceDistributionStatistics {
	return ExperienceNamespaceAddRankCapByExperienceDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ExperienceNamespaceAddRankCapByExperienceDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ExperienceNamespaceAddRankCapByExperienceDistributionStatistics) Pointer() *ExperienceNamespaceAddRankCapByExperienceDistributionStatistics {
	return &p
}

func CastExperienceNamespaceAddRankCapByExperienceDistributionStatisticses(data []interface{}) []ExperienceNamespaceAddRankCapByExperienceDistributionStatistics {
	v := make([]ExperienceNamespaceAddRankCapByExperienceDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddRankCapByExperienceDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddRankCapByExperienceDistributionStatisticsesFromDict(data []ExperienceNamespaceAddRankCapByExperienceDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddRankCapByExperienceDistributionSegment struct {
	ExperienceName *string `json:"experienceName"`
	Count          *int64  `json:"count"`
}

func (p *ExperienceNamespaceAddRankCapByExperienceDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionSegment{}
	} else {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["experienceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ExperienceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ExperienceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ExperienceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ExperienceName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionSegmentFromJson(data string) ExperienceNamespaceAddRankCapByExperienceDistributionSegment {
	req := ExperienceNamespaceAddRankCapByExperienceDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionSegmentFromDict(data map[string]interface{}) ExperienceNamespaceAddRankCapByExperienceDistributionSegment {
	return ExperienceNamespaceAddRankCapByExperienceDistributionSegment{
		ExperienceName: core.CastString(data["experienceName"]),
		Count:          core.CastInt64(data["count"]),
	}
}

func (p ExperienceNamespaceAddRankCapByExperienceDistributionSegment) ToDict() map[string]interface{} {

	var experienceName *string
	if p.ExperienceName != nil {
		experienceName = p.ExperienceName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"experienceName": experienceName,
		"count":          count,
	}
}

func (p ExperienceNamespaceAddRankCapByExperienceDistributionSegment) Pointer() *ExperienceNamespaceAddRankCapByExperienceDistributionSegment {
	return &p
}

func CastExperienceNamespaceAddRankCapByExperienceDistributionSegments(data []interface{}) []ExperienceNamespaceAddRankCapByExperienceDistributionSegment {
	v := make([]ExperienceNamespaceAddRankCapByExperienceDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddRankCapByExperienceDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddRankCapByExperienceDistributionSegmentsFromDict(data []ExperienceNamespaceAddRankCapByExperienceDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddRankCapByExperienceDistribution struct {
	Statistics   *ExperienceNamespaceAddRankCapByExperienceDistributionStatistics `json:"statistics"`
	Distribution []ExperienceNamespaceAddRankCapByExperienceDistributionSegment   `json:"distribution"`
}

func (p *ExperienceNamespaceAddRankCapByExperienceDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddRankCapByExperienceDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddRankCapByExperienceDistribution{}
	} else {
		*p = ExperienceNamespaceAddRankCapByExperienceDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionFromJson(data string) ExperienceNamespaceAddRankCapByExperienceDistribution {
	req := ExperienceNamespaceAddRankCapByExperienceDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionFromDict(data map[string]interface{}) ExperienceNamespaceAddRankCapByExperienceDistribution {
	return ExperienceNamespaceAddRankCapByExperienceDistribution{
		Statistics:   NewExperienceNamespaceAddRankCapByExperienceDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastExperienceNamespaceAddRankCapByExperienceDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ExperienceNamespaceAddRankCapByExperienceDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastExperienceNamespaceAddRankCapByExperienceDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ExperienceNamespaceAddRankCapByExperienceDistribution) Pointer() *ExperienceNamespaceAddRankCapByExperienceDistribution {
	return &p
}

func CastExperienceNamespaceAddRankCapByExperienceDistributions(data []interface{}) []ExperienceNamespaceAddRankCapByExperienceDistribution {
	v := make([]ExperienceNamespaceAddRankCapByExperienceDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddRankCapByExperienceDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddRankCapByExperienceDistributionsFromDict(data []ExperienceNamespaceAddRankCapByExperienceDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceDistributions struct {
	AddExperienceByExperience *ExperienceNamespaceAddExperienceByExperienceDistribution `json:"addExperienceByExperience"`
	AddRankCapByExperience    *ExperienceNamespaceAddRankCapByExperienceDistribution    `json:"addRankCapByExperience"`
}

func (p *ExperienceNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceDistributions{}
	} else {
		*p = ExperienceNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["addExperienceByExperience"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddExperienceByExperience)
		}
		if v, ok := d["addRankCapByExperience"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddRankCapByExperience)
		}
	}
	return nil
}

func NewExperienceNamespaceDistributionsFromJson(data string) ExperienceNamespaceDistributions {
	req := ExperienceNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceDistributionsFromDict(data map[string]interface{}) ExperienceNamespaceDistributions {
	return ExperienceNamespaceDistributions{
		AddExperienceByExperience: NewExperienceNamespaceAddExperienceByExperienceDistributionFromDict(core.CastMap(data["addExperienceByExperience"])).Pointer(),
		AddRankCapByExperience:    NewExperienceNamespaceAddRankCapByExperienceDistributionFromDict(core.CastMap(data["addRankCapByExperience"])).Pointer(),
	}
}

func (p ExperienceNamespaceDistributions) ToDict() map[string]interface{} {

	var addExperienceByExperience map[string]interface{}
	if p.AddExperienceByExperience != nil {
		addExperienceByExperience = p.AddExperienceByExperience.ToDict()
	}
	var addRankCapByExperience map[string]interface{}
	if p.AddRankCapByExperience != nil {
		addRankCapByExperience = p.AddRankCapByExperience.ToDict()
	}
	return map[string]interface{}{
		"addExperienceByExperience": addExperienceByExperience,
		"addRankCapByExperience":    addRankCapByExperience,
	}
}

func (p ExperienceNamespaceDistributions) Pointer() *ExperienceNamespaceDistributions {
	return &p
}

func CastExperienceNamespaceDistributionses(data []interface{}) []ExperienceNamespaceDistributions {
	v := make([]ExperienceNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceDistributionsesFromDict(data []ExperienceNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespace struct {
	NamespaceId      *string                           `json:"namespaceId"`
	Year             *int32                            `json:"year"`
	Month            *int32                            `json:"month"`
	Day              *int32                            `json:"day"`
	NamespaceName    *string                           `json:"namespaceName"`
	Statistics       *ExperienceNamespaceStatistics    `json:"statistics"`
	Distributions    *ExperienceNamespaceDistributions `json:"distributions"`
	ExperienceModels []ExperienceExperienceModel       `json:"experienceModels"`
}

func (p *ExperienceNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespace{}
	} else {
		*p = ExperienceNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["experienceModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExperienceModels)
		}
	}
	return nil
}

func NewExperienceNamespaceFromJson(data string) ExperienceNamespace {
	req := ExperienceNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceFromDict(data map[string]interface{}) ExperienceNamespace {
	return ExperienceNamespace{
		NamespaceId:      core.CastString(data["namespaceId"]),
		Year:             core.CastInt32(data["year"]),
		Month:            core.CastInt32(data["month"]),
		Day:              core.CastInt32(data["day"]),
		NamespaceName:    core.CastString(data["namespaceName"]),
		Statistics:       NewExperienceNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions:    NewExperienceNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		ExperienceModels: CastExperienceExperienceModels(core.CastArray(data["experienceModels"])),
	}
}

func (p ExperienceNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var experienceModels []interface{}
	if p.ExperienceModels != nil {
		experienceModels = CastExperienceExperienceModelsFromDict(
			p.ExperienceModels,
		)
	}
	return map[string]interface{}{
		"namespaceId":      namespaceId,
		"year":             year,
		"month":            month,
		"day":              day,
		"namespaceName":    namespaceName,
		"statistics":       statistics,
		"distributions":    distributions,
		"experienceModels": experienceModels,
	}
}

func (p ExperienceNamespace) Pointer() *ExperienceNamespace {
	return &p
}

func CastExperienceNamespaces(data []interface{}) []ExperienceNamespace {
	v := make([]ExperienceNamespace, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespacesFromDict(data []ExperienceNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormStatistics struct {
	Update *int64 `json:"update"`
}

func (p *FormationFormStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormStatistics{}
	} else {
		*p = FormationFormStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["update"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Update)
		}
	}
	return nil
}

func NewFormationFormStatisticsFromJson(data string) FormationFormStatistics {
	req := FormationFormStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormStatisticsFromDict(data map[string]interface{}) FormationFormStatistics {
	return FormationFormStatistics{
		Update: core.CastInt64(data["update"]),
	}
}

func (p FormationFormStatistics) ToDict() map[string]interface{} {

	var update *int64
	if p.Update != nil {
		update = p.Update
	}
	return map[string]interface{}{
		"update": update,
	}
}

func (p FormationFormStatistics) Pointer() *FormationFormStatistics {
	return &p
}

func CastFormationFormStatisticses(data []interface{}) []FormationFormStatistics {
	v := make([]FormationFormStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationFormStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormStatisticsesFromDict(data []FormationFormStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormSlotDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationFormSlotDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormSlotDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormSlotDistributionStatistics{}
	} else {
		*p = FormationFormSlotDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationFormSlotDistributionStatisticsFromJson(data string) FormationFormSlotDistributionStatistics {
	req := FormationFormSlotDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormSlotDistributionStatisticsFromDict(data map[string]interface{}) FormationFormSlotDistributionStatistics {
	return FormationFormSlotDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FormationFormSlotDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FormationFormSlotDistributionStatistics) Pointer() *FormationFormSlotDistributionStatistics {
	return &p
}

func CastFormationFormSlotDistributionStatisticses(data []interface{}) []FormationFormSlotDistributionStatistics {
	v := make([]FormationFormSlotDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationFormSlotDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormSlotDistributionStatisticsesFromDict(data []FormationFormSlotDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormSlotDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FormationFormSlotDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormSlotDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormSlotDistributionSegment{}
	} else {
		*p = FormationFormSlotDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationFormSlotDistributionSegmentFromJson(data string) FormationFormSlotDistributionSegment {
	req := FormationFormSlotDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormSlotDistributionSegmentFromDict(data map[string]interface{}) FormationFormSlotDistributionSegment {
	return FormationFormSlotDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p FormationFormSlotDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p FormationFormSlotDistributionSegment) Pointer() *FormationFormSlotDistributionSegment {
	return &p
}

func CastFormationFormSlotDistributionSegments(data []interface{}) []FormationFormSlotDistributionSegment {
	v := make([]FormationFormSlotDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationFormSlotDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormSlotDistributionSegmentsFromDict(data []FormationFormSlotDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormSlotDistribution struct {
	Statistics   *FormationFormSlotDistributionStatistics `json:"statistics"`
	Distribution []FormationFormSlotDistributionSegment   `json:"distribution"`
}

func (p *FormationFormSlotDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormSlotDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormSlotDistribution{}
	} else {
		*p = FormationFormSlotDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationFormSlotDistributionFromJson(data string) FormationFormSlotDistribution {
	req := FormationFormSlotDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormSlotDistributionFromDict(data map[string]interface{}) FormationFormSlotDistribution {
	return FormationFormSlotDistribution{
		Statistics:   NewFormationFormSlotDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFormationFormSlotDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FormationFormSlotDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFormationFormSlotDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FormationFormSlotDistribution) Pointer() *FormationFormSlotDistribution {
	return &p
}

func CastFormationFormSlotDistributions(data []interface{}) []FormationFormSlotDistribution {
	v := make([]FormationFormSlotDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationFormSlotDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormSlotDistributionsFromDict(data []FormationFormSlotDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormUsageDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationFormUsageDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormUsageDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormUsageDistributionStatistics{}
	} else {
		*p = FormationFormUsageDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationFormUsageDistributionStatisticsFromJson(data string) FormationFormUsageDistributionStatistics {
	req := FormationFormUsageDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormUsageDistributionStatisticsFromDict(data map[string]interface{}) FormationFormUsageDistributionStatistics {
	return FormationFormUsageDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FormationFormUsageDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FormationFormUsageDistributionStatistics) Pointer() *FormationFormUsageDistributionStatistics {
	return &p
}

func CastFormationFormUsageDistributionStatisticses(data []interface{}) []FormationFormUsageDistributionStatistics {
	v := make([]FormationFormUsageDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationFormUsageDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormUsageDistributionStatisticsesFromDict(data []FormationFormUsageDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormUsageDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FormationFormUsageDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormUsageDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormUsageDistributionSegment{}
	} else {
		*p = FormationFormUsageDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationFormUsageDistributionSegmentFromJson(data string) FormationFormUsageDistributionSegment {
	req := FormationFormUsageDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormUsageDistributionSegmentFromDict(data map[string]interface{}) FormationFormUsageDistributionSegment {
	return FormationFormUsageDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p FormationFormUsageDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p FormationFormUsageDistributionSegment) Pointer() *FormationFormUsageDistributionSegment {
	return &p
}

func CastFormationFormUsageDistributionSegments(data []interface{}) []FormationFormUsageDistributionSegment {
	v := make([]FormationFormUsageDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationFormUsageDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormUsageDistributionSegmentsFromDict(data []FormationFormUsageDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormUsageDistribution struct {
	Statistics   *FormationFormUsageDistributionStatistics `json:"statistics"`
	Distribution []FormationFormUsageDistributionSegment   `json:"distribution"`
}

func (p *FormationFormUsageDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormUsageDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormUsageDistribution{}
	} else {
		*p = FormationFormUsageDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationFormUsageDistributionFromJson(data string) FormationFormUsageDistribution {
	req := FormationFormUsageDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormUsageDistributionFromDict(data map[string]interface{}) FormationFormUsageDistribution {
	return FormationFormUsageDistribution{
		Statistics:   NewFormationFormUsageDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFormationFormUsageDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FormationFormUsageDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFormationFormUsageDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FormationFormUsageDistribution) Pointer() *FormationFormUsageDistribution {
	return &p
}

func CastFormationFormUsageDistributions(data []interface{}) []FormationFormUsageDistribution {
	v := make([]FormationFormUsageDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationFormUsageDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormUsageDistributionsFromDict(data []FormationFormUsageDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormDistributions struct {
	Slot  *FormationFormSlotDistribution  `json:"slot"`
	Usage *FormationFormUsageDistribution `json:"usage"`
}

func (p *FormationFormDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormDistributions{}
	} else {
		*p = FormationFormDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["slot"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Slot)
		}
		if v, ok := d["usage"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Usage)
		}
	}
	return nil
}

func NewFormationFormDistributionsFromJson(data string) FormationFormDistributions {
	req := FormationFormDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormDistributionsFromDict(data map[string]interface{}) FormationFormDistributions {
	return FormationFormDistributions{
		Slot:  NewFormationFormSlotDistributionFromDict(core.CastMap(data["slot"])).Pointer(),
		Usage: NewFormationFormUsageDistributionFromDict(core.CastMap(data["usage"])).Pointer(),
	}
}

func (p FormationFormDistributions) ToDict() map[string]interface{} {

	var slot map[string]interface{}
	if p.Slot != nil {
		slot = p.Slot.ToDict()
	}
	var usage map[string]interface{}
	if p.Usage != nil {
		usage = p.Usage.ToDict()
	}
	return map[string]interface{}{
		"slot":  slot,
		"usage": usage,
	}
}

func (p FormationFormDistributions) Pointer() *FormationFormDistributions {
	return &p
}

func CastFormationFormDistributionses(data []interface{}) []FormationFormDistributions {
	v := make([]FormationFormDistributions, 0)
	for _, d := range data {
		v = append(v, NewFormationFormDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormDistributionsesFromDict(data []FormationFormDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationForm struct {
	FormId        *string                     `json:"formId"`
	Index         *int32                      `json:"index"`
	Statistics    *FormationFormStatistics    `json:"statistics"`
	Distributions *FormationFormDistributions `json:"distributions"`
}

func (p *FormationForm) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationForm{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationForm{}
	} else {
		*p = FormationForm{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["formId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.FormId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.FormId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.FormId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.FormId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.FormId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.FormId)
				}
			}
		}
		if v, ok := d["index"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Index)
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewFormationFormFromJson(data string) FormationForm {
	req := FormationForm{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormFromDict(data map[string]interface{}) FormationForm {
	return FormationForm{
		FormId:        core.CastString(data["formId"]),
		Index:         core.CastInt32(data["index"]),
		Statistics:    NewFormationFormStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewFormationFormDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p FormationForm) ToDict() map[string]interface{} {

	var formId *string
	if p.FormId != nil {
		formId = p.FormId
	}
	var index *int32
	if p.Index != nil {
		index = p.Index
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"formId":        formId,
		"index":         index,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p FormationForm) Pointer() *FormationForm {
	return &p
}

func CastFormationForms(data []interface{}) []FormationForm {
	v := make([]FormationForm, 0)
	for _, d := range data {
		v = append(v, NewFormationFormFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormsFromDict(data []FormationForm) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldStatistics struct {
	IncreaseCapacity       *int64 `json:"increaseCapacity"`
	IncreaseCapacityAmount *int64 `json:"increaseCapacityAmount"`
}

func (p *FormationMoldStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldStatistics{}
	} else {
		*p = FormationMoldStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increaseCapacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacity)
		}
		if v, ok := d["increaseCapacityAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacityAmount)
		}
	}
	return nil
}

func NewFormationMoldStatisticsFromJson(data string) FormationMoldStatistics {
	req := FormationMoldStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldStatisticsFromDict(data map[string]interface{}) FormationMoldStatistics {
	return FormationMoldStatistics{
		IncreaseCapacity:       core.CastInt64(data["increaseCapacity"]),
		IncreaseCapacityAmount: core.CastInt64(data["increaseCapacityAmount"]),
	}
}

func (p FormationMoldStatistics) ToDict() map[string]interface{} {

	var increaseCapacity *int64
	if p.IncreaseCapacity != nil {
		increaseCapacity = p.IncreaseCapacity
	}
	var increaseCapacityAmount *int64
	if p.IncreaseCapacityAmount != nil {
		increaseCapacityAmount = p.IncreaseCapacityAmount
	}
	return map[string]interface{}{
		"increaseCapacity":       increaseCapacity,
		"increaseCapacityAmount": increaseCapacityAmount,
	}
}

func (p FormationMoldStatistics) Pointer() *FormationMoldStatistics {
	return &p
}

func CastFormationMoldStatisticses(data []interface{}) []FormationMoldStatistics {
	v := make([]FormationMoldStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldStatisticsesFromDict(data []FormationMoldStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldCapacityDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationMoldCapacityDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldCapacityDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldCapacityDistributionStatistics{}
	} else {
		*p = FormationMoldCapacityDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationMoldCapacityDistributionStatisticsFromJson(data string) FormationMoldCapacityDistributionStatistics {
	req := FormationMoldCapacityDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldCapacityDistributionStatisticsFromDict(data map[string]interface{}) FormationMoldCapacityDistributionStatistics {
	return FormationMoldCapacityDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FormationMoldCapacityDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FormationMoldCapacityDistributionStatistics) Pointer() *FormationMoldCapacityDistributionStatistics {
	return &p
}

func CastFormationMoldCapacityDistributionStatisticses(data []interface{}) []FormationMoldCapacityDistributionStatistics {
	v := make([]FormationMoldCapacityDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldCapacityDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldCapacityDistributionStatisticsesFromDict(data []FormationMoldCapacityDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldCapacityDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FormationMoldCapacityDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldCapacityDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldCapacityDistributionSegment{}
	} else {
		*p = FormationMoldCapacityDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationMoldCapacityDistributionSegmentFromJson(data string) FormationMoldCapacityDistributionSegment {
	req := FormationMoldCapacityDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldCapacityDistributionSegmentFromDict(data map[string]interface{}) FormationMoldCapacityDistributionSegment {
	return FormationMoldCapacityDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p FormationMoldCapacityDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p FormationMoldCapacityDistributionSegment) Pointer() *FormationMoldCapacityDistributionSegment {
	return &p
}

func CastFormationMoldCapacityDistributionSegments(data []interface{}) []FormationMoldCapacityDistributionSegment {
	v := make([]FormationMoldCapacityDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldCapacityDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldCapacityDistributionSegmentsFromDict(data []FormationMoldCapacityDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldCapacityDistribution struct {
	Statistics   *FormationMoldCapacityDistributionStatistics `json:"statistics"`
	Distribution []FormationMoldCapacityDistributionSegment   `json:"distribution"`
}

func (p *FormationMoldCapacityDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldCapacityDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldCapacityDistribution{}
	} else {
		*p = FormationMoldCapacityDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationMoldCapacityDistributionFromJson(data string) FormationMoldCapacityDistribution {
	req := FormationMoldCapacityDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldCapacityDistributionFromDict(data map[string]interface{}) FormationMoldCapacityDistribution {
	return FormationMoldCapacityDistribution{
		Statistics:   NewFormationMoldCapacityDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFormationMoldCapacityDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FormationMoldCapacityDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFormationMoldCapacityDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FormationMoldCapacityDistribution) Pointer() *FormationMoldCapacityDistribution {
	return &p
}

func CastFormationMoldCapacityDistributions(data []interface{}) []FormationMoldCapacityDistribution {
	v := make([]FormationMoldCapacityDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldCapacityDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldCapacityDistributionsFromDict(data []FormationMoldCapacityDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldUpdateByIndexDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationMoldUpdateByIndexDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldUpdateByIndexDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldUpdateByIndexDistributionStatistics{}
	} else {
		*p = FormationMoldUpdateByIndexDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationMoldUpdateByIndexDistributionStatisticsFromJson(data string) FormationMoldUpdateByIndexDistributionStatistics {
	req := FormationMoldUpdateByIndexDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldUpdateByIndexDistributionStatisticsFromDict(data map[string]interface{}) FormationMoldUpdateByIndexDistributionStatistics {
	return FormationMoldUpdateByIndexDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FormationMoldUpdateByIndexDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FormationMoldUpdateByIndexDistributionStatistics) Pointer() *FormationMoldUpdateByIndexDistributionStatistics {
	return &p
}

func CastFormationMoldUpdateByIndexDistributionStatisticses(data []interface{}) []FormationMoldUpdateByIndexDistributionStatistics {
	v := make([]FormationMoldUpdateByIndexDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldUpdateByIndexDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldUpdateByIndexDistributionStatisticsesFromDict(data []FormationMoldUpdateByIndexDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldUpdateByIndexDistributionSegment struct {
	Index *int64 `json:"index"`
	Count *int64 `json:"count"`
}

func (p *FormationMoldUpdateByIndexDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldUpdateByIndexDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldUpdateByIndexDistributionSegment{}
	} else {
		*p = FormationMoldUpdateByIndexDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["index"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Index)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationMoldUpdateByIndexDistributionSegmentFromJson(data string) FormationMoldUpdateByIndexDistributionSegment {
	req := FormationMoldUpdateByIndexDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldUpdateByIndexDistributionSegmentFromDict(data map[string]interface{}) FormationMoldUpdateByIndexDistributionSegment {
	return FormationMoldUpdateByIndexDistributionSegment{
		Index: core.CastInt64(data["index"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p FormationMoldUpdateByIndexDistributionSegment) ToDict() map[string]interface{} {

	var index *int64
	if p.Index != nil {
		index = p.Index
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"index": index,
		"count": count,
	}
}

func (p FormationMoldUpdateByIndexDistributionSegment) Pointer() *FormationMoldUpdateByIndexDistributionSegment {
	return &p
}

func CastFormationMoldUpdateByIndexDistributionSegments(data []interface{}) []FormationMoldUpdateByIndexDistributionSegment {
	v := make([]FormationMoldUpdateByIndexDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldUpdateByIndexDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldUpdateByIndexDistributionSegmentsFromDict(data []FormationMoldUpdateByIndexDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldUpdateByIndexDistribution struct {
	Statistics   *FormationMoldUpdateByIndexDistributionStatistics `json:"statistics"`
	Distribution []FormationMoldUpdateByIndexDistributionSegment   `json:"distribution"`
}

func (p *FormationMoldUpdateByIndexDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldUpdateByIndexDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldUpdateByIndexDistribution{}
	} else {
		*p = FormationMoldUpdateByIndexDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationMoldUpdateByIndexDistributionFromJson(data string) FormationMoldUpdateByIndexDistribution {
	req := FormationMoldUpdateByIndexDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldUpdateByIndexDistributionFromDict(data map[string]interface{}) FormationMoldUpdateByIndexDistribution {
	return FormationMoldUpdateByIndexDistribution{
		Statistics:   NewFormationMoldUpdateByIndexDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFormationMoldUpdateByIndexDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FormationMoldUpdateByIndexDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFormationMoldUpdateByIndexDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FormationMoldUpdateByIndexDistribution) Pointer() *FormationMoldUpdateByIndexDistribution {
	return &p
}

func CastFormationMoldUpdateByIndexDistributions(data []interface{}) []FormationMoldUpdateByIndexDistribution {
	v := make([]FormationMoldUpdateByIndexDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldUpdateByIndexDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldUpdateByIndexDistributionsFromDict(data []FormationMoldUpdateByIndexDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldDistributions struct {
	Capacity      *FormationMoldCapacityDistribution      `json:"capacity"`
	UpdateByIndex *FormationMoldUpdateByIndexDistribution `json:"updateByIndex"`
}

func (p *FormationMoldDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldDistributions{}
	} else {
		*p = FormationMoldDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["capacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Capacity)
		}
		if v, ok := d["updateByIndex"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.UpdateByIndex)
		}
	}
	return nil
}

func NewFormationMoldDistributionsFromJson(data string) FormationMoldDistributions {
	req := FormationMoldDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldDistributionsFromDict(data map[string]interface{}) FormationMoldDistributions {
	return FormationMoldDistributions{
		Capacity:      NewFormationMoldCapacityDistributionFromDict(core.CastMap(data["capacity"])).Pointer(),
		UpdateByIndex: NewFormationMoldUpdateByIndexDistributionFromDict(core.CastMap(data["updateByIndex"])).Pointer(),
	}
}

func (p FormationMoldDistributions) ToDict() map[string]interface{} {

	var capacity map[string]interface{}
	if p.Capacity != nil {
		capacity = p.Capacity.ToDict()
	}
	var updateByIndex map[string]interface{}
	if p.UpdateByIndex != nil {
		updateByIndex = p.UpdateByIndex.ToDict()
	}
	return map[string]interface{}{
		"capacity":      capacity,
		"updateByIndex": updateByIndex,
	}
}

func (p FormationMoldDistributions) Pointer() *FormationMoldDistributions {
	return &p
}

func CastFormationMoldDistributionses(data []interface{}) []FormationMoldDistributions {
	v := make([]FormationMoldDistributions, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldDistributionsesFromDict(data []FormationMoldDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMold struct {
	MoldId        *string                     `json:"moldId"`
	MoldModelName *string                     `json:"moldModelName"`
	Statistics    *FormationMoldStatistics    `json:"statistics"`
	Distributions *FormationMoldDistributions `json:"distributions"`
	Forms         []FormationForm             `json:"forms"`
}

func (p *FormationMold) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMold{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMold{}
	} else {
		*p = FormationMold{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["moldId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MoldId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MoldId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MoldId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MoldId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MoldId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MoldId)
				}
			}
		}
		if v, ok := d["moldModelName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MoldModelName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MoldModelName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MoldModelName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MoldModelName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["forms"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Forms)
		}
	}
	return nil
}

func NewFormationMoldFromJson(data string) FormationMold {
	req := FormationMold{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldFromDict(data map[string]interface{}) FormationMold {
	return FormationMold{
		MoldId:        core.CastString(data["moldId"]),
		MoldModelName: core.CastString(data["moldModelName"]),
		Statistics:    NewFormationMoldStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewFormationMoldDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		Forms:         CastFormationForms(core.CastArray(data["forms"])),
	}
}

func (p FormationMold) ToDict() map[string]interface{} {

	var moldId *string
	if p.MoldId != nil {
		moldId = p.MoldId
	}
	var moldModelName *string
	if p.MoldModelName != nil {
		moldModelName = p.MoldModelName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var forms []interface{}
	if p.Forms != nil {
		forms = CastFormationFormsFromDict(
			p.Forms,
		)
	}
	return map[string]interface{}{
		"moldId":        moldId,
		"moldModelName": moldModelName,
		"statistics":    statistics,
		"distributions": distributions,
		"forms":         forms,
	}
}

func (p FormationMold) Pointer() *FormationMold {
	return &p
}

func CastFormationMolds(data []interface{}) []FormationMold {
	v := make([]FormationMold, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldsFromDict(data []FormationMold) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceStatistics struct {
	Update   *int64 `json:"update"`
	Increase *int64 `json:"increase"`
}

func (p *FormationNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceStatistics{}
	} else {
		*p = FormationNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["update"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Update)
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
	}
	return nil
}

func NewFormationNamespaceStatisticsFromJson(data string) FormationNamespaceStatistics {
	req := FormationNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceStatisticsFromDict(data map[string]interface{}) FormationNamespaceStatistics {
	return FormationNamespaceStatistics{
		Update:   core.CastInt64(data["update"]),
		Increase: core.CastInt64(data["increase"]),
	}
}

func (p FormationNamespaceStatistics) ToDict() map[string]interface{} {

	var update *int64
	if p.Update != nil {
		update = p.Update
	}
	var increase *int64
	if p.Increase != nil {
		increase = p.Increase
	}
	return map[string]interface{}{
		"update":   update,
		"increase": increase,
	}
}

func (p FormationNamespaceStatistics) Pointer() *FormationNamespaceStatistics {
	return &p
}

func CastFormationNamespaceStatisticses(data []interface{}) []FormationNamespaceStatistics {
	v := make([]FormationNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceStatisticsesFromDict(data []FormationNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceUpdateByMoldDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationNamespaceUpdateByMoldDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceUpdateByMoldDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceUpdateByMoldDistributionStatistics{}
	} else {
		*p = FormationNamespaceUpdateByMoldDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationNamespaceUpdateByMoldDistributionStatisticsFromJson(data string) FormationNamespaceUpdateByMoldDistributionStatistics {
	req := FormationNamespaceUpdateByMoldDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceUpdateByMoldDistributionStatisticsFromDict(data map[string]interface{}) FormationNamespaceUpdateByMoldDistributionStatistics {
	return FormationNamespaceUpdateByMoldDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FormationNamespaceUpdateByMoldDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FormationNamespaceUpdateByMoldDistributionStatistics) Pointer() *FormationNamespaceUpdateByMoldDistributionStatistics {
	return &p
}

func CastFormationNamespaceUpdateByMoldDistributionStatisticses(data []interface{}) []FormationNamespaceUpdateByMoldDistributionStatistics {
	v := make([]FormationNamespaceUpdateByMoldDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceUpdateByMoldDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceUpdateByMoldDistributionStatisticsesFromDict(data []FormationNamespaceUpdateByMoldDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceUpdateByMoldDistributionSegment struct {
	MoldModelName *string `json:"moldModelName"`
	Count         *int64  `json:"count"`
}

func (p *FormationNamespaceUpdateByMoldDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceUpdateByMoldDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceUpdateByMoldDistributionSegment{}
	} else {
		*p = FormationNamespaceUpdateByMoldDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["moldModelName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MoldModelName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MoldModelName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MoldModelName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MoldModelName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationNamespaceUpdateByMoldDistributionSegmentFromJson(data string) FormationNamespaceUpdateByMoldDistributionSegment {
	req := FormationNamespaceUpdateByMoldDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceUpdateByMoldDistributionSegmentFromDict(data map[string]interface{}) FormationNamespaceUpdateByMoldDistributionSegment {
	return FormationNamespaceUpdateByMoldDistributionSegment{
		MoldModelName: core.CastString(data["moldModelName"]),
		Count:         core.CastInt64(data["count"]),
	}
}

func (p FormationNamespaceUpdateByMoldDistributionSegment) ToDict() map[string]interface{} {

	var moldModelName *string
	if p.MoldModelName != nil {
		moldModelName = p.MoldModelName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"moldModelName": moldModelName,
		"count":         count,
	}
}

func (p FormationNamespaceUpdateByMoldDistributionSegment) Pointer() *FormationNamespaceUpdateByMoldDistributionSegment {
	return &p
}

func CastFormationNamespaceUpdateByMoldDistributionSegments(data []interface{}) []FormationNamespaceUpdateByMoldDistributionSegment {
	v := make([]FormationNamespaceUpdateByMoldDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceUpdateByMoldDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceUpdateByMoldDistributionSegmentsFromDict(data []FormationNamespaceUpdateByMoldDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceUpdateByMoldDistribution struct {
	Statistics   *FormationNamespaceUpdateByMoldDistributionStatistics `json:"statistics"`
	Distribution []FormationNamespaceUpdateByMoldDistributionSegment   `json:"distribution"`
}

func (p *FormationNamespaceUpdateByMoldDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceUpdateByMoldDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceUpdateByMoldDistribution{}
	} else {
		*p = FormationNamespaceUpdateByMoldDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationNamespaceUpdateByMoldDistributionFromJson(data string) FormationNamespaceUpdateByMoldDistribution {
	req := FormationNamespaceUpdateByMoldDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceUpdateByMoldDistributionFromDict(data map[string]interface{}) FormationNamespaceUpdateByMoldDistribution {
	return FormationNamespaceUpdateByMoldDistribution{
		Statistics:   NewFormationNamespaceUpdateByMoldDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFormationNamespaceUpdateByMoldDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FormationNamespaceUpdateByMoldDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFormationNamespaceUpdateByMoldDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FormationNamespaceUpdateByMoldDistribution) Pointer() *FormationNamespaceUpdateByMoldDistribution {
	return &p
}

func CastFormationNamespaceUpdateByMoldDistributions(data []interface{}) []FormationNamespaceUpdateByMoldDistribution {
	v := make([]FormationNamespaceUpdateByMoldDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceUpdateByMoldDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceUpdateByMoldDistributionsFromDict(data []FormationNamespaceUpdateByMoldDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceIncreaseCapacityByMoldDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationNamespaceIncreaseCapacityByMoldDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionStatistics{}
	} else {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionStatisticsFromJson(data string) FormationNamespaceIncreaseCapacityByMoldDistributionStatistics {
	req := FormationNamespaceIncreaseCapacityByMoldDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionStatisticsFromDict(data map[string]interface{}) FormationNamespaceIncreaseCapacityByMoldDistributionStatistics {
	return FormationNamespaceIncreaseCapacityByMoldDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FormationNamespaceIncreaseCapacityByMoldDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FormationNamespaceIncreaseCapacityByMoldDistributionStatistics) Pointer() *FormationNamespaceIncreaseCapacityByMoldDistributionStatistics {
	return &p
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributionStatisticses(data []interface{}) []FormationNamespaceIncreaseCapacityByMoldDistributionStatistics {
	v := make([]FormationNamespaceIncreaseCapacityByMoldDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceIncreaseCapacityByMoldDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributionStatisticsesFromDict(data []FormationNamespaceIncreaseCapacityByMoldDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceIncreaseCapacityByMoldDistributionSegment struct {
	MoldModelName *string `json:"moldModelName"`
	Count         *int64  `json:"count"`
}

func (p *FormationNamespaceIncreaseCapacityByMoldDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionSegment{}
	} else {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["moldModelName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MoldModelName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MoldModelName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MoldModelName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MoldModelName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionSegmentFromJson(data string) FormationNamespaceIncreaseCapacityByMoldDistributionSegment {
	req := FormationNamespaceIncreaseCapacityByMoldDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionSegmentFromDict(data map[string]interface{}) FormationNamespaceIncreaseCapacityByMoldDistributionSegment {
	return FormationNamespaceIncreaseCapacityByMoldDistributionSegment{
		MoldModelName: core.CastString(data["moldModelName"]),
		Count:         core.CastInt64(data["count"]),
	}
}

func (p FormationNamespaceIncreaseCapacityByMoldDistributionSegment) ToDict() map[string]interface{} {

	var moldModelName *string
	if p.MoldModelName != nil {
		moldModelName = p.MoldModelName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"moldModelName": moldModelName,
		"count":         count,
	}
}

func (p FormationNamespaceIncreaseCapacityByMoldDistributionSegment) Pointer() *FormationNamespaceIncreaseCapacityByMoldDistributionSegment {
	return &p
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributionSegments(data []interface{}) []FormationNamespaceIncreaseCapacityByMoldDistributionSegment {
	v := make([]FormationNamespaceIncreaseCapacityByMoldDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceIncreaseCapacityByMoldDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributionSegmentsFromDict(data []FormationNamespaceIncreaseCapacityByMoldDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceIncreaseCapacityByMoldDistribution struct {
	Statistics   *FormationNamespaceIncreaseCapacityByMoldDistributionStatistics `json:"statistics"`
	Distribution []FormationNamespaceIncreaseCapacityByMoldDistributionSegment   `json:"distribution"`
}

func (p *FormationNamespaceIncreaseCapacityByMoldDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceIncreaseCapacityByMoldDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceIncreaseCapacityByMoldDistribution{}
	} else {
		*p = FormationNamespaceIncreaseCapacityByMoldDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionFromJson(data string) FormationNamespaceIncreaseCapacityByMoldDistribution {
	req := FormationNamespaceIncreaseCapacityByMoldDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionFromDict(data map[string]interface{}) FormationNamespaceIncreaseCapacityByMoldDistribution {
	return FormationNamespaceIncreaseCapacityByMoldDistribution{
		Statistics:   NewFormationNamespaceIncreaseCapacityByMoldDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFormationNamespaceIncreaseCapacityByMoldDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FormationNamespaceIncreaseCapacityByMoldDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFormationNamespaceIncreaseCapacityByMoldDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FormationNamespaceIncreaseCapacityByMoldDistribution) Pointer() *FormationNamespaceIncreaseCapacityByMoldDistribution {
	return &p
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributions(data []interface{}) []FormationNamespaceIncreaseCapacityByMoldDistribution {
	v := make([]FormationNamespaceIncreaseCapacityByMoldDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceIncreaseCapacityByMoldDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributionsFromDict(data []FormationNamespaceIncreaseCapacityByMoldDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceDistributions struct {
	UpdateByMold           *FormationNamespaceUpdateByMoldDistribution           `json:"updateByMold"`
	IncreaseCapacityByMold *FormationNamespaceIncreaseCapacityByMoldDistribution `json:"increaseCapacityByMold"`
}

func (p *FormationNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceDistributions{}
	} else {
		*p = FormationNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["updateByMold"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.UpdateByMold)
		}
		if v, ok := d["increaseCapacityByMold"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacityByMold)
		}
	}
	return nil
}

func NewFormationNamespaceDistributionsFromJson(data string) FormationNamespaceDistributions {
	req := FormationNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceDistributionsFromDict(data map[string]interface{}) FormationNamespaceDistributions {
	return FormationNamespaceDistributions{
		UpdateByMold:           NewFormationNamespaceUpdateByMoldDistributionFromDict(core.CastMap(data["updateByMold"])).Pointer(),
		IncreaseCapacityByMold: NewFormationNamespaceIncreaseCapacityByMoldDistributionFromDict(core.CastMap(data["increaseCapacityByMold"])).Pointer(),
	}
}

func (p FormationNamespaceDistributions) ToDict() map[string]interface{} {

	var updateByMold map[string]interface{}
	if p.UpdateByMold != nil {
		updateByMold = p.UpdateByMold.ToDict()
	}
	var increaseCapacityByMold map[string]interface{}
	if p.IncreaseCapacityByMold != nil {
		increaseCapacityByMold = p.IncreaseCapacityByMold.ToDict()
	}
	return map[string]interface{}{
		"updateByMold":           updateByMold,
		"increaseCapacityByMold": increaseCapacityByMold,
	}
}

func (p FormationNamespaceDistributions) Pointer() *FormationNamespaceDistributions {
	return &p
}

func CastFormationNamespaceDistributionses(data []interface{}) []FormationNamespaceDistributions {
	v := make([]FormationNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceDistributionsesFromDict(data []FormationNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespace struct {
	NamespaceId   *string                          `json:"namespaceId"`
	Year          *int32                           `json:"year"`
	Month         *int32                           `json:"month"`
	Day           *int32                           `json:"day"`
	NamespaceName *string                          `json:"namespaceName"`
	Statistics    *FormationNamespaceStatistics    `json:"statistics"`
	Distributions *FormationNamespaceDistributions `json:"distributions"`
	Molds         []FormationMold                  `json:"molds"`
}

func (p *FormationNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespace{}
	} else {
		*p = FormationNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["molds"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Molds)
		}
	}
	return nil
}

func NewFormationNamespaceFromJson(data string) FormationNamespace {
	req := FormationNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceFromDict(data map[string]interface{}) FormationNamespace {
	return FormationNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewFormationNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewFormationNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		Molds:         CastFormationMolds(core.CastArray(data["molds"])),
	}
}

func (p FormationNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var molds []interface{}
	if p.Molds != nil {
		molds = CastFormationMoldsFromDict(
			p.Molds,
		)
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
		"molds":         molds,
	}
}

func (p FormationNamespace) Pointer() *FormationNamespace {
	return &p
}

func CastFormationNamespaces(data []interface{}) []FormationNamespace {
	v := make([]FormationNamespace, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespacesFromDict(data []FormationNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceStatistics struct {
	Accept      *int64 `json:"accept"`
	Reject      *int64 `json:"reject"`
	SendRequest *int64 `json:"sendRequest"`
	Follow      *int64 `json:"follow"`
}

func (p *FriendNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceStatistics{}
	} else {
		*p = FriendNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["accept"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Accept)
		}
		if v, ok := d["reject"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Reject)
		}
		if v, ok := d["sendRequest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SendRequest)
		}
		if v, ok := d["follow"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Follow)
		}
	}
	return nil
}

func NewFriendNamespaceStatisticsFromJson(data string) FriendNamespaceStatistics {
	req := FriendNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceStatisticsFromDict(data map[string]interface{}) FriendNamespaceStatistics {
	return FriendNamespaceStatistics{
		Accept:      core.CastInt64(data["accept"]),
		Reject:      core.CastInt64(data["reject"]),
		SendRequest: core.CastInt64(data["sendRequest"]),
		Follow:      core.CastInt64(data["follow"]),
	}
}

func (p FriendNamespaceStatistics) ToDict() map[string]interface{} {

	var accept *int64
	if p.Accept != nil {
		accept = p.Accept
	}
	var reject *int64
	if p.Reject != nil {
		reject = p.Reject
	}
	var sendRequest *int64
	if p.SendRequest != nil {
		sendRequest = p.SendRequest
	}
	var follow *int64
	if p.Follow != nil {
		follow = p.Follow
	}
	return map[string]interface{}{
		"accept":      accept,
		"reject":      reject,
		"sendRequest": sendRequest,
		"follow":      follow,
	}
}

func (p FriendNamespaceStatistics) Pointer() *FriendNamespaceStatistics {
	return &p
}

func CastFriendNamespaceStatisticses(data []interface{}) []FriendNamespaceStatistics {
	v := make([]FriendNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceStatisticsesFromDict(data []FriendNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceAcceptByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FriendNamespaceAcceptByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceAcceptByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceAcceptByUserDistributionStatistics{}
	} else {
		*p = FriendNamespaceAcceptByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFriendNamespaceAcceptByUserDistributionStatisticsFromJson(data string) FriendNamespaceAcceptByUserDistributionStatistics {
	req := FriendNamespaceAcceptByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceAcceptByUserDistributionStatisticsFromDict(data map[string]interface{}) FriendNamespaceAcceptByUserDistributionStatistics {
	return FriendNamespaceAcceptByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FriendNamespaceAcceptByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FriendNamespaceAcceptByUserDistributionStatistics) Pointer() *FriendNamespaceAcceptByUserDistributionStatistics {
	return &p
}

func CastFriendNamespaceAcceptByUserDistributionStatisticses(data []interface{}) []FriendNamespaceAcceptByUserDistributionStatistics {
	v := make([]FriendNamespaceAcceptByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceAcceptByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceAcceptByUserDistributionStatisticsesFromDict(data []FriendNamespaceAcceptByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceAcceptByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FriendNamespaceAcceptByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceAcceptByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceAcceptByUserDistributionSegment{}
	} else {
		*p = FriendNamespaceAcceptByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFriendNamespaceAcceptByUserDistributionSegmentFromJson(data string) FriendNamespaceAcceptByUserDistributionSegment {
	req := FriendNamespaceAcceptByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceAcceptByUserDistributionSegmentFromDict(data map[string]interface{}) FriendNamespaceAcceptByUserDistributionSegment {
	return FriendNamespaceAcceptByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p FriendNamespaceAcceptByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p FriendNamespaceAcceptByUserDistributionSegment) Pointer() *FriendNamespaceAcceptByUserDistributionSegment {
	return &p
}

func CastFriendNamespaceAcceptByUserDistributionSegments(data []interface{}) []FriendNamespaceAcceptByUserDistributionSegment {
	v := make([]FriendNamespaceAcceptByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceAcceptByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceAcceptByUserDistributionSegmentsFromDict(data []FriendNamespaceAcceptByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceAcceptByUserDistribution struct {
	Statistics   *FriendNamespaceAcceptByUserDistributionStatistics `json:"statistics"`
	Distribution []FriendNamespaceAcceptByUserDistributionSegment   `json:"distribution"`
}

func (p *FriendNamespaceAcceptByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceAcceptByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceAcceptByUserDistribution{}
	} else {
		*p = FriendNamespaceAcceptByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFriendNamespaceAcceptByUserDistributionFromJson(data string) FriendNamespaceAcceptByUserDistribution {
	req := FriendNamespaceAcceptByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceAcceptByUserDistributionFromDict(data map[string]interface{}) FriendNamespaceAcceptByUserDistribution {
	return FriendNamespaceAcceptByUserDistribution{
		Statistics:   NewFriendNamespaceAcceptByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFriendNamespaceAcceptByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FriendNamespaceAcceptByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFriendNamespaceAcceptByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FriendNamespaceAcceptByUserDistribution) Pointer() *FriendNamespaceAcceptByUserDistribution {
	return &p
}

func CastFriendNamespaceAcceptByUserDistributions(data []interface{}) []FriendNamespaceAcceptByUserDistribution {
	v := make([]FriendNamespaceAcceptByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceAcceptByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceAcceptByUserDistributionsFromDict(data []FriendNamespaceAcceptByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceRejectByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FriendNamespaceRejectByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceRejectByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceRejectByUserDistributionStatistics{}
	} else {
		*p = FriendNamespaceRejectByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFriendNamespaceRejectByUserDistributionStatisticsFromJson(data string) FriendNamespaceRejectByUserDistributionStatistics {
	req := FriendNamespaceRejectByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceRejectByUserDistributionStatisticsFromDict(data map[string]interface{}) FriendNamespaceRejectByUserDistributionStatistics {
	return FriendNamespaceRejectByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FriendNamespaceRejectByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FriendNamespaceRejectByUserDistributionStatistics) Pointer() *FriendNamespaceRejectByUserDistributionStatistics {
	return &p
}

func CastFriendNamespaceRejectByUserDistributionStatisticses(data []interface{}) []FriendNamespaceRejectByUserDistributionStatistics {
	v := make([]FriendNamespaceRejectByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceRejectByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceRejectByUserDistributionStatisticsesFromDict(data []FriendNamespaceRejectByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceRejectByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FriendNamespaceRejectByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceRejectByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceRejectByUserDistributionSegment{}
	} else {
		*p = FriendNamespaceRejectByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFriendNamespaceRejectByUserDistributionSegmentFromJson(data string) FriendNamespaceRejectByUserDistributionSegment {
	req := FriendNamespaceRejectByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceRejectByUserDistributionSegmentFromDict(data map[string]interface{}) FriendNamespaceRejectByUserDistributionSegment {
	return FriendNamespaceRejectByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p FriendNamespaceRejectByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p FriendNamespaceRejectByUserDistributionSegment) Pointer() *FriendNamespaceRejectByUserDistributionSegment {
	return &p
}

func CastFriendNamespaceRejectByUserDistributionSegments(data []interface{}) []FriendNamespaceRejectByUserDistributionSegment {
	v := make([]FriendNamespaceRejectByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceRejectByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceRejectByUserDistributionSegmentsFromDict(data []FriendNamespaceRejectByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceRejectByUserDistribution struct {
	Statistics   *FriendNamespaceRejectByUserDistributionStatistics `json:"statistics"`
	Distribution []FriendNamespaceRejectByUserDistributionSegment   `json:"distribution"`
}

func (p *FriendNamespaceRejectByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceRejectByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceRejectByUserDistribution{}
	} else {
		*p = FriendNamespaceRejectByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFriendNamespaceRejectByUserDistributionFromJson(data string) FriendNamespaceRejectByUserDistribution {
	req := FriendNamespaceRejectByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceRejectByUserDistributionFromDict(data map[string]interface{}) FriendNamespaceRejectByUserDistribution {
	return FriendNamespaceRejectByUserDistribution{
		Statistics:   NewFriendNamespaceRejectByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFriendNamespaceRejectByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FriendNamespaceRejectByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFriendNamespaceRejectByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FriendNamespaceRejectByUserDistribution) Pointer() *FriendNamespaceRejectByUserDistribution {
	return &p
}

func CastFriendNamespaceRejectByUserDistributions(data []interface{}) []FriendNamespaceRejectByUserDistribution {
	v := make([]FriendNamespaceRejectByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceRejectByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceRejectByUserDistributionsFromDict(data []FriendNamespaceRejectByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceSendRequestByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FriendNamespaceSendRequestByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceSendRequestByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceSendRequestByUserDistributionStatistics{}
	} else {
		*p = FriendNamespaceSendRequestByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFriendNamespaceSendRequestByUserDistributionStatisticsFromJson(data string) FriendNamespaceSendRequestByUserDistributionStatistics {
	req := FriendNamespaceSendRequestByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceSendRequestByUserDistributionStatisticsFromDict(data map[string]interface{}) FriendNamespaceSendRequestByUserDistributionStatistics {
	return FriendNamespaceSendRequestByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FriendNamespaceSendRequestByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FriendNamespaceSendRequestByUserDistributionStatistics) Pointer() *FriendNamespaceSendRequestByUserDistributionStatistics {
	return &p
}

func CastFriendNamespaceSendRequestByUserDistributionStatisticses(data []interface{}) []FriendNamespaceSendRequestByUserDistributionStatistics {
	v := make([]FriendNamespaceSendRequestByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceSendRequestByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceSendRequestByUserDistributionStatisticsesFromDict(data []FriendNamespaceSendRequestByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceSendRequestByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FriendNamespaceSendRequestByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceSendRequestByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceSendRequestByUserDistributionSegment{}
	} else {
		*p = FriendNamespaceSendRequestByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFriendNamespaceSendRequestByUserDistributionSegmentFromJson(data string) FriendNamespaceSendRequestByUserDistributionSegment {
	req := FriendNamespaceSendRequestByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceSendRequestByUserDistributionSegmentFromDict(data map[string]interface{}) FriendNamespaceSendRequestByUserDistributionSegment {
	return FriendNamespaceSendRequestByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p FriendNamespaceSendRequestByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p FriendNamespaceSendRequestByUserDistributionSegment) Pointer() *FriendNamespaceSendRequestByUserDistributionSegment {
	return &p
}

func CastFriendNamespaceSendRequestByUserDistributionSegments(data []interface{}) []FriendNamespaceSendRequestByUserDistributionSegment {
	v := make([]FriendNamespaceSendRequestByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceSendRequestByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceSendRequestByUserDistributionSegmentsFromDict(data []FriendNamespaceSendRequestByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceSendRequestByUserDistribution struct {
	Statistics   *FriendNamespaceSendRequestByUserDistributionStatistics `json:"statistics"`
	Distribution []FriendNamespaceSendRequestByUserDistributionSegment   `json:"distribution"`
}

func (p *FriendNamespaceSendRequestByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceSendRequestByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceSendRequestByUserDistribution{}
	} else {
		*p = FriendNamespaceSendRequestByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFriendNamespaceSendRequestByUserDistributionFromJson(data string) FriendNamespaceSendRequestByUserDistribution {
	req := FriendNamespaceSendRequestByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceSendRequestByUserDistributionFromDict(data map[string]interface{}) FriendNamespaceSendRequestByUserDistribution {
	return FriendNamespaceSendRequestByUserDistribution{
		Statistics:   NewFriendNamespaceSendRequestByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFriendNamespaceSendRequestByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FriendNamespaceSendRequestByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFriendNamespaceSendRequestByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FriendNamespaceSendRequestByUserDistribution) Pointer() *FriendNamespaceSendRequestByUserDistribution {
	return &p
}

func CastFriendNamespaceSendRequestByUserDistributions(data []interface{}) []FriendNamespaceSendRequestByUserDistribution {
	v := make([]FriendNamespaceSendRequestByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceSendRequestByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceSendRequestByUserDistributionsFromDict(data []FriendNamespaceSendRequestByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceNewFollowByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FriendNamespaceNewFollowByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceNewFollowByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceNewFollowByUserDistributionStatistics{}
	} else {
		*p = FriendNamespaceNewFollowByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFriendNamespaceNewFollowByUserDistributionStatisticsFromJson(data string) FriendNamespaceNewFollowByUserDistributionStatistics {
	req := FriendNamespaceNewFollowByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceNewFollowByUserDistributionStatisticsFromDict(data map[string]interface{}) FriendNamespaceNewFollowByUserDistributionStatistics {
	return FriendNamespaceNewFollowByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p FriendNamespaceNewFollowByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p FriendNamespaceNewFollowByUserDistributionStatistics) Pointer() *FriendNamespaceNewFollowByUserDistributionStatistics {
	return &p
}

func CastFriendNamespaceNewFollowByUserDistributionStatisticses(data []interface{}) []FriendNamespaceNewFollowByUserDistributionStatistics {
	v := make([]FriendNamespaceNewFollowByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceNewFollowByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceNewFollowByUserDistributionStatisticsesFromDict(data []FriendNamespaceNewFollowByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceNewFollowByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FriendNamespaceNewFollowByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceNewFollowByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceNewFollowByUserDistributionSegment{}
	} else {
		*p = FriendNamespaceNewFollowByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFriendNamespaceNewFollowByUserDistributionSegmentFromJson(data string) FriendNamespaceNewFollowByUserDistributionSegment {
	req := FriendNamespaceNewFollowByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceNewFollowByUserDistributionSegmentFromDict(data map[string]interface{}) FriendNamespaceNewFollowByUserDistributionSegment {
	return FriendNamespaceNewFollowByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p FriendNamespaceNewFollowByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p FriendNamespaceNewFollowByUserDistributionSegment) Pointer() *FriendNamespaceNewFollowByUserDistributionSegment {
	return &p
}

func CastFriendNamespaceNewFollowByUserDistributionSegments(data []interface{}) []FriendNamespaceNewFollowByUserDistributionSegment {
	v := make([]FriendNamespaceNewFollowByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceNewFollowByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceNewFollowByUserDistributionSegmentsFromDict(data []FriendNamespaceNewFollowByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceNewFollowByUserDistribution struct {
	Statistics   *FriendNamespaceNewFollowByUserDistributionStatistics `json:"statistics"`
	Distribution []FriendNamespaceNewFollowByUserDistributionSegment   `json:"distribution"`
}

func (p *FriendNamespaceNewFollowByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceNewFollowByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceNewFollowByUserDistribution{}
	} else {
		*p = FriendNamespaceNewFollowByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFriendNamespaceNewFollowByUserDistributionFromJson(data string) FriendNamespaceNewFollowByUserDistribution {
	req := FriendNamespaceNewFollowByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceNewFollowByUserDistributionFromDict(data map[string]interface{}) FriendNamespaceNewFollowByUserDistribution {
	return FriendNamespaceNewFollowByUserDistribution{
		Statistics:   NewFriendNamespaceNewFollowByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastFriendNamespaceNewFollowByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p FriendNamespaceNewFollowByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastFriendNamespaceNewFollowByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p FriendNamespaceNewFollowByUserDistribution) Pointer() *FriendNamespaceNewFollowByUserDistribution {
	return &p
}

func CastFriendNamespaceNewFollowByUserDistributions(data []interface{}) []FriendNamespaceNewFollowByUserDistribution {
	v := make([]FriendNamespaceNewFollowByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceNewFollowByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceNewFollowByUserDistributionsFromDict(data []FriendNamespaceNewFollowByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceDistributions struct {
	AcceptByUser      *FriendNamespaceAcceptByUserDistribution      `json:"acceptByUser"`
	RejectByUser      *FriendNamespaceRejectByUserDistribution      `json:"rejectByUser"`
	SendRequestByUser *FriendNamespaceSendRequestByUserDistribution `json:"sendRequestByUser"`
	NewFollowByUser   *FriendNamespaceNewFollowByUserDistribution   `json:"newFollowByUser"`
}

func (p *FriendNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceDistributions{}
	} else {
		*p = FriendNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["acceptByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AcceptByUser)
		}
		if v, ok := d["rejectByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RejectByUser)
		}
		if v, ok := d["sendRequestByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SendRequestByUser)
		}
		if v, ok := d["newFollowByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.NewFollowByUser)
		}
	}
	return nil
}

func NewFriendNamespaceDistributionsFromJson(data string) FriendNamespaceDistributions {
	req := FriendNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceDistributionsFromDict(data map[string]interface{}) FriendNamespaceDistributions {
	return FriendNamespaceDistributions{
		AcceptByUser:      NewFriendNamespaceAcceptByUserDistributionFromDict(core.CastMap(data["acceptByUser"])).Pointer(),
		RejectByUser:      NewFriendNamespaceRejectByUserDistributionFromDict(core.CastMap(data["rejectByUser"])).Pointer(),
		SendRequestByUser: NewFriendNamespaceSendRequestByUserDistributionFromDict(core.CastMap(data["sendRequestByUser"])).Pointer(),
		NewFollowByUser:   NewFriendNamespaceNewFollowByUserDistributionFromDict(core.CastMap(data["newFollowByUser"])).Pointer(),
	}
}

func (p FriendNamespaceDistributions) ToDict() map[string]interface{} {

	var acceptByUser map[string]interface{}
	if p.AcceptByUser != nil {
		acceptByUser = p.AcceptByUser.ToDict()
	}
	var rejectByUser map[string]interface{}
	if p.RejectByUser != nil {
		rejectByUser = p.RejectByUser.ToDict()
	}
	var sendRequestByUser map[string]interface{}
	if p.SendRequestByUser != nil {
		sendRequestByUser = p.SendRequestByUser.ToDict()
	}
	var newFollowByUser map[string]interface{}
	if p.NewFollowByUser != nil {
		newFollowByUser = p.NewFollowByUser.ToDict()
	}
	return map[string]interface{}{
		"acceptByUser":      acceptByUser,
		"rejectByUser":      rejectByUser,
		"sendRequestByUser": sendRequestByUser,
		"newFollowByUser":   newFollowByUser,
	}
}

func (p FriendNamespaceDistributions) Pointer() *FriendNamespaceDistributions {
	return &p
}

func CastFriendNamespaceDistributionses(data []interface{}) []FriendNamespaceDistributions {
	v := make([]FriendNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceDistributionsesFromDict(data []FriendNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespace struct {
	NamespaceId   *string                       `json:"namespaceId"`
	Year          *int32                        `json:"year"`
	Month         *int32                        `json:"month"`
	Day           *int32                        `json:"day"`
	NamespaceName *string                       `json:"namespaceName"`
	Statistics    *FriendNamespaceStatistics    `json:"statistics"`
	Distributions *FriendNamespaceDistributions `json:"distributions"`
}

func (p *FriendNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespace{}
	} else {
		*p = FriendNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewFriendNamespaceFromJson(data string) FriendNamespace {
	req := FriendNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceFromDict(data map[string]interface{}) FriendNamespace {
	return FriendNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewFriendNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewFriendNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p FriendNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p FriendNamespace) Pointer() *FriendNamespace {
	return &p
}

func CastFriendNamespaces(data []interface{}) []FriendNamespace {
	v := make([]FriendNamespace, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespacesFromDict(data []FriendNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceStatistics struct {
	Sent     *int64   `json:"sent"`
	Open     *int64   `json:"open"`
	OpenRate *float32 `json:"openRate"`
}

func (p *InboxNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceStatistics{}
	} else {
		*p = InboxNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["sent"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sent)
		}
		if v, ok := d["open"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Open)
		}
		if v, ok := d["openRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.OpenRate)
		}
	}
	return nil
}

func NewInboxNamespaceStatisticsFromJson(data string) InboxNamespaceStatistics {
	req := InboxNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceStatisticsFromDict(data map[string]interface{}) InboxNamespaceStatistics {
	return InboxNamespaceStatistics{
		Sent:     core.CastInt64(data["sent"]),
		Open:     core.CastInt64(data["open"]),
		OpenRate: core.CastFloat32(data["openRate"]),
	}
}

func (p InboxNamespaceStatistics) ToDict() map[string]interface{} {

	var sent *int64
	if p.Sent != nil {
		sent = p.Sent
	}
	var open *int64
	if p.Open != nil {
		open = p.Open
	}
	var openRate *float32
	if p.OpenRate != nil {
		openRate = p.OpenRate
	}
	return map[string]interface{}{
		"sent":     sent,
		"open":     open,
		"openRate": openRate,
	}
}

func (p InboxNamespaceStatistics) Pointer() *InboxNamespaceStatistics {
	return &p
}

func CastInboxNamespaceStatisticses(data []interface{}) []InboxNamespaceStatistics {
	v := make([]InboxNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceStatisticsesFromDict(data []InboxNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceSendByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InboxNamespaceSendByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceSendByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceSendByUserDistributionStatistics{}
	} else {
		*p = InboxNamespaceSendByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInboxNamespaceSendByUserDistributionStatisticsFromJson(data string) InboxNamespaceSendByUserDistributionStatistics {
	req := InboxNamespaceSendByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceSendByUserDistributionStatisticsFromDict(data map[string]interface{}) InboxNamespaceSendByUserDistributionStatistics {
	return InboxNamespaceSendByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InboxNamespaceSendByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InboxNamespaceSendByUserDistributionStatistics) Pointer() *InboxNamespaceSendByUserDistributionStatistics {
	return &p
}

func CastInboxNamespaceSendByUserDistributionStatisticses(data []interface{}) []InboxNamespaceSendByUserDistributionStatistics {
	v := make([]InboxNamespaceSendByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceSendByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceSendByUserDistributionStatisticsesFromDict(data []InboxNamespaceSendByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceSendByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *InboxNamespaceSendByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceSendByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceSendByUserDistributionSegment{}
	} else {
		*p = InboxNamespaceSendByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInboxNamespaceSendByUserDistributionSegmentFromJson(data string) InboxNamespaceSendByUserDistributionSegment {
	req := InboxNamespaceSendByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceSendByUserDistributionSegmentFromDict(data map[string]interface{}) InboxNamespaceSendByUserDistributionSegment {
	return InboxNamespaceSendByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p InboxNamespaceSendByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p InboxNamespaceSendByUserDistributionSegment) Pointer() *InboxNamespaceSendByUserDistributionSegment {
	return &p
}

func CastInboxNamespaceSendByUserDistributionSegments(data []interface{}) []InboxNamespaceSendByUserDistributionSegment {
	v := make([]InboxNamespaceSendByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceSendByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceSendByUserDistributionSegmentsFromDict(data []InboxNamespaceSendByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceSendByUserDistribution struct {
	Statistics   *InboxNamespaceSendByUserDistributionStatistics `json:"statistics"`
	Distribution []InboxNamespaceSendByUserDistributionSegment   `json:"distribution"`
}

func (p *InboxNamespaceSendByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceSendByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceSendByUserDistribution{}
	} else {
		*p = InboxNamespaceSendByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInboxNamespaceSendByUserDistributionFromJson(data string) InboxNamespaceSendByUserDistribution {
	req := InboxNamespaceSendByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceSendByUserDistributionFromDict(data map[string]interface{}) InboxNamespaceSendByUserDistribution {
	return InboxNamespaceSendByUserDistribution{
		Statistics:   NewInboxNamespaceSendByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInboxNamespaceSendByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InboxNamespaceSendByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInboxNamespaceSendByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InboxNamespaceSendByUserDistribution) Pointer() *InboxNamespaceSendByUserDistribution {
	return &p
}

func CastInboxNamespaceSendByUserDistributions(data []interface{}) []InboxNamespaceSendByUserDistribution {
	v := make([]InboxNamespaceSendByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceSendByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceSendByUserDistributionsFromDict(data []InboxNamespaceSendByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceReadElapsedMinutesDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InboxNamespaceReadElapsedMinutesDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceReadElapsedMinutesDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceReadElapsedMinutesDistributionStatistics{}
	} else {
		*p = InboxNamespaceReadElapsedMinutesDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInboxNamespaceReadElapsedMinutesDistributionStatisticsFromJson(data string) InboxNamespaceReadElapsedMinutesDistributionStatistics {
	req := InboxNamespaceReadElapsedMinutesDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceReadElapsedMinutesDistributionStatisticsFromDict(data map[string]interface{}) InboxNamespaceReadElapsedMinutesDistributionStatistics {
	return InboxNamespaceReadElapsedMinutesDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InboxNamespaceReadElapsedMinutesDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InboxNamespaceReadElapsedMinutesDistributionStatistics) Pointer() *InboxNamespaceReadElapsedMinutesDistributionStatistics {
	return &p
}

func CastInboxNamespaceReadElapsedMinutesDistributionStatisticses(data []interface{}) []InboxNamespaceReadElapsedMinutesDistributionStatistics {
	v := make([]InboxNamespaceReadElapsedMinutesDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceReadElapsedMinutesDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceReadElapsedMinutesDistributionStatisticsesFromDict(data []InboxNamespaceReadElapsedMinutesDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceReadElapsedMinutesDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *InboxNamespaceReadElapsedMinutesDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceReadElapsedMinutesDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceReadElapsedMinutesDistributionSegment{}
	} else {
		*p = InboxNamespaceReadElapsedMinutesDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInboxNamespaceReadElapsedMinutesDistributionSegmentFromJson(data string) InboxNamespaceReadElapsedMinutesDistributionSegment {
	req := InboxNamespaceReadElapsedMinutesDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceReadElapsedMinutesDistributionSegmentFromDict(data map[string]interface{}) InboxNamespaceReadElapsedMinutesDistributionSegment {
	return InboxNamespaceReadElapsedMinutesDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p InboxNamespaceReadElapsedMinutesDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p InboxNamespaceReadElapsedMinutesDistributionSegment) Pointer() *InboxNamespaceReadElapsedMinutesDistributionSegment {
	return &p
}

func CastInboxNamespaceReadElapsedMinutesDistributionSegments(data []interface{}) []InboxNamespaceReadElapsedMinutesDistributionSegment {
	v := make([]InboxNamespaceReadElapsedMinutesDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceReadElapsedMinutesDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceReadElapsedMinutesDistributionSegmentsFromDict(data []InboxNamespaceReadElapsedMinutesDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceReadElapsedMinutesDistribution struct {
	Statistics   *InboxNamespaceReadElapsedMinutesDistributionStatistics `json:"statistics"`
	Distribution []InboxNamespaceReadElapsedMinutesDistributionSegment   `json:"distribution"`
}

func (p *InboxNamespaceReadElapsedMinutesDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceReadElapsedMinutesDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceReadElapsedMinutesDistribution{}
	} else {
		*p = InboxNamespaceReadElapsedMinutesDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInboxNamespaceReadElapsedMinutesDistributionFromJson(data string) InboxNamespaceReadElapsedMinutesDistribution {
	req := InboxNamespaceReadElapsedMinutesDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceReadElapsedMinutesDistributionFromDict(data map[string]interface{}) InboxNamespaceReadElapsedMinutesDistribution {
	return InboxNamespaceReadElapsedMinutesDistribution{
		Statistics:   NewInboxNamespaceReadElapsedMinutesDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInboxNamespaceReadElapsedMinutesDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InboxNamespaceReadElapsedMinutesDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInboxNamespaceReadElapsedMinutesDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InboxNamespaceReadElapsedMinutesDistribution) Pointer() *InboxNamespaceReadElapsedMinutesDistribution {
	return &p
}

func CastInboxNamespaceReadElapsedMinutesDistributions(data []interface{}) []InboxNamespaceReadElapsedMinutesDistribution {
	v := make([]InboxNamespaceReadElapsedMinutesDistribution, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceReadElapsedMinutesDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceReadElapsedMinutesDistributionsFromDict(data []InboxNamespaceReadElapsedMinutesDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceDistributions struct {
	SendByUser         *InboxNamespaceSendByUserDistribution         `json:"sendByUser"`
	ReadElapsedMinutes *InboxNamespaceReadElapsedMinutesDistribution `json:"readElapsedMinutes"`
}

func (p *InboxNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceDistributions{}
	} else {
		*p = InboxNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["sendByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SendByUser)
		}
		if v, ok := d["readElapsedMinutes"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ReadElapsedMinutes)
		}
	}
	return nil
}

func NewInboxNamespaceDistributionsFromJson(data string) InboxNamespaceDistributions {
	req := InboxNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceDistributionsFromDict(data map[string]interface{}) InboxNamespaceDistributions {
	return InboxNamespaceDistributions{
		SendByUser:         NewInboxNamespaceSendByUserDistributionFromDict(core.CastMap(data["sendByUser"])).Pointer(),
		ReadElapsedMinutes: NewInboxNamespaceReadElapsedMinutesDistributionFromDict(core.CastMap(data["readElapsedMinutes"])).Pointer(),
	}
}

func (p InboxNamespaceDistributions) ToDict() map[string]interface{} {

	var sendByUser map[string]interface{}
	if p.SendByUser != nil {
		sendByUser = p.SendByUser.ToDict()
	}
	var readElapsedMinutes map[string]interface{}
	if p.ReadElapsedMinutes != nil {
		readElapsedMinutes = p.ReadElapsedMinutes.ToDict()
	}
	return map[string]interface{}{
		"sendByUser":         sendByUser,
		"readElapsedMinutes": readElapsedMinutes,
	}
}

func (p InboxNamespaceDistributions) Pointer() *InboxNamespaceDistributions {
	return &p
}

func CastInboxNamespaceDistributionses(data []interface{}) []InboxNamespaceDistributions {
	v := make([]InboxNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceDistributionsesFromDict(data []InboxNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespace struct {
	NamespaceId   *string                      `json:"namespaceId"`
	Year          *int32                       `json:"year"`
	Month         *int32                       `json:"month"`
	Day           *int32                       `json:"day"`
	NamespaceName *string                      `json:"namespaceName"`
	Statistics    *InboxNamespaceStatistics    `json:"statistics"`
	Distributions *InboxNamespaceDistributions `json:"distributions"`
}

func (p *InboxNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespace{}
	} else {
		*p = InboxNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewInboxNamespaceFromJson(data string) InboxNamespace {
	req := InboxNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceFromDict(data map[string]interface{}) InboxNamespace {
	return InboxNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewInboxNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewInboxNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p InboxNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p InboxNamespace) Pointer() *InboxNamespace {
	return &p
}

func CastInboxNamespaces(data []interface{}) []InboxNamespace {
	v := make([]InboxNamespace, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespacesFromDict(data []InboxNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSetStatistics struct {
	Acquired       *int64   `json:"acquired"`
	AcquiredAmount *int64   `json:"acquiredAmount"`
	Consumed       *int64   `json:"consumed"`
	ConsumedAmount *int64   `json:"consumedAmount"`
	ConsumedRate   *float32 `json:"consumedRate"`
}

func (p *InventoryItemSetStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSetStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSetStatistics{}
	} else {
		*p = InventoryItemSetStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["acquired"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Acquired)
		}
		if v, ok := d["acquiredAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AcquiredAmount)
		}
		if v, ok := d["consumed"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consumed)
		}
		if v, ok := d["consumedAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ConsumedAmount)
		}
		if v, ok := d["consumedRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ConsumedRate)
		}
	}
	return nil
}

func NewInventoryItemSetStatisticsFromJson(data string) InventoryItemSetStatistics {
	req := InventoryItemSetStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetStatisticsFromDict(data map[string]interface{}) InventoryItemSetStatistics {
	return InventoryItemSetStatistics{
		Acquired:       core.CastInt64(data["acquired"]),
		AcquiredAmount: core.CastInt64(data["acquiredAmount"]),
		Consumed:       core.CastInt64(data["consumed"]),
		ConsumedAmount: core.CastInt64(data["consumedAmount"]),
		ConsumedRate:   core.CastFloat32(data["consumedRate"]),
	}
}

func (p InventoryItemSetStatistics) ToDict() map[string]interface{} {

	var acquired *int64
	if p.Acquired != nil {
		acquired = p.Acquired
	}
	var acquiredAmount *int64
	if p.AcquiredAmount != nil {
		acquiredAmount = p.AcquiredAmount
	}
	var consumed *int64
	if p.Consumed != nil {
		consumed = p.Consumed
	}
	var consumedAmount *int64
	if p.ConsumedAmount != nil {
		consumedAmount = p.ConsumedAmount
	}
	var consumedRate *float32
	if p.ConsumedRate != nil {
		consumedRate = p.ConsumedRate
	}
	return map[string]interface{}{
		"acquired":       acquired,
		"acquiredAmount": acquiredAmount,
		"consumed":       consumed,
		"consumedAmount": consumedAmount,
		"consumedRate":   consumedRate,
	}
}

func (p InventoryItemSetStatistics) Pointer() *InventoryItemSetStatistics {
	return &p
}

func CastInventoryItemSetStatisticses(data []interface{}) []InventoryItemSetStatistics {
	v := make([]InventoryItemSetStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetStatisticsesFromDict(data []InventoryItemSetStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSetCountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryItemSetCountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSetCountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSetCountDistributionStatistics{}
	} else {
		*p = InventoryItemSetCountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryItemSetCountDistributionStatisticsFromJson(data string) InventoryItemSetCountDistributionStatistics {
	req := InventoryItemSetCountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetCountDistributionStatisticsFromDict(data map[string]interface{}) InventoryItemSetCountDistributionStatistics {
	return InventoryItemSetCountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryItemSetCountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryItemSetCountDistributionStatistics) Pointer() *InventoryItemSetCountDistributionStatistics {
	return &p
}

func CastInventoryItemSetCountDistributionStatisticses(data []interface{}) []InventoryItemSetCountDistributionStatistics {
	v := make([]InventoryItemSetCountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetCountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetCountDistributionStatisticsesFromDict(data []InventoryItemSetCountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSetCountDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *InventoryItemSetCountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSetCountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSetCountDistributionSegment{}
	} else {
		*p = InventoryItemSetCountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryItemSetCountDistributionSegmentFromJson(data string) InventoryItemSetCountDistributionSegment {
	req := InventoryItemSetCountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetCountDistributionSegmentFromDict(data map[string]interface{}) InventoryItemSetCountDistributionSegment {
	return InventoryItemSetCountDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p InventoryItemSetCountDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p InventoryItemSetCountDistributionSegment) Pointer() *InventoryItemSetCountDistributionSegment {
	return &p
}

func CastInventoryItemSetCountDistributionSegments(data []interface{}) []InventoryItemSetCountDistributionSegment {
	v := make([]InventoryItemSetCountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetCountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetCountDistributionSegmentsFromDict(data []InventoryItemSetCountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSetCountDistribution struct {
	Statistics   *InventoryItemSetCountDistributionStatistics `json:"statistics"`
	Distribution []InventoryItemSetCountDistributionSegment   `json:"distribution"`
}

func (p *InventoryItemSetCountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSetCountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSetCountDistribution{}
	} else {
		*p = InventoryItemSetCountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryItemSetCountDistributionFromJson(data string) InventoryItemSetCountDistribution {
	req := InventoryItemSetCountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetCountDistributionFromDict(data map[string]interface{}) InventoryItemSetCountDistribution {
	return InventoryItemSetCountDistribution{
		Statistics:   NewInventoryItemSetCountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryItemSetCountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryItemSetCountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryItemSetCountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryItemSetCountDistribution) Pointer() *InventoryItemSetCountDistribution {
	return &p
}

func CastInventoryItemSetCountDistributions(data []interface{}) []InventoryItemSetCountDistribution {
	v := make([]InventoryItemSetCountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetCountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetCountDistributionsFromDict(data []InventoryItemSetCountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSetDistributions struct {
	Count *InventoryItemSetCountDistribution `json:"count"`
}

func (p *InventoryItemSetDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSetDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSetDistributions{}
	} else {
		*p = InventoryItemSetDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryItemSetDistributionsFromJson(data string) InventoryItemSetDistributions {
	req := InventoryItemSetDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetDistributionsFromDict(data map[string]interface{}) InventoryItemSetDistributions {
	return InventoryItemSetDistributions{
		Count: NewInventoryItemSetCountDistributionFromDict(core.CastMap(data["count"])).Pointer(),
	}
}

func (p InventoryItemSetDistributions) ToDict() map[string]interface{} {

	var count map[string]interface{}
	if p.Count != nil {
		count = p.Count.ToDict()
	}
	return map[string]interface{}{
		"count": count,
	}
}

func (p InventoryItemSetDistributions) Pointer() *InventoryItemSetDistributions {
	return &p
}

func CastInventoryItemSetDistributionses(data []interface{}) []InventoryItemSetDistributions {
	v := make([]InventoryItemSetDistributions, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetDistributionsesFromDict(data []InventoryItemSetDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSet struct {
	ItemSetId     *string                        `json:"itemSetId"`
	ItemName      *string                        `json:"itemName"`
	ItemSetName   *string                        `json:"itemSetName"`
	Statistics    *InventoryItemSetStatistics    `json:"statistics"`
	Distributions *InventoryItemSetDistributions `json:"distributions"`
}

func (p *InventoryItemSet) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSet{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSet{}
	} else {
		*p = InventoryItemSet{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["itemSetId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemSetId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemSetId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemSetId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemSetId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemSetId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemSetId)
				}
			}
		}
		if v, ok := d["itemName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemName)
				}
			}
		}
		if v, ok := d["itemSetName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemSetName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemSetName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemSetName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemSetName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemSetName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemSetName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewInventoryItemSetFromJson(data string) InventoryItemSet {
	req := InventoryItemSet{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetFromDict(data map[string]interface{}) InventoryItemSet {
	return InventoryItemSet{
		ItemSetId:     core.CastString(data["itemSetId"]),
		ItemName:      core.CastString(data["itemName"]),
		ItemSetName:   core.CastString(data["itemSetName"]),
		Statistics:    NewInventoryItemSetStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewInventoryItemSetDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p InventoryItemSet) ToDict() map[string]interface{} {

	var itemSetId *string
	if p.ItemSetId != nil {
		itemSetId = p.ItemSetId
	}
	var itemName *string
	if p.ItemName != nil {
		itemName = p.ItemName
	}
	var itemSetName *string
	if p.ItemSetName != nil {
		itemSetName = p.ItemSetName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"itemSetId":     itemSetId,
		"itemName":      itemName,
		"itemSetName":   itemSetName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p InventoryItemSet) Pointer() *InventoryItemSet {
	return &p
}

func CastInventoryItemSets(data []interface{}) []InventoryItemSet {
	v := make([]InventoryItemSet, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetsFromDict(data []InventoryItemSet) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryStatistics struct {
	Acquired               *int64 `json:"acquired"`
	Consume                *int64 `json:"consume"`
	IncreaseCapacity       *int64 `json:"increaseCapacity"`
	IncreaseCapacityAmount *int64 `json:"increaseCapacityAmount"`
}

func (p *InventoryInventoryStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryStatistics{}
	} else {
		*p = InventoryInventoryStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["acquired"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Acquired)
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["increaseCapacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacity)
		}
		if v, ok := d["increaseCapacityAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacityAmount)
		}
	}
	return nil
}

func NewInventoryInventoryStatisticsFromJson(data string) InventoryInventoryStatistics {
	req := InventoryInventoryStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryStatisticsFromDict(data map[string]interface{}) InventoryInventoryStatistics {
	return InventoryInventoryStatistics{
		Acquired:               core.CastInt64(data["acquired"]),
		Consume:                core.CastInt64(data["consume"]),
		IncreaseCapacity:       core.CastInt64(data["increaseCapacity"]),
		IncreaseCapacityAmount: core.CastInt64(data["increaseCapacityAmount"]),
	}
}

func (p InventoryInventoryStatistics) ToDict() map[string]interface{} {

	var acquired *int64
	if p.Acquired != nil {
		acquired = p.Acquired
	}
	var consume *int64
	if p.Consume != nil {
		consume = p.Consume
	}
	var increaseCapacity *int64
	if p.IncreaseCapacity != nil {
		increaseCapacity = p.IncreaseCapacity
	}
	var increaseCapacityAmount *int64
	if p.IncreaseCapacityAmount != nil {
		increaseCapacityAmount = p.IncreaseCapacityAmount
	}
	return map[string]interface{}{
		"acquired":               acquired,
		"consume":                consume,
		"increaseCapacity":       increaseCapacity,
		"increaseCapacityAmount": increaseCapacityAmount,
	}
}

func (p InventoryInventoryStatistics) Pointer() *InventoryInventoryStatistics {
	return &p
}

func CastInventoryInventoryStatisticses(data []interface{}) []InventoryInventoryStatistics {
	v := make([]InventoryInventoryStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryStatisticsesFromDict(data []InventoryInventoryStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryCapacityDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryInventoryCapacityDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryCapacityDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryCapacityDistributionStatistics{}
	} else {
		*p = InventoryInventoryCapacityDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryInventoryCapacityDistributionStatisticsFromJson(data string) InventoryInventoryCapacityDistributionStatistics {
	req := InventoryInventoryCapacityDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryCapacityDistributionStatisticsFromDict(data map[string]interface{}) InventoryInventoryCapacityDistributionStatistics {
	return InventoryInventoryCapacityDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryInventoryCapacityDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryInventoryCapacityDistributionStatistics) Pointer() *InventoryInventoryCapacityDistributionStatistics {
	return &p
}

func CastInventoryInventoryCapacityDistributionStatisticses(data []interface{}) []InventoryInventoryCapacityDistributionStatistics {
	v := make([]InventoryInventoryCapacityDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryCapacityDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryCapacityDistributionStatisticsesFromDict(data []InventoryInventoryCapacityDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryCapacityDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *InventoryInventoryCapacityDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryCapacityDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryCapacityDistributionSegment{}
	} else {
		*p = InventoryInventoryCapacityDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryInventoryCapacityDistributionSegmentFromJson(data string) InventoryInventoryCapacityDistributionSegment {
	req := InventoryInventoryCapacityDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryCapacityDistributionSegmentFromDict(data map[string]interface{}) InventoryInventoryCapacityDistributionSegment {
	return InventoryInventoryCapacityDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p InventoryInventoryCapacityDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p InventoryInventoryCapacityDistributionSegment) Pointer() *InventoryInventoryCapacityDistributionSegment {
	return &p
}

func CastInventoryInventoryCapacityDistributionSegments(data []interface{}) []InventoryInventoryCapacityDistributionSegment {
	v := make([]InventoryInventoryCapacityDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryCapacityDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryCapacityDistributionSegmentsFromDict(data []InventoryInventoryCapacityDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryCapacityDistribution struct {
	Statistics   *InventoryInventoryCapacityDistributionStatistics `json:"statistics"`
	Distribution []InventoryInventoryCapacityDistributionSegment   `json:"distribution"`
}

func (p *InventoryInventoryCapacityDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryCapacityDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryCapacityDistribution{}
	} else {
		*p = InventoryInventoryCapacityDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryInventoryCapacityDistributionFromJson(data string) InventoryInventoryCapacityDistribution {
	req := InventoryInventoryCapacityDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryCapacityDistributionFromDict(data map[string]interface{}) InventoryInventoryCapacityDistribution {
	return InventoryInventoryCapacityDistribution{
		Statistics:   NewInventoryInventoryCapacityDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryInventoryCapacityDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryInventoryCapacityDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryInventoryCapacityDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryInventoryCapacityDistribution) Pointer() *InventoryInventoryCapacityDistribution {
	return &p
}

func CastInventoryInventoryCapacityDistributions(data []interface{}) []InventoryInventoryCapacityDistribution {
	v := make([]InventoryInventoryCapacityDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryCapacityDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryCapacityDistributionsFromDict(data []InventoryInventoryCapacityDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryInventoryAcquireDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireDistributionStatistics{}
	} else {
		*p = InventoryInventoryAcquireDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireDistributionStatisticsFromJson(data string) InventoryInventoryAcquireDistributionStatistics {
	req := InventoryInventoryAcquireDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireDistributionStatisticsFromDict(data map[string]interface{}) InventoryInventoryAcquireDistributionStatistics {
	return InventoryInventoryAcquireDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryInventoryAcquireDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryInventoryAcquireDistributionStatistics) Pointer() *InventoryInventoryAcquireDistributionStatistics {
	return &p
}

func CastInventoryInventoryAcquireDistributionStatisticses(data []interface{}) []InventoryInventoryAcquireDistributionStatistics {
	v := make([]InventoryInventoryAcquireDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireDistributionStatisticsesFromDict(data []InventoryInventoryAcquireDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireDistributionSegment struct {
	ItemName *string `json:"itemName"`
	Count    *int64  `json:"count"`
}

func (p *InventoryInventoryAcquireDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireDistributionSegment{}
	} else {
		*p = InventoryInventoryAcquireDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["itemName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireDistributionSegmentFromJson(data string) InventoryInventoryAcquireDistributionSegment {
	req := InventoryInventoryAcquireDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireDistributionSegmentFromDict(data map[string]interface{}) InventoryInventoryAcquireDistributionSegment {
	return InventoryInventoryAcquireDistributionSegment{
		ItemName: core.CastString(data["itemName"]),
		Count:    core.CastInt64(data["count"]),
	}
}

func (p InventoryInventoryAcquireDistributionSegment) ToDict() map[string]interface{} {

	var itemName *string
	if p.ItemName != nil {
		itemName = p.ItemName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"itemName": itemName,
		"count":    count,
	}
}

func (p InventoryInventoryAcquireDistributionSegment) Pointer() *InventoryInventoryAcquireDistributionSegment {
	return &p
}

func CastInventoryInventoryAcquireDistributionSegments(data []interface{}) []InventoryInventoryAcquireDistributionSegment {
	v := make([]InventoryInventoryAcquireDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireDistributionSegmentsFromDict(data []InventoryInventoryAcquireDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireDistribution struct {
	Statistics   *InventoryInventoryAcquireDistributionStatistics `json:"statistics"`
	Distribution []InventoryInventoryAcquireDistributionSegment   `json:"distribution"`
}

func (p *InventoryInventoryAcquireDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireDistribution{}
	} else {
		*p = InventoryInventoryAcquireDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireDistributionFromJson(data string) InventoryInventoryAcquireDistribution {
	req := InventoryInventoryAcquireDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireDistributionFromDict(data map[string]interface{}) InventoryInventoryAcquireDistribution {
	return InventoryInventoryAcquireDistribution{
		Statistics:   NewInventoryInventoryAcquireDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryInventoryAcquireDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryInventoryAcquireDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryInventoryAcquireDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryInventoryAcquireDistribution) Pointer() *InventoryInventoryAcquireDistribution {
	return &p
}

func CastInventoryInventoryAcquireDistributions(data []interface{}) []InventoryInventoryAcquireDistribution {
	v := make([]InventoryInventoryAcquireDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireDistributionsFromDict(data []InventoryInventoryAcquireDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryInventoryAcquireAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireAmountDistributionStatistics{}
	} else {
		*p = InventoryInventoryAcquireAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireAmountDistributionStatisticsFromJson(data string) InventoryInventoryAcquireAmountDistributionStatistics {
	req := InventoryInventoryAcquireAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireAmountDistributionStatisticsFromDict(data map[string]interface{}) InventoryInventoryAcquireAmountDistributionStatistics {
	return InventoryInventoryAcquireAmountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryInventoryAcquireAmountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryInventoryAcquireAmountDistributionStatistics) Pointer() *InventoryInventoryAcquireAmountDistributionStatistics {
	return &p
}

func CastInventoryInventoryAcquireAmountDistributionStatisticses(data []interface{}) []InventoryInventoryAcquireAmountDistributionStatistics {
	v := make([]InventoryInventoryAcquireAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireAmountDistributionStatisticsesFromDict(data []InventoryInventoryAcquireAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireAmountDistributionSegment struct {
	ItemName *string `json:"itemName"`
	Sum      *int64  `json:"sum"`
}

func (p *InventoryInventoryAcquireAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireAmountDistributionSegment{}
	} else {
		*p = InventoryInventoryAcquireAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["itemName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireAmountDistributionSegmentFromJson(data string) InventoryInventoryAcquireAmountDistributionSegment {
	req := InventoryInventoryAcquireAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireAmountDistributionSegmentFromDict(data map[string]interface{}) InventoryInventoryAcquireAmountDistributionSegment {
	return InventoryInventoryAcquireAmountDistributionSegment{
		ItemName: core.CastString(data["itemName"]),
		Sum:      core.CastInt64(data["sum"]),
	}
}

func (p InventoryInventoryAcquireAmountDistributionSegment) ToDict() map[string]interface{} {

	var itemName *string
	if p.ItemName != nil {
		itemName = p.ItemName
	}
	var sum *int64
	if p.Sum != nil {
		sum = p.Sum
	}
	return map[string]interface{}{
		"itemName": itemName,
		"sum":      sum,
	}
}

func (p InventoryInventoryAcquireAmountDistributionSegment) Pointer() *InventoryInventoryAcquireAmountDistributionSegment {
	return &p
}

func CastInventoryInventoryAcquireAmountDistributionSegments(data []interface{}) []InventoryInventoryAcquireAmountDistributionSegment {
	v := make([]InventoryInventoryAcquireAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireAmountDistributionSegmentsFromDict(data []InventoryInventoryAcquireAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireAmountDistribution struct {
	Statistics   *InventoryInventoryAcquireAmountDistributionStatistics `json:"statistics"`
	Distribution []InventoryInventoryAcquireAmountDistributionSegment   `json:"distribution"`
}

func (p *InventoryInventoryAcquireAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireAmountDistribution{}
	} else {
		*p = InventoryInventoryAcquireAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireAmountDistributionFromJson(data string) InventoryInventoryAcquireAmountDistribution {
	req := InventoryInventoryAcquireAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireAmountDistributionFromDict(data map[string]interface{}) InventoryInventoryAcquireAmountDistribution {
	return InventoryInventoryAcquireAmountDistribution{
		Statistics:   NewInventoryInventoryAcquireAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryInventoryAcquireAmountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryInventoryAcquireAmountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryInventoryAcquireAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryInventoryAcquireAmountDistribution) Pointer() *InventoryInventoryAcquireAmountDistribution {
	return &p
}

func CastInventoryInventoryAcquireAmountDistributions(data []interface{}) []InventoryInventoryAcquireAmountDistribution {
	v := make([]InventoryInventoryAcquireAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireAmountDistributionsFromDict(data []InventoryInventoryAcquireAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryInventoryConsumeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeDistributionStatistics{}
	} else {
		*p = InventoryInventoryConsumeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeDistributionStatisticsFromJson(data string) InventoryInventoryConsumeDistributionStatistics {
	req := InventoryInventoryConsumeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeDistributionStatisticsFromDict(data map[string]interface{}) InventoryInventoryConsumeDistributionStatistics {
	return InventoryInventoryConsumeDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryInventoryConsumeDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryInventoryConsumeDistributionStatistics) Pointer() *InventoryInventoryConsumeDistributionStatistics {
	return &p
}

func CastInventoryInventoryConsumeDistributionStatisticses(data []interface{}) []InventoryInventoryConsumeDistributionStatistics {
	v := make([]InventoryInventoryConsumeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeDistributionStatisticsesFromDict(data []InventoryInventoryConsumeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeDistributionSegment struct {
	ItemName *string `json:"itemName"`
	Count    *int64  `json:"count"`
}

func (p *InventoryInventoryConsumeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeDistributionSegment{}
	} else {
		*p = InventoryInventoryConsumeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["itemName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeDistributionSegmentFromJson(data string) InventoryInventoryConsumeDistributionSegment {
	req := InventoryInventoryConsumeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeDistributionSegmentFromDict(data map[string]interface{}) InventoryInventoryConsumeDistributionSegment {
	return InventoryInventoryConsumeDistributionSegment{
		ItemName: core.CastString(data["itemName"]),
		Count:    core.CastInt64(data["count"]),
	}
}

func (p InventoryInventoryConsumeDistributionSegment) ToDict() map[string]interface{} {

	var itemName *string
	if p.ItemName != nil {
		itemName = p.ItemName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"itemName": itemName,
		"count":    count,
	}
}

func (p InventoryInventoryConsumeDistributionSegment) Pointer() *InventoryInventoryConsumeDistributionSegment {
	return &p
}

func CastInventoryInventoryConsumeDistributionSegments(data []interface{}) []InventoryInventoryConsumeDistributionSegment {
	v := make([]InventoryInventoryConsumeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeDistributionSegmentsFromDict(data []InventoryInventoryConsumeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeDistribution struct {
	Statistics   *InventoryInventoryConsumeDistributionStatistics `json:"statistics"`
	Distribution []InventoryInventoryConsumeDistributionSegment   `json:"distribution"`
}

func (p *InventoryInventoryConsumeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeDistribution{}
	} else {
		*p = InventoryInventoryConsumeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeDistributionFromJson(data string) InventoryInventoryConsumeDistribution {
	req := InventoryInventoryConsumeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeDistributionFromDict(data map[string]interface{}) InventoryInventoryConsumeDistribution {
	return InventoryInventoryConsumeDistribution{
		Statistics:   NewInventoryInventoryConsumeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryInventoryConsumeDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryInventoryConsumeDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryInventoryConsumeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryInventoryConsumeDistribution) Pointer() *InventoryInventoryConsumeDistribution {
	return &p
}

func CastInventoryInventoryConsumeDistributions(data []interface{}) []InventoryInventoryConsumeDistribution {
	v := make([]InventoryInventoryConsumeDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeDistributionsFromDict(data []InventoryInventoryConsumeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryInventoryConsumeAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeAmountDistributionStatistics{}
	} else {
		*p = InventoryInventoryConsumeAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeAmountDistributionStatisticsFromJson(data string) InventoryInventoryConsumeAmountDistributionStatistics {
	req := InventoryInventoryConsumeAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeAmountDistributionStatisticsFromDict(data map[string]interface{}) InventoryInventoryConsumeAmountDistributionStatistics {
	return InventoryInventoryConsumeAmountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryInventoryConsumeAmountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryInventoryConsumeAmountDistributionStatistics) Pointer() *InventoryInventoryConsumeAmountDistributionStatistics {
	return &p
}

func CastInventoryInventoryConsumeAmountDistributionStatisticses(data []interface{}) []InventoryInventoryConsumeAmountDistributionStatistics {
	v := make([]InventoryInventoryConsumeAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeAmountDistributionStatisticsesFromDict(data []InventoryInventoryConsumeAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeAmountDistributionSegment struct {
	ItemName *string `json:"itemName"`
	Sum      *int64  `json:"sum"`
}

func (p *InventoryInventoryConsumeAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeAmountDistributionSegment{}
	} else {
		*p = InventoryInventoryConsumeAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["itemName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeAmountDistributionSegmentFromJson(data string) InventoryInventoryConsumeAmountDistributionSegment {
	req := InventoryInventoryConsumeAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeAmountDistributionSegmentFromDict(data map[string]interface{}) InventoryInventoryConsumeAmountDistributionSegment {
	return InventoryInventoryConsumeAmountDistributionSegment{
		ItemName: core.CastString(data["itemName"]),
		Sum:      core.CastInt64(data["sum"]),
	}
}

func (p InventoryInventoryConsumeAmountDistributionSegment) ToDict() map[string]interface{} {

	var itemName *string
	if p.ItemName != nil {
		itemName = p.ItemName
	}
	var sum *int64
	if p.Sum != nil {
		sum = p.Sum
	}
	return map[string]interface{}{
		"itemName": itemName,
		"sum":      sum,
	}
}

func (p InventoryInventoryConsumeAmountDistributionSegment) Pointer() *InventoryInventoryConsumeAmountDistributionSegment {
	return &p
}

func CastInventoryInventoryConsumeAmountDistributionSegments(data []interface{}) []InventoryInventoryConsumeAmountDistributionSegment {
	v := make([]InventoryInventoryConsumeAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeAmountDistributionSegmentsFromDict(data []InventoryInventoryConsumeAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeAmountDistribution struct {
	Statistics   *InventoryInventoryConsumeAmountDistributionStatistics `json:"statistics"`
	Distribution []InventoryInventoryConsumeAmountDistributionSegment   `json:"distribution"`
}

func (p *InventoryInventoryConsumeAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeAmountDistribution{}
	} else {
		*p = InventoryInventoryConsumeAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeAmountDistributionFromJson(data string) InventoryInventoryConsumeAmountDistribution {
	req := InventoryInventoryConsumeAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeAmountDistributionFromDict(data map[string]interface{}) InventoryInventoryConsumeAmountDistribution {
	return InventoryInventoryConsumeAmountDistribution{
		Statistics:   NewInventoryInventoryConsumeAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryInventoryConsumeAmountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryInventoryConsumeAmountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryInventoryConsumeAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryInventoryConsumeAmountDistribution) Pointer() *InventoryInventoryConsumeAmountDistribution {
	return &p
}

func CastInventoryInventoryConsumeAmountDistributions(data []interface{}) []InventoryInventoryConsumeAmountDistribution {
	v := make([]InventoryInventoryConsumeAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeAmountDistributionsFromDict(data []InventoryInventoryConsumeAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryDistributions struct {
	Capacity      *InventoryInventoryCapacityDistribution      `json:"capacity"`
	Acquire       *InventoryInventoryAcquireDistribution       `json:"acquire"`
	AcquireAmount *InventoryInventoryAcquireAmountDistribution `json:"acquireAmount"`
	Consume       *InventoryInventoryConsumeDistribution       `json:"consume"`
	ConsumeAmount *InventoryInventoryConsumeAmountDistribution `json:"consumeAmount"`
}

func (p *InventoryInventoryDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryDistributions{}
	} else {
		*p = InventoryInventoryDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["capacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Capacity)
		}
		if v, ok := d["acquire"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Acquire)
		}
		if v, ok := d["acquireAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AcquireAmount)
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["consumeAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ConsumeAmount)
		}
	}
	return nil
}

func NewInventoryInventoryDistributionsFromJson(data string) InventoryInventoryDistributions {
	req := InventoryInventoryDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryDistributionsFromDict(data map[string]interface{}) InventoryInventoryDistributions {
	return InventoryInventoryDistributions{
		Capacity:      NewInventoryInventoryCapacityDistributionFromDict(core.CastMap(data["capacity"])).Pointer(),
		Acquire:       NewInventoryInventoryAcquireDistributionFromDict(core.CastMap(data["acquire"])).Pointer(),
		AcquireAmount: NewInventoryInventoryAcquireAmountDistributionFromDict(core.CastMap(data["acquireAmount"])).Pointer(),
		Consume:       NewInventoryInventoryConsumeDistributionFromDict(core.CastMap(data["consume"])).Pointer(),
		ConsumeAmount: NewInventoryInventoryConsumeAmountDistributionFromDict(core.CastMap(data["consumeAmount"])).Pointer(),
	}
}

func (p InventoryInventoryDistributions) ToDict() map[string]interface{} {

	var capacity map[string]interface{}
	if p.Capacity != nil {
		capacity = p.Capacity.ToDict()
	}
	var acquire map[string]interface{}
	if p.Acquire != nil {
		acquire = p.Acquire.ToDict()
	}
	var acquireAmount map[string]interface{}
	if p.AcquireAmount != nil {
		acquireAmount = p.AcquireAmount.ToDict()
	}
	var consume map[string]interface{}
	if p.Consume != nil {
		consume = p.Consume.ToDict()
	}
	var consumeAmount map[string]interface{}
	if p.ConsumeAmount != nil {
		consumeAmount = p.ConsumeAmount.ToDict()
	}
	return map[string]interface{}{
		"capacity":      capacity,
		"acquire":       acquire,
		"acquireAmount": acquireAmount,
		"consume":       consume,
		"consumeAmount": consumeAmount,
	}
}

func (p InventoryInventoryDistributions) Pointer() *InventoryInventoryDistributions {
	return &p
}

func CastInventoryInventoryDistributionses(data []interface{}) []InventoryInventoryDistributions {
	v := make([]InventoryInventoryDistributions, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryDistributionsesFromDict(data []InventoryInventoryDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventory struct {
	InventoryId   *string                          `json:"inventoryId"`
	InventoryName *string                          `json:"inventoryName"`
	Statistics    *InventoryInventoryStatistics    `json:"statistics"`
	Distributions *InventoryInventoryDistributions `json:"distributions"`
	ItemSets      []InventoryItemSet               `json:"itemSets"`
}

func (p *InventoryInventory) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventory{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventory{}
	} else {
		*p = InventoryInventory{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryId)
				}
			}
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["itemSets"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ItemSets)
		}
	}
	return nil
}

func NewInventoryInventoryFromJson(data string) InventoryInventory {
	req := InventoryInventory{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryFromDict(data map[string]interface{}) InventoryInventory {
	return InventoryInventory{
		InventoryId:   core.CastString(data["inventoryId"]),
		InventoryName: core.CastString(data["inventoryName"]),
		Statistics:    NewInventoryInventoryStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewInventoryInventoryDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		ItemSets:      CastInventoryItemSets(core.CastArray(data["itemSets"])),
	}
}

func (p InventoryInventory) ToDict() map[string]interface{} {

	var inventoryId *string
	if p.InventoryId != nil {
		inventoryId = p.InventoryId
	}
	var inventoryName *string
	if p.InventoryName != nil {
		inventoryName = p.InventoryName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var itemSets []interface{}
	if p.ItemSets != nil {
		itemSets = CastInventoryItemSetsFromDict(
			p.ItemSets,
		)
	}
	return map[string]interface{}{
		"inventoryId":   inventoryId,
		"inventoryName": inventoryName,
		"statistics":    statistics,
		"distributions": distributions,
		"itemSets":      itemSets,
	}
}

func (p InventoryInventory) Pointer() *InventoryInventory {
	return &p
}

func CastInventoryInventories(data []interface{}) []InventoryInventory {
	v := make([]InventoryInventory, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoriesFromDict(data []InventoryInventory) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceStatistics struct {
	Acquire          *int64 `json:"acquire"`
	Consume          *int64 `json:"consume"`
	IncreaseCapacity *int64 `json:"increaseCapacity"`
}

func (p *InventoryNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceStatistics{}
	} else {
		*p = InventoryNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["acquire"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Acquire)
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["increaseCapacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacity)
		}
	}
	return nil
}

func NewInventoryNamespaceStatisticsFromJson(data string) InventoryNamespaceStatistics {
	req := InventoryNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceStatisticsFromDict(data map[string]interface{}) InventoryNamespaceStatistics {
	return InventoryNamespaceStatistics{
		Acquire:          core.CastInt64(data["acquire"]),
		Consume:          core.CastInt64(data["consume"]),
		IncreaseCapacity: core.CastInt64(data["increaseCapacity"]),
	}
}

func (p InventoryNamespaceStatistics) ToDict() map[string]interface{} {

	var acquire *int64
	if p.Acquire != nil {
		acquire = p.Acquire
	}
	var consume *int64
	if p.Consume != nil {
		consume = p.Consume
	}
	var increaseCapacity *int64
	if p.IncreaseCapacity != nil {
		increaseCapacity = p.IncreaseCapacity
	}
	return map[string]interface{}{
		"acquire":          acquire,
		"consume":          consume,
		"increaseCapacity": increaseCapacity,
	}
}

func (p InventoryNamespaceStatistics) Pointer() *InventoryNamespaceStatistics {
	return &p
}

func CastInventoryNamespaceStatisticses(data []interface{}) []InventoryNamespaceStatistics {
	v := make([]InventoryNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceStatisticsesFromDict(data []InventoryNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceAcquireDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireDistributionStatistics{}
	} else {
		*p = InventoryNamespaceAcquireDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireDistributionStatisticsFromJson(data string) InventoryNamespaceAcquireDistributionStatistics {
	req := InventoryNamespaceAcquireDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceAcquireDistributionStatistics {
	return InventoryNamespaceAcquireDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryNamespaceAcquireDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryNamespaceAcquireDistributionStatistics) Pointer() *InventoryNamespaceAcquireDistributionStatistics {
	return &p
}

func CastInventoryNamespaceAcquireDistributionStatisticses(data []interface{}) []InventoryNamespaceAcquireDistributionStatistics {
	v := make([]InventoryNamespaceAcquireDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireDistributionStatisticsesFromDict(data []InventoryNamespaceAcquireDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Count         *int64  `json:"count"`
}

func (p *InventoryNamespaceAcquireDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireDistributionSegment{}
	} else {
		*p = InventoryNamespaceAcquireDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireDistributionSegmentFromJson(data string) InventoryNamespaceAcquireDistributionSegment {
	req := InventoryNamespaceAcquireDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceAcquireDistributionSegment {
	return InventoryNamespaceAcquireDistributionSegment{
		InventoryName: core.CastString(data["inventoryName"]),
		Count:         core.CastInt64(data["count"]),
	}
}

func (p InventoryNamespaceAcquireDistributionSegment) ToDict() map[string]interface{} {

	var inventoryName *string
	if p.InventoryName != nil {
		inventoryName = p.InventoryName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"inventoryName": inventoryName,
		"count":         count,
	}
}

func (p InventoryNamespaceAcquireDistributionSegment) Pointer() *InventoryNamespaceAcquireDistributionSegment {
	return &p
}

func CastInventoryNamespaceAcquireDistributionSegments(data []interface{}) []InventoryNamespaceAcquireDistributionSegment {
	v := make([]InventoryNamespaceAcquireDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireDistributionSegmentsFromDict(data []InventoryNamespaceAcquireDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireDistribution struct {
	Statistics   *InventoryNamespaceAcquireDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceAcquireDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceAcquireDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireDistribution{}
	} else {
		*p = InventoryNamespaceAcquireDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireDistributionFromJson(data string) InventoryNamespaceAcquireDistribution {
	req := InventoryNamespaceAcquireDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireDistributionFromDict(data map[string]interface{}) InventoryNamespaceAcquireDistribution {
	return InventoryNamespaceAcquireDistribution{
		Statistics:   NewInventoryNamespaceAcquireDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryNamespaceAcquireDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryNamespaceAcquireDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryNamespaceAcquireDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryNamespaceAcquireDistribution) Pointer() *InventoryNamespaceAcquireDistribution {
	return &p
}

func CastInventoryNamespaceAcquireDistributions(data []interface{}) []InventoryNamespaceAcquireDistribution {
	v := make([]InventoryNamespaceAcquireDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireDistributionsFromDict(data []InventoryNamespaceAcquireDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceAcquireAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireAmountDistributionStatistics{}
	} else {
		*p = InventoryNamespaceAcquireAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireAmountDistributionStatisticsFromJson(data string) InventoryNamespaceAcquireAmountDistributionStatistics {
	req := InventoryNamespaceAcquireAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireAmountDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceAcquireAmountDistributionStatistics {
	return InventoryNamespaceAcquireAmountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryNamespaceAcquireAmountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryNamespaceAcquireAmountDistributionStatistics) Pointer() *InventoryNamespaceAcquireAmountDistributionStatistics {
	return &p
}

func CastInventoryNamespaceAcquireAmountDistributionStatisticses(data []interface{}) []InventoryNamespaceAcquireAmountDistributionStatistics {
	v := make([]InventoryNamespaceAcquireAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireAmountDistributionStatisticsesFromDict(data []InventoryNamespaceAcquireAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireAmountDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Sum           *int64  `json:"sum"`
}

func (p *InventoryNamespaceAcquireAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireAmountDistributionSegment{}
	} else {
		*p = InventoryNamespaceAcquireAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireAmountDistributionSegmentFromJson(data string) InventoryNamespaceAcquireAmountDistributionSegment {
	req := InventoryNamespaceAcquireAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireAmountDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceAcquireAmountDistributionSegment {
	return InventoryNamespaceAcquireAmountDistributionSegment{
		InventoryName: core.CastString(data["inventoryName"]),
		Sum:           core.CastInt64(data["sum"]),
	}
}

func (p InventoryNamespaceAcquireAmountDistributionSegment) ToDict() map[string]interface{} {

	var inventoryName *string
	if p.InventoryName != nil {
		inventoryName = p.InventoryName
	}
	var sum *int64
	if p.Sum != nil {
		sum = p.Sum
	}
	return map[string]interface{}{
		"inventoryName": inventoryName,
		"sum":           sum,
	}
}

func (p InventoryNamespaceAcquireAmountDistributionSegment) Pointer() *InventoryNamespaceAcquireAmountDistributionSegment {
	return &p
}

func CastInventoryNamespaceAcquireAmountDistributionSegments(data []interface{}) []InventoryNamespaceAcquireAmountDistributionSegment {
	v := make([]InventoryNamespaceAcquireAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireAmountDistributionSegmentsFromDict(data []InventoryNamespaceAcquireAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireAmountDistribution struct {
	Statistics   *InventoryNamespaceAcquireAmountDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceAcquireAmountDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceAcquireAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireAmountDistribution{}
	} else {
		*p = InventoryNamespaceAcquireAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireAmountDistributionFromJson(data string) InventoryNamespaceAcquireAmountDistribution {
	req := InventoryNamespaceAcquireAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireAmountDistributionFromDict(data map[string]interface{}) InventoryNamespaceAcquireAmountDistribution {
	return InventoryNamespaceAcquireAmountDistribution{
		Statistics:   NewInventoryNamespaceAcquireAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryNamespaceAcquireAmountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryNamespaceAcquireAmountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryNamespaceAcquireAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryNamespaceAcquireAmountDistribution) Pointer() *InventoryNamespaceAcquireAmountDistribution {
	return &p
}

func CastInventoryNamespaceAcquireAmountDistributions(data []interface{}) []InventoryNamespaceAcquireAmountDistribution {
	v := make([]InventoryNamespaceAcquireAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireAmountDistributionsFromDict(data []InventoryNamespaceAcquireAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceConsumeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeDistributionStatistics{}
	} else {
		*p = InventoryNamespaceConsumeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeDistributionStatisticsFromJson(data string) InventoryNamespaceConsumeDistributionStatistics {
	req := InventoryNamespaceConsumeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceConsumeDistributionStatistics {
	return InventoryNamespaceConsumeDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryNamespaceConsumeDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryNamespaceConsumeDistributionStatistics) Pointer() *InventoryNamespaceConsumeDistributionStatistics {
	return &p
}

func CastInventoryNamespaceConsumeDistributionStatisticses(data []interface{}) []InventoryNamespaceConsumeDistributionStatistics {
	v := make([]InventoryNamespaceConsumeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeDistributionStatisticsesFromDict(data []InventoryNamespaceConsumeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Count         *int64  `json:"count"`
}

func (p *InventoryNamespaceConsumeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeDistributionSegment{}
	} else {
		*p = InventoryNamespaceConsumeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeDistributionSegmentFromJson(data string) InventoryNamespaceConsumeDistributionSegment {
	req := InventoryNamespaceConsumeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceConsumeDistributionSegment {
	return InventoryNamespaceConsumeDistributionSegment{
		InventoryName: core.CastString(data["inventoryName"]),
		Count:         core.CastInt64(data["count"]),
	}
}

func (p InventoryNamespaceConsumeDistributionSegment) ToDict() map[string]interface{} {

	var inventoryName *string
	if p.InventoryName != nil {
		inventoryName = p.InventoryName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"inventoryName": inventoryName,
		"count":         count,
	}
}

func (p InventoryNamespaceConsumeDistributionSegment) Pointer() *InventoryNamespaceConsumeDistributionSegment {
	return &p
}

func CastInventoryNamespaceConsumeDistributionSegments(data []interface{}) []InventoryNamespaceConsumeDistributionSegment {
	v := make([]InventoryNamespaceConsumeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeDistributionSegmentsFromDict(data []InventoryNamespaceConsumeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeDistribution struct {
	Statistics   *InventoryNamespaceConsumeDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceConsumeDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceConsumeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeDistribution{}
	} else {
		*p = InventoryNamespaceConsumeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeDistributionFromJson(data string) InventoryNamespaceConsumeDistribution {
	req := InventoryNamespaceConsumeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeDistributionFromDict(data map[string]interface{}) InventoryNamespaceConsumeDistribution {
	return InventoryNamespaceConsumeDistribution{
		Statistics:   NewInventoryNamespaceConsumeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryNamespaceConsumeDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryNamespaceConsumeDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryNamespaceConsumeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryNamespaceConsumeDistribution) Pointer() *InventoryNamespaceConsumeDistribution {
	return &p
}

func CastInventoryNamespaceConsumeDistributions(data []interface{}) []InventoryNamespaceConsumeDistribution {
	v := make([]InventoryNamespaceConsumeDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeDistributionsFromDict(data []InventoryNamespaceConsumeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceConsumeAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeAmountDistributionStatistics{}
	} else {
		*p = InventoryNamespaceConsumeAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeAmountDistributionStatisticsFromJson(data string) InventoryNamespaceConsumeAmountDistributionStatistics {
	req := InventoryNamespaceConsumeAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeAmountDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceConsumeAmountDistributionStatistics {
	return InventoryNamespaceConsumeAmountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryNamespaceConsumeAmountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryNamespaceConsumeAmountDistributionStatistics) Pointer() *InventoryNamespaceConsumeAmountDistributionStatistics {
	return &p
}

func CastInventoryNamespaceConsumeAmountDistributionStatisticses(data []interface{}) []InventoryNamespaceConsumeAmountDistributionStatistics {
	v := make([]InventoryNamespaceConsumeAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeAmountDistributionStatisticsesFromDict(data []InventoryNamespaceConsumeAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeAmountDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Sum           *int64  `json:"sum"`
}

func (p *InventoryNamespaceConsumeAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeAmountDistributionSegment{}
	} else {
		*p = InventoryNamespaceConsumeAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeAmountDistributionSegmentFromJson(data string) InventoryNamespaceConsumeAmountDistributionSegment {
	req := InventoryNamespaceConsumeAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeAmountDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceConsumeAmountDistributionSegment {
	return InventoryNamespaceConsumeAmountDistributionSegment{
		InventoryName: core.CastString(data["inventoryName"]),
		Sum:           core.CastInt64(data["sum"]),
	}
}

func (p InventoryNamespaceConsumeAmountDistributionSegment) ToDict() map[string]interface{} {

	var inventoryName *string
	if p.InventoryName != nil {
		inventoryName = p.InventoryName
	}
	var sum *int64
	if p.Sum != nil {
		sum = p.Sum
	}
	return map[string]interface{}{
		"inventoryName": inventoryName,
		"sum":           sum,
	}
}

func (p InventoryNamespaceConsumeAmountDistributionSegment) Pointer() *InventoryNamespaceConsumeAmountDistributionSegment {
	return &p
}

func CastInventoryNamespaceConsumeAmountDistributionSegments(data []interface{}) []InventoryNamespaceConsumeAmountDistributionSegment {
	v := make([]InventoryNamespaceConsumeAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeAmountDistributionSegmentsFromDict(data []InventoryNamespaceConsumeAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeAmountDistribution struct {
	Statistics   *InventoryNamespaceConsumeAmountDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceConsumeAmountDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceConsumeAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeAmountDistribution{}
	} else {
		*p = InventoryNamespaceConsumeAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeAmountDistributionFromJson(data string) InventoryNamespaceConsumeAmountDistribution {
	req := InventoryNamespaceConsumeAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeAmountDistributionFromDict(data map[string]interface{}) InventoryNamespaceConsumeAmountDistribution {
	return InventoryNamespaceConsumeAmountDistribution{
		Statistics:   NewInventoryNamespaceConsumeAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryNamespaceConsumeAmountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryNamespaceConsumeAmountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryNamespaceConsumeAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryNamespaceConsumeAmountDistribution) Pointer() *InventoryNamespaceConsumeAmountDistribution {
	return &p
}

func CastInventoryNamespaceConsumeAmountDistributions(data []interface{}) []InventoryNamespaceConsumeAmountDistribution {
	v := make([]InventoryNamespaceConsumeAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeAmountDistributionsFromDict(data []InventoryNamespaceConsumeAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceIncreaseCapacityDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityDistributionStatistics{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityDistributionStatisticsFromJson(data string) InventoryNamespaceIncreaseCapacityDistributionStatistics {
	req := InventoryNamespaceIncreaseCapacityDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityDistributionStatistics {
	return InventoryNamespaceIncreaseCapacityDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryNamespaceIncreaseCapacityDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryNamespaceIncreaseCapacityDistributionStatistics) Pointer() *InventoryNamespaceIncreaseCapacityDistributionStatistics {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityDistributionStatisticses(data []interface{}) []InventoryNamespaceIncreaseCapacityDistributionStatistics {
	v := make([]InventoryNamespaceIncreaseCapacityDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityDistributionStatisticsesFromDict(data []InventoryNamespaceIncreaseCapacityDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Count         *int64  `json:"count"`
}

func (p *InventoryNamespaceIncreaseCapacityDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityDistributionSegment{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityDistributionSegmentFromJson(data string) InventoryNamespaceIncreaseCapacityDistributionSegment {
	req := InventoryNamespaceIncreaseCapacityDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityDistributionSegment {
	return InventoryNamespaceIncreaseCapacityDistributionSegment{
		InventoryName: core.CastString(data["inventoryName"]),
		Count:         core.CastInt64(data["count"]),
	}
}

func (p InventoryNamespaceIncreaseCapacityDistributionSegment) ToDict() map[string]interface{} {

	var inventoryName *string
	if p.InventoryName != nil {
		inventoryName = p.InventoryName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"inventoryName": inventoryName,
		"count":         count,
	}
}

func (p InventoryNamespaceIncreaseCapacityDistributionSegment) Pointer() *InventoryNamespaceIncreaseCapacityDistributionSegment {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityDistributionSegments(data []interface{}) []InventoryNamespaceIncreaseCapacityDistributionSegment {
	v := make([]InventoryNamespaceIncreaseCapacityDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityDistributionSegmentsFromDict(data []InventoryNamespaceIncreaseCapacityDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityDistribution struct {
	Statistics   *InventoryNamespaceIncreaseCapacityDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceIncreaseCapacityDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceIncreaseCapacityDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityDistribution{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityDistributionFromJson(data string) InventoryNamespaceIncreaseCapacityDistribution {
	req := InventoryNamespaceIncreaseCapacityDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityDistributionFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityDistribution {
	return InventoryNamespaceIncreaseCapacityDistribution{
		Statistics:   NewInventoryNamespaceIncreaseCapacityDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryNamespaceIncreaseCapacityDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryNamespaceIncreaseCapacityDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryNamespaceIncreaseCapacityDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryNamespaceIncreaseCapacityDistribution) Pointer() *InventoryNamespaceIncreaseCapacityDistribution {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityDistributions(data []interface{}) []InventoryNamespaceIncreaseCapacityDistribution {
	v := make([]InventoryNamespaceIncreaseCapacityDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityDistributionsFromDict(data []InventoryNamespaceIncreaseCapacityDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceIncreaseCapacityAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionStatistics{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionStatisticsFromJson(data string) InventoryNamespaceIncreaseCapacityAmountDistributionStatistics {
	req := InventoryNamespaceIncreaseCapacityAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityAmountDistributionStatistics {
	return InventoryNamespaceIncreaseCapacityAmountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p InventoryNamespaceIncreaseCapacityAmountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p InventoryNamespaceIncreaseCapacityAmountDistributionStatistics) Pointer() *InventoryNamespaceIncreaseCapacityAmountDistributionStatistics {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributionStatisticses(data []interface{}) []InventoryNamespaceIncreaseCapacityAmountDistributionStatistics {
	v := make([]InventoryNamespaceIncreaseCapacityAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributionStatisticsesFromDict(data []InventoryNamespaceIncreaseCapacityAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityAmountDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Sum           *int64  `json:"sum"`
}

func (p *InventoryNamespaceIncreaseCapacityAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionSegment{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionSegmentFromJson(data string) InventoryNamespaceIncreaseCapacityAmountDistributionSegment {
	req := InventoryNamespaceIncreaseCapacityAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityAmountDistributionSegment {
	return InventoryNamespaceIncreaseCapacityAmountDistributionSegment{
		InventoryName: core.CastString(data["inventoryName"]),
		Sum:           core.CastInt64(data["sum"]),
	}
}

func (p InventoryNamespaceIncreaseCapacityAmountDistributionSegment) ToDict() map[string]interface{} {

	var inventoryName *string
	if p.InventoryName != nil {
		inventoryName = p.InventoryName
	}
	var sum *int64
	if p.Sum != nil {
		sum = p.Sum
	}
	return map[string]interface{}{
		"inventoryName": inventoryName,
		"sum":           sum,
	}
}

func (p InventoryNamespaceIncreaseCapacityAmountDistributionSegment) Pointer() *InventoryNamespaceIncreaseCapacityAmountDistributionSegment {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributionSegments(data []interface{}) []InventoryNamespaceIncreaseCapacityAmountDistributionSegment {
	v := make([]InventoryNamespaceIncreaseCapacityAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributionSegmentsFromDict(data []InventoryNamespaceIncreaseCapacityAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityAmountDistribution struct {
	Statistics   *InventoryNamespaceIncreaseCapacityAmountDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceIncreaseCapacityAmountDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceIncreaseCapacityAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityAmountDistribution{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionFromJson(data string) InventoryNamespaceIncreaseCapacityAmountDistribution {
	req := InventoryNamespaceIncreaseCapacityAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityAmountDistribution {
	return InventoryNamespaceIncreaseCapacityAmountDistribution{
		Statistics:   NewInventoryNamespaceIncreaseCapacityAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastInventoryNamespaceIncreaseCapacityAmountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p InventoryNamespaceIncreaseCapacityAmountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastInventoryNamespaceIncreaseCapacityAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p InventoryNamespaceIncreaseCapacityAmountDistribution) Pointer() *InventoryNamespaceIncreaseCapacityAmountDistribution {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributions(data []interface{}) []InventoryNamespaceIncreaseCapacityAmountDistribution {
	v := make([]InventoryNamespaceIncreaseCapacityAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributionsFromDict(data []InventoryNamespaceIncreaseCapacityAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceDistributions struct {
	Acquire                *InventoryNamespaceAcquireDistribution                `json:"acquire"`
	AcquireAmount          *InventoryNamespaceAcquireAmountDistribution          `json:"acquireAmount"`
	Consume                *InventoryNamespaceConsumeDistribution                `json:"consume"`
	ConsumeAmount          *InventoryNamespaceConsumeAmountDistribution          `json:"consumeAmount"`
	IncreaseCapacity       *InventoryNamespaceIncreaseCapacityDistribution       `json:"increaseCapacity"`
	IncreaseCapacityAmount *InventoryNamespaceIncreaseCapacityAmountDistribution `json:"increaseCapacityAmount"`
}

func (p *InventoryNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceDistributions{}
	} else {
		*p = InventoryNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["acquire"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Acquire)
		}
		if v, ok := d["acquireAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AcquireAmount)
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["consumeAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ConsumeAmount)
		}
		if v, ok := d["increaseCapacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacity)
		}
		if v, ok := d["increaseCapacityAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacityAmount)
		}
	}
	return nil
}

func NewInventoryNamespaceDistributionsFromJson(data string) InventoryNamespaceDistributions {
	req := InventoryNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceDistributionsFromDict(data map[string]interface{}) InventoryNamespaceDistributions {
	return InventoryNamespaceDistributions{
		Acquire:                NewInventoryNamespaceAcquireDistributionFromDict(core.CastMap(data["acquire"])).Pointer(),
		AcquireAmount:          NewInventoryNamespaceAcquireAmountDistributionFromDict(core.CastMap(data["acquireAmount"])).Pointer(),
		Consume:                NewInventoryNamespaceConsumeDistributionFromDict(core.CastMap(data["consume"])).Pointer(),
		ConsumeAmount:          NewInventoryNamespaceConsumeAmountDistributionFromDict(core.CastMap(data["consumeAmount"])).Pointer(),
		IncreaseCapacity:       NewInventoryNamespaceIncreaseCapacityDistributionFromDict(core.CastMap(data["increaseCapacity"])).Pointer(),
		IncreaseCapacityAmount: NewInventoryNamespaceIncreaseCapacityAmountDistributionFromDict(core.CastMap(data["increaseCapacityAmount"])).Pointer(),
	}
}

func (p InventoryNamespaceDistributions) ToDict() map[string]interface{} {

	var acquire map[string]interface{}
	if p.Acquire != nil {
		acquire = p.Acquire.ToDict()
	}
	var acquireAmount map[string]interface{}
	if p.AcquireAmount != nil {
		acquireAmount = p.AcquireAmount.ToDict()
	}
	var consume map[string]interface{}
	if p.Consume != nil {
		consume = p.Consume.ToDict()
	}
	var consumeAmount map[string]interface{}
	if p.ConsumeAmount != nil {
		consumeAmount = p.ConsumeAmount.ToDict()
	}
	var increaseCapacity map[string]interface{}
	if p.IncreaseCapacity != nil {
		increaseCapacity = p.IncreaseCapacity.ToDict()
	}
	var increaseCapacityAmount map[string]interface{}
	if p.IncreaseCapacityAmount != nil {
		increaseCapacityAmount = p.IncreaseCapacityAmount.ToDict()
	}
	return map[string]interface{}{
		"acquire":                acquire,
		"acquireAmount":          acquireAmount,
		"consume":                consume,
		"consumeAmount":          consumeAmount,
		"increaseCapacity":       increaseCapacity,
		"increaseCapacityAmount": increaseCapacityAmount,
	}
}

func (p InventoryNamespaceDistributions) Pointer() *InventoryNamespaceDistributions {
	return &p
}

func CastInventoryNamespaceDistributionses(data []interface{}) []InventoryNamespaceDistributions {
	v := make([]InventoryNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceDistributionsesFromDict(data []InventoryNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespace struct {
	NamespaceId   *string                          `json:"namespaceId"`
	Year          *int32                           `json:"year"`
	Month         *int32                           `json:"month"`
	Day           *int32                           `json:"day"`
	NamespaceName *string                          `json:"namespaceName"`
	Statistics    *InventoryNamespaceStatistics    `json:"statistics"`
	Distributions *InventoryNamespaceDistributions `json:"distributions"`
	Inventories   []InventoryInventory             `json:"inventories"`
}

func (p *InventoryNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespace{}
	} else {
		*p = InventoryNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["inventories"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Inventories)
		}
	}
	return nil
}

func NewInventoryNamespaceFromJson(data string) InventoryNamespace {
	req := InventoryNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceFromDict(data map[string]interface{}) InventoryNamespace {
	return InventoryNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewInventoryNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewInventoryNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		Inventories:   CastInventoryInventories(core.CastArray(data["inventories"])),
	}
}

func (p InventoryNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var inventories []interface{}
	if p.Inventories != nil {
		inventories = CastInventoryInventoriesFromDict(
			p.Inventories,
		)
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
		"inventories":   inventories,
	}
}

func (p InventoryNamespace) Pointer() *InventoryNamespace {
	return &p
}

func CastInventoryNamespaces(data []interface{}) []InventoryNamespace {
	v := make([]InventoryNamespace, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespacesFromDict(data []InventoryNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceStatistics struct {
	Encrypt *int64 `json:"encrypt"`
	Decrypt *int64 `json:"decrypt"`
}

func (p *KeyNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceStatistics{}
	} else {
		*p = KeyNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["encrypt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Encrypt)
		}
		if v, ok := d["decrypt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Decrypt)
		}
	}
	return nil
}

func NewKeyNamespaceStatisticsFromJson(data string) KeyNamespaceStatistics {
	req := KeyNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceStatisticsFromDict(data map[string]interface{}) KeyNamespaceStatistics {
	return KeyNamespaceStatistics{
		Encrypt: core.CastInt64(data["encrypt"]),
		Decrypt: core.CastInt64(data["decrypt"]),
	}
}

func (p KeyNamespaceStatistics) ToDict() map[string]interface{} {

	var encrypt *int64
	if p.Encrypt != nil {
		encrypt = p.Encrypt
	}
	var decrypt *int64
	if p.Decrypt != nil {
		decrypt = p.Decrypt
	}
	return map[string]interface{}{
		"encrypt": encrypt,
		"decrypt": decrypt,
	}
}

func (p KeyNamespaceStatistics) Pointer() *KeyNamespaceStatistics {
	return &p
}

func CastKeyNamespaceStatisticses(data []interface{}) []KeyNamespaceStatistics {
	v := make([]KeyNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceStatisticsesFromDict(data []KeyNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceEncryptDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *KeyNamespaceEncryptDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceEncryptDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceEncryptDistributionStatistics{}
	} else {
		*p = KeyNamespaceEncryptDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewKeyNamespaceEncryptDistributionStatisticsFromJson(data string) KeyNamespaceEncryptDistributionStatistics {
	req := KeyNamespaceEncryptDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceEncryptDistributionStatisticsFromDict(data map[string]interface{}) KeyNamespaceEncryptDistributionStatistics {
	return KeyNamespaceEncryptDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p KeyNamespaceEncryptDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p KeyNamespaceEncryptDistributionStatistics) Pointer() *KeyNamespaceEncryptDistributionStatistics {
	return &p
}

func CastKeyNamespaceEncryptDistributionStatisticses(data []interface{}) []KeyNamespaceEncryptDistributionStatistics {
	v := make([]KeyNamespaceEncryptDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceEncryptDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceEncryptDistributionStatisticsesFromDict(data []KeyNamespaceEncryptDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceEncryptDistributionSegment struct {
	KeyName *string `json:"keyName"`
	Count   *int64  `json:"count"`
}

func (p *KeyNamespaceEncryptDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceEncryptDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceEncryptDistributionSegment{}
	} else {
		*p = KeyNamespaceEncryptDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["keyName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.KeyName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.KeyName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.KeyName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.KeyName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewKeyNamespaceEncryptDistributionSegmentFromJson(data string) KeyNamespaceEncryptDistributionSegment {
	req := KeyNamespaceEncryptDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceEncryptDistributionSegmentFromDict(data map[string]interface{}) KeyNamespaceEncryptDistributionSegment {
	return KeyNamespaceEncryptDistributionSegment{
		KeyName: core.CastString(data["keyName"]),
		Count:   core.CastInt64(data["count"]),
	}
}

func (p KeyNamespaceEncryptDistributionSegment) ToDict() map[string]interface{} {

	var keyName *string
	if p.KeyName != nil {
		keyName = p.KeyName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"keyName": keyName,
		"count":   count,
	}
}

func (p KeyNamespaceEncryptDistributionSegment) Pointer() *KeyNamespaceEncryptDistributionSegment {
	return &p
}

func CastKeyNamespaceEncryptDistributionSegments(data []interface{}) []KeyNamespaceEncryptDistributionSegment {
	v := make([]KeyNamespaceEncryptDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceEncryptDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceEncryptDistributionSegmentsFromDict(data []KeyNamespaceEncryptDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceEncryptDistribution struct {
	Statistics   *KeyNamespaceEncryptDistributionStatistics `json:"statistics"`
	Distribution []KeyNamespaceEncryptDistributionSegment   `json:"distribution"`
}

func (p *KeyNamespaceEncryptDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceEncryptDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceEncryptDistribution{}
	} else {
		*p = KeyNamespaceEncryptDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewKeyNamespaceEncryptDistributionFromJson(data string) KeyNamespaceEncryptDistribution {
	req := KeyNamespaceEncryptDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceEncryptDistributionFromDict(data map[string]interface{}) KeyNamespaceEncryptDistribution {
	return KeyNamespaceEncryptDistribution{
		Statistics:   NewKeyNamespaceEncryptDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastKeyNamespaceEncryptDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p KeyNamespaceEncryptDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastKeyNamespaceEncryptDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p KeyNamespaceEncryptDistribution) Pointer() *KeyNamespaceEncryptDistribution {
	return &p
}

func CastKeyNamespaceEncryptDistributions(data []interface{}) []KeyNamespaceEncryptDistribution {
	v := make([]KeyNamespaceEncryptDistribution, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceEncryptDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceEncryptDistributionsFromDict(data []KeyNamespaceEncryptDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceDecryptDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *KeyNamespaceDecryptDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceDecryptDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceDecryptDistributionStatistics{}
	} else {
		*p = KeyNamespaceDecryptDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewKeyNamespaceDecryptDistributionStatisticsFromJson(data string) KeyNamespaceDecryptDistributionStatistics {
	req := KeyNamespaceDecryptDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceDecryptDistributionStatisticsFromDict(data map[string]interface{}) KeyNamespaceDecryptDistributionStatistics {
	return KeyNamespaceDecryptDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p KeyNamespaceDecryptDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p KeyNamespaceDecryptDistributionStatistics) Pointer() *KeyNamespaceDecryptDistributionStatistics {
	return &p
}

func CastKeyNamespaceDecryptDistributionStatisticses(data []interface{}) []KeyNamespaceDecryptDistributionStatistics {
	v := make([]KeyNamespaceDecryptDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceDecryptDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceDecryptDistributionStatisticsesFromDict(data []KeyNamespaceDecryptDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceDecryptDistributionSegment struct {
	KeyName *string `json:"keyName"`
	Count   *int64  `json:"count"`
}

func (p *KeyNamespaceDecryptDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceDecryptDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceDecryptDistributionSegment{}
	} else {
		*p = KeyNamespaceDecryptDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["keyName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.KeyName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.KeyName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.KeyName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.KeyName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewKeyNamespaceDecryptDistributionSegmentFromJson(data string) KeyNamespaceDecryptDistributionSegment {
	req := KeyNamespaceDecryptDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceDecryptDistributionSegmentFromDict(data map[string]interface{}) KeyNamespaceDecryptDistributionSegment {
	return KeyNamespaceDecryptDistributionSegment{
		KeyName: core.CastString(data["keyName"]),
		Count:   core.CastInt64(data["count"]),
	}
}

func (p KeyNamespaceDecryptDistributionSegment) ToDict() map[string]interface{} {

	var keyName *string
	if p.KeyName != nil {
		keyName = p.KeyName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"keyName": keyName,
		"count":   count,
	}
}

func (p KeyNamespaceDecryptDistributionSegment) Pointer() *KeyNamespaceDecryptDistributionSegment {
	return &p
}

func CastKeyNamespaceDecryptDistributionSegments(data []interface{}) []KeyNamespaceDecryptDistributionSegment {
	v := make([]KeyNamespaceDecryptDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceDecryptDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceDecryptDistributionSegmentsFromDict(data []KeyNamespaceDecryptDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceDecryptDistribution struct {
	Statistics   *KeyNamespaceDecryptDistributionStatistics `json:"statistics"`
	Distribution []KeyNamespaceDecryptDistributionSegment   `json:"distribution"`
}

func (p *KeyNamespaceDecryptDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceDecryptDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceDecryptDistribution{}
	} else {
		*p = KeyNamespaceDecryptDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewKeyNamespaceDecryptDistributionFromJson(data string) KeyNamespaceDecryptDistribution {
	req := KeyNamespaceDecryptDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceDecryptDistributionFromDict(data map[string]interface{}) KeyNamespaceDecryptDistribution {
	return KeyNamespaceDecryptDistribution{
		Statistics:   NewKeyNamespaceDecryptDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastKeyNamespaceDecryptDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p KeyNamespaceDecryptDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastKeyNamespaceDecryptDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p KeyNamespaceDecryptDistribution) Pointer() *KeyNamespaceDecryptDistribution {
	return &p
}

func CastKeyNamespaceDecryptDistributions(data []interface{}) []KeyNamespaceDecryptDistribution {
	v := make([]KeyNamespaceDecryptDistribution, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceDecryptDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceDecryptDistributionsFromDict(data []KeyNamespaceDecryptDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceDistributions struct {
	Encrypt *KeyNamespaceEncryptDistribution `json:"encrypt"`
	Decrypt *KeyNamespaceDecryptDistribution `json:"decrypt"`
}

func (p *KeyNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceDistributions{}
	} else {
		*p = KeyNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["encrypt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Encrypt)
		}
		if v, ok := d["decrypt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Decrypt)
		}
	}
	return nil
}

func NewKeyNamespaceDistributionsFromJson(data string) KeyNamespaceDistributions {
	req := KeyNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceDistributionsFromDict(data map[string]interface{}) KeyNamespaceDistributions {
	return KeyNamespaceDistributions{
		Encrypt: NewKeyNamespaceEncryptDistributionFromDict(core.CastMap(data["encrypt"])).Pointer(),
		Decrypt: NewKeyNamespaceDecryptDistributionFromDict(core.CastMap(data["decrypt"])).Pointer(),
	}
}

func (p KeyNamespaceDistributions) ToDict() map[string]interface{} {

	var encrypt map[string]interface{}
	if p.Encrypt != nil {
		encrypt = p.Encrypt.ToDict()
	}
	var decrypt map[string]interface{}
	if p.Decrypt != nil {
		decrypt = p.Decrypt.ToDict()
	}
	return map[string]interface{}{
		"encrypt": encrypt,
		"decrypt": decrypt,
	}
}

func (p KeyNamespaceDistributions) Pointer() *KeyNamespaceDistributions {
	return &p
}

func CastKeyNamespaceDistributionses(data []interface{}) []KeyNamespaceDistributions {
	v := make([]KeyNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceDistributionsesFromDict(data []KeyNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespace struct {
	NamespaceId   *string                    `json:"namespaceId"`
	Year          *int32                     `json:"year"`
	Month         *int32                     `json:"month"`
	Day           *int32                     `json:"day"`
	NamespaceName *string                    `json:"namespaceName"`
	Statistics    *KeyNamespaceStatistics    `json:"statistics"`
	Distributions *KeyNamespaceDistributions `json:"distributions"`
}

func (p *KeyNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespace{}
	} else {
		*p = KeyNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewKeyNamespaceFromJson(data string) KeyNamespace {
	req := KeyNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceFromDict(data map[string]interface{}) KeyNamespace {
	return KeyNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewKeyNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewKeyNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p KeyNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p KeyNamespace) Pointer() *KeyNamespace {
	return &p
}

func CastKeyNamespaces(data []interface{}) []KeyNamespace {
	v := make([]KeyNamespace, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespacesFromDict(data []KeyNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyKey struct {
	KeyId   *string `json:"keyId"`
	KeyName *string `json:"keyName"`
}

func (p *KeyKey) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyKey{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyKey{}
	} else {
		*p = KeyKey{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["keyId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.KeyId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.KeyId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.KeyId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.KeyId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.KeyId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.KeyId)
				}
			}
		}
		if v, ok := d["keyName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.KeyName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.KeyName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.KeyName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.KeyName)
				}
			}
		}
	}
	return nil
}

func NewKeyKeyFromJson(data string) KeyKey {
	req := KeyKey{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyKeyFromDict(data map[string]interface{}) KeyKey {
	return KeyKey{
		KeyId:   core.CastString(data["keyId"]),
		KeyName: core.CastString(data["keyName"]),
	}
}

func (p KeyKey) ToDict() map[string]interface{} {

	var keyId *string
	if p.KeyId != nil {
		keyId = p.KeyId
	}
	var keyName *string
	if p.KeyName != nil {
		keyName = p.KeyName
	}
	return map[string]interface{}{
		"keyId":   keyId,
		"keyName": keyName,
	}
}

func (p KeyKey) Pointer() *KeyKey {
	return &p
}

func CastKeyKeys(data []interface{}) []KeyKey {
	v := make([]KeyKey, 0)
	for _, d := range data {
		v = append(v, NewKeyKeyFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyKeysFromDict(data []KeyKey) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounterStatistics struct {
	Increase       *int64 `json:"increase"`
	IncreaseAmount *int64 `json:"increaseAmount"`
}

func (p *LimitCounterStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounterStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounterStatistics{}
	} else {
		*p = LimitCounterStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
		if v, ok := d["increaseAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmount)
		}
	}
	return nil
}

func NewLimitCounterStatisticsFromJson(data string) LimitCounterStatistics {
	req := LimitCounterStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterStatisticsFromDict(data map[string]interface{}) LimitCounterStatistics {
	return LimitCounterStatistics{
		Increase:       core.CastInt64(data["increase"]),
		IncreaseAmount: core.CastInt64(data["increaseAmount"]),
	}
}

func (p LimitCounterStatistics) ToDict() map[string]interface{} {

	var increase *int64
	if p.Increase != nil {
		increase = p.Increase
	}
	var increaseAmount *int64
	if p.IncreaseAmount != nil {
		increaseAmount = p.IncreaseAmount
	}
	return map[string]interface{}{
		"increase":       increase,
		"increaseAmount": increaseAmount,
	}
}

func (p LimitCounterStatistics) Pointer() *LimitCounterStatistics {
	return &p
}

func CastLimitCounterStatisticses(data []interface{}) []LimitCounterStatistics {
	v := make([]LimitCounterStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCounterStatisticsesFromDict(data []LimitCounterStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounterCounterDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitCounterCounterDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounterCounterDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounterCounterDistributionStatistics{}
	} else {
		*p = LimitCounterCounterDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitCounterCounterDistributionStatisticsFromJson(data string) LimitCounterCounterDistributionStatistics {
	req := LimitCounterCounterDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterCounterDistributionStatisticsFromDict(data map[string]interface{}) LimitCounterCounterDistributionStatistics {
	return LimitCounterCounterDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LimitCounterCounterDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LimitCounterCounterDistributionStatistics) Pointer() *LimitCounterCounterDistributionStatistics {
	return &p
}

func CastLimitCounterCounterDistributionStatisticses(data []interface{}) []LimitCounterCounterDistributionStatistics {
	v := make([]LimitCounterCounterDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterCounterDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCounterCounterDistributionStatisticsesFromDict(data []LimitCounterCounterDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounterCounterDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *LimitCounterCounterDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounterCounterDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounterCounterDistributionSegment{}
	} else {
		*p = LimitCounterCounterDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLimitCounterCounterDistributionSegmentFromJson(data string) LimitCounterCounterDistributionSegment {
	req := LimitCounterCounterDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterCounterDistributionSegmentFromDict(data map[string]interface{}) LimitCounterCounterDistributionSegment {
	return LimitCounterCounterDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p LimitCounterCounterDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p LimitCounterCounterDistributionSegment) Pointer() *LimitCounterCounterDistributionSegment {
	return &p
}

func CastLimitCounterCounterDistributionSegments(data []interface{}) []LimitCounterCounterDistributionSegment {
	v := make([]LimitCounterCounterDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterCounterDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCounterCounterDistributionSegmentsFromDict(data []LimitCounterCounterDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounterCounterDistribution struct {
	Statistics   *LimitCounterCounterDistributionStatistics `json:"statistics"`
	Distribution []LimitCounterCounterDistributionSegment   `json:"distribution"`
}

func (p *LimitCounterCounterDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounterCounterDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounterCounterDistribution{}
	} else {
		*p = LimitCounterCounterDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitCounterCounterDistributionFromJson(data string) LimitCounterCounterDistribution {
	req := LimitCounterCounterDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterCounterDistributionFromDict(data map[string]interface{}) LimitCounterCounterDistribution {
	return LimitCounterCounterDistribution{
		Statistics:   NewLimitCounterCounterDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLimitCounterCounterDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LimitCounterCounterDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLimitCounterCounterDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LimitCounterCounterDistribution) Pointer() *LimitCounterCounterDistribution {
	return &p
}

func CastLimitCounterCounterDistributions(data []interface{}) []LimitCounterCounterDistribution {
	v := make([]LimitCounterCounterDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterCounterDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCounterCounterDistributionsFromDict(data []LimitCounterCounterDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounterDistributions struct {
	Counter *LimitCounterCounterDistribution `json:"counter"`
}

func (p *LimitCounterDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounterDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounterDistributions{}
	} else {
		*p = LimitCounterDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counter"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Counter)
		}
	}
	return nil
}

func NewLimitCounterDistributionsFromJson(data string) LimitCounterDistributions {
	req := LimitCounterDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterDistributionsFromDict(data map[string]interface{}) LimitCounterDistributions {
	return LimitCounterDistributions{
		Counter: NewLimitCounterCounterDistributionFromDict(core.CastMap(data["counter"])).Pointer(),
	}
}

func (p LimitCounterDistributions) ToDict() map[string]interface{} {

	var counter map[string]interface{}
	if p.Counter != nil {
		counter = p.Counter.ToDict()
	}
	return map[string]interface{}{
		"counter": counter,
	}
}

func (p LimitCounterDistributions) Pointer() *LimitCounterDistributions {
	return &p
}

func CastLimitCounterDistributionses(data []interface{}) []LimitCounterDistributions {
	v := make([]LimitCounterDistributions, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCounterDistributionsesFromDict(data []LimitCounterDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounter struct {
	CounterId     *string                    `json:"counterId"`
	LimitName     *string                    `json:"limitName"`
	CounterName   *string                    `json:"counterName"`
	Statistics    *LimitCounterStatistics    `json:"statistics"`
	Distributions *LimitCounterDistributions `json:"distributions"`
}

func (p *LimitCounter) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounter{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounter{}
	} else {
		*p = LimitCounter{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterId)
				}
			}
		}
		if v, ok := d["limitName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LimitName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LimitName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LimitName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LimitName)
				}
			}
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewLimitCounterFromJson(data string) LimitCounter {
	req := LimitCounter{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterFromDict(data map[string]interface{}) LimitCounter {
	return LimitCounter{
		CounterId:     core.CastString(data["counterId"]),
		LimitName:     core.CastString(data["limitName"]),
		CounterName:   core.CastString(data["counterName"]),
		Statistics:    NewLimitCounterStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewLimitCounterDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p LimitCounter) ToDict() map[string]interface{} {

	var counterId *string
	if p.CounterId != nil {
		counterId = p.CounterId
	}
	var limitName *string
	if p.LimitName != nil {
		limitName = p.LimitName
	}
	var counterName *string
	if p.CounterName != nil {
		counterName = p.CounterName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"counterId":     counterId,
		"limitName":     limitName,
		"counterName":   counterName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p LimitCounter) Pointer() *LimitCounter {
	return &p
}

func CastLimitCounters(data []interface{}) []LimitCounter {
	v := make([]LimitCounter, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCountersFromDict(data []LimitCounter) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelStatistics struct {
	Increase       *int64 `json:"increase"`
	IncreaseAmount *int64 `json:"increaseAmount"`
}

func (p *LimitLimitModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelStatistics{}
	} else {
		*p = LimitLimitModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
		if v, ok := d["increaseAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmount)
		}
	}
	return nil
}

func NewLimitLimitModelStatisticsFromJson(data string) LimitLimitModelStatistics {
	req := LimitLimitModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelStatisticsFromDict(data map[string]interface{}) LimitLimitModelStatistics {
	return LimitLimitModelStatistics{
		Increase:       core.CastInt64(data["increase"]),
		IncreaseAmount: core.CastInt64(data["increaseAmount"]),
	}
}

func (p LimitLimitModelStatistics) ToDict() map[string]interface{} {

	var increase *int64
	if p.Increase != nil {
		increase = p.Increase
	}
	var increaseAmount *int64
	if p.IncreaseAmount != nil {
		increaseAmount = p.IncreaseAmount
	}
	return map[string]interface{}{
		"increase":       increase,
		"increaseAmount": increaseAmount,
	}
}

func (p LimitLimitModelStatistics) Pointer() *LimitLimitModelStatistics {
	return &p
}

func CastLimitLimitModelStatisticses(data []interface{}) []LimitLimitModelStatistics {
	v := make([]LimitLimitModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelStatisticsesFromDict(data []LimitLimitModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitLimitModelIncreaseDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseDistributionStatistics{}
	} else {
		*p = LimitLimitModelIncreaseDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseDistributionStatisticsFromJson(data string) LimitLimitModelIncreaseDistributionStatistics {
	req := LimitLimitModelIncreaseDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseDistributionStatisticsFromDict(data map[string]interface{}) LimitLimitModelIncreaseDistributionStatistics {
	return LimitLimitModelIncreaseDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LimitLimitModelIncreaseDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LimitLimitModelIncreaseDistributionStatistics) Pointer() *LimitLimitModelIncreaseDistributionStatistics {
	return &p
}

func CastLimitLimitModelIncreaseDistributionStatisticses(data []interface{}) []LimitLimitModelIncreaseDistributionStatistics {
	v := make([]LimitLimitModelIncreaseDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseDistributionStatisticsesFromDict(data []LimitLimitModelIncreaseDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseDistributionSegment struct {
	CounterName *string `json:"counterName"`
	Count       *int64  `json:"count"`
}

func (p *LimitLimitModelIncreaseDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseDistributionSegment{}
	} else {
		*p = LimitLimitModelIncreaseDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseDistributionSegmentFromJson(data string) LimitLimitModelIncreaseDistributionSegment {
	req := LimitLimitModelIncreaseDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseDistributionSegmentFromDict(data map[string]interface{}) LimitLimitModelIncreaseDistributionSegment {
	return LimitLimitModelIncreaseDistributionSegment{
		CounterName: core.CastString(data["counterName"]),
		Count:       core.CastInt64(data["count"]),
	}
}

func (p LimitLimitModelIncreaseDistributionSegment) ToDict() map[string]interface{} {

	var counterName *string
	if p.CounterName != nil {
		counterName = p.CounterName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"counterName": counterName,
		"count":       count,
	}
}

func (p LimitLimitModelIncreaseDistributionSegment) Pointer() *LimitLimitModelIncreaseDistributionSegment {
	return &p
}

func CastLimitLimitModelIncreaseDistributionSegments(data []interface{}) []LimitLimitModelIncreaseDistributionSegment {
	v := make([]LimitLimitModelIncreaseDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseDistributionSegmentsFromDict(data []LimitLimitModelIncreaseDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseDistribution struct {
	Statistics   *LimitLimitModelIncreaseDistributionStatistics `json:"statistics"`
	Distribution []LimitLimitModelIncreaseDistributionSegment   `json:"distribution"`
}

func (p *LimitLimitModelIncreaseDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseDistribution{}
	} else {
		*p = LimitLimitModelIncreaseDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseDistributionFromJson(data string) LimitLimitModelIncreaseDistribution {
	req := LimitLimitModelIncreaseDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseDistributionFromDict(data map[string]interface{}) LimitLimitModelIncreaseDistribution {
	return LimitLimitModelIncreaseDistribution{
		Statistics:   NewLimitLimitModelIncreaseDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLimitLimitModelIncreaseDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LimitLimitModelIncreaseDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLimitLimitModelIncreaseDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LimitLimitModelIncreaseDistribution) Pointer() *LimitLimitModelIncreaseDistribution {
	return &p
}

func CastLimitLimitModelIncreaseDistributions(data []interface{}) []LimitLimitModelIncreaseDistribution {
	v := make([]LimitLimitModelIncreaseDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseDistributionsFromDict(data []LimitLimitModelIncreaseDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitLimitModelIncreaseAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountDistributionStatistics{}
	} else {
		*p = LimitLimitModelIncreaseAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountDistributionStatisticsFromJson(data string) LimitLimitModelIncreaseAmountDistributionStatistics {
	req := LimitLimitModelIncreaseAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountDistributionStatisticsFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountDistributionStatistics {
	return LimitLimitModelIncreaseAmountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LimitLimitModelIncreaseAmountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LimitLimitModelIncreaseAmountDistributionStatistics) Pointer() *LimitLimitModelIncreaseAmountDistributionStatistics {
	return &p
}

func CastLimitLimitModelIncreaseAmountDistributionStatisticses(data []interface{}) []LimitLimitModelIncreaseAmountDistributionStatistics {
	v := make([]LimitLimitModelIncreaseAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountDistributionStatisticsesFromDict(data []LimitLimitModelIncreaseAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountDistributionSegment struct {
	CounterName *string `json:"counterName"`
	Sum         *int64  `json:"sum"`
}

func (p *LimitLimitModelIncreaseAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountDistributionSegment{}
	} else {
		*p = LimitLimitModelIncreaseAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountDistributionSegmentFromJson(data string) LimitLimitModelIncreaseAmountDistributionSegment {
	req := LimitLimitModelIncreaseAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountDistributionSegmentFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountDistributionSegment {
	return LimitLimitModelIncreaseAmountDistributionSegment{
		CounterName: core.CastString(data["counterName"]),
		Sum:         core.CastInt64(data["sum"]),
	}
}

func (p LimitLimitModelIncreaseAmountDistributionSegment) ToDict() map[string]interface{} {

	var counterName *string
	if p.CounterName != nil {
		counterName = p.CounterName
	}
	var sum *int64
	if p.Sum != nil {
		sum = p.Sum
	}
	return map[string]interface{}{
		"counterName": counterName,
		"sum":         sum,
	}
}

func (p LimitLimitModelIncreaseAmountDistributionSegment) Pointer() *LimitLimitModelIncreaseAmountDistributionSegment {
	return &p
}

func CastLimitLimitModelIncreaseAmountDistributionSegments(data []interface{}) []LimitLimitModelIncreaseAmountDistributionSegment {
	v := make([]LimitLimitModelIncreaseAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountDistributionSegmentsFromDict(data []LimitLimitModelIncreaseAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountDistribution struct {
	Statistics   *LimitLimitModelIncreaseAmountDistributionStatistics `json:"statistics"`
	Distribution []LimitLimitModelIncreaseAmountDistributionSegment   `json:"distribution"`
}

func (p *LimitLimitModelIncreaseAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountDistribution{}
	} else {
		*p = LimitLimitModelIncreaseAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountDistributionFromJson(data string) LimitLimitModelIncreaseAmountDistribution {
	req := LimitLimitModelIncreaseAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountDistributionFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountDistribution {
	return LimitLimitModelIncreaseAmountDistribution{
		Statistics:   NewLimitLimitModelIncreaseAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLimitLimitModelIncreaseAmountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LimitLimitModelIncreaseAmountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLimitLimitModelIncreaseAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LimitLimitModelIncreaseAmountDistribution) Pointer() *LimitLimitModelIncreaseAmountDistribution {
	return &p
}

func CastLimitLimitModelIncreaseAmountDistributions(data []interface{}) []LimitLimitModelIncreaseAmountDistribution {
	v := make([]LimitLimitModelIncreaseAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountDistributionsFromDict(data []LimitLimitModelIncreaseAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitLimitModelIncreaseByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseByUserDistributionStatistics{}
	} else {
		*p = LimitLimitModelIncreaseByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseByUserDistributionStatisticsFromJson(data string) LimitLimitModelIncreaseByUserDistributionStatistics {
	req := LimitLimitModelIncreaseByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseByUserDistributionStatisticsFromDict(data map[string]interface{}) LimitLimitModelIncreaseByUserDistributionStatistics {
	return LimitLimitModelIncreaseByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LimitLimitModelIncreaseByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LimitLimitModelIncreaseByUserDistributionStatistics) Pointer() *LimitLimitModelIncreaseByUserDistributionStatistics {
	return &p
}

func CastLimitLimitModelIncreaseByUserDistributionStatisticses(data []interface{}) []LimitLimitModelIncreaseByUserDistributionStatistics {
	v := make([]LimitLimitModelIncreaseByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseByUserDistributionStatisticsesFromDict(data []LimitLimitModelIncreaseByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *LimitLimitModelIncreaseByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseByUserDistributionSegment{}
	} else {
		*p = LimitLimitModelIncreaseByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseByUserDistributionSegmentFromJson(data string) LimitLimitModelIncreaseByUserDistributionSegment {
	req := LimitLimitModelIncreaseByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseByUserDistributionSegmentFromDict(data map[string]interface{}) LimitLimitModelIncreaseByUserDistributionSegment {
	return LimitLimitModelIncreaseByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p LimitLimitModelIncreaseByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p LimitLimitModelIncreaseByUserDistributionSegment) Pointer() *LimitLimitModelIncreaseByUserDistributionSegment {
	return &p
}

func CastLimitLimitModelIncreaseByUserDistributionSegments(data []interface{}) []LimitLimitModelIncreaseByUserDistributionSegment {
	v := make([]LimitLimitModelIncreaseByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseByUserDistributionSegmentsFromDict(data []LimitLimitModelIncreaseByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseByUserDistribution struct {
	Statistics   *LimitLimitModelIncreaseByUserDistributionStatistics `json:"statistics"`
	Distribution []LimitLimitModelIncreaseByUserDistributionSegment   `json:"distribution"`
}

func (p *LimitLimitModelIncreaseByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseByUserDistribution{}
	} else {
		*p = LimitLimitModelIncreaseByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseByUserDistributionFromJson(data string) LimitLimitModelIncreaseByUserDistribution {
	req := LimitLimitModelIncreaseByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseByUserDistributionFromDict(data map[string]interface{}) LimitLimitModelIncreaseByUserDistribution {
	return LimitLimitModelIncreaseByUserDistribution{
		Statistics:   NewLimitLimitModelIncreaseByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLimitLimitModelIncreaseByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LimitLimitModelIncreaseByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLimitLimitModelIncreaseByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LimitLimitModelIncreaseByUserDistribution) Pointer() *LimitLimitModelIncreaseByUserDistribution {
	return &p
}

func CastLimitLimitModelIncreaseByUserDistributions(data []interface{}) []LimitLimitModelIncreaseByUserDistribution {
	v := make([]LimitLimitModelIncreaseByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseByUserDistributionsFromDict(data []LimitLimitModelIncreaseByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitLimitModelIncreaseAmountByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountByUserDistributionStatistics{}
	} else {
		*p = LimitLimitModelIncreaseAmountByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountByUserDistributionStatisticsFromJson(data string) LimitLimitModelIncreaseAmountByUserDistributionStatistics {
	req := LimitLimitModelIncreaseAmountByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountByUserDistributionStatisticsFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountByUserDistributionStatistics {
	return LimitLimitModelIncreaseAmountByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LimitLimitModelIncreaseAmountByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LimitLimitModelIncreaseAmountByUserDistributionStatistics) Pointer() *LimitLimitModelIncreaseAmountByUserDistributionStatistics {
	return &p
}

func CastLimitLimitModelIncreaseAmountByUserDistributionStatisticses(data []interface{}) []LimitLimitModelIncreaseAmountByUserDistributionStatistics {
	v := make([]LimitLimitModelIncreaseAmountByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountByUserDistributionStatisticsesFromDict(data []LimitLimitModelIncreaseAmountByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *LimitLimitModelIncreaseAmountByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountByUserDistributionSegment{}
	} else {
		*p = LimitLimitModelIncreaseAmountByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountByUserDistributionSegmentFromJson(data string) LimitLimitModelIncreaseAmountByUserDistributionSegment {
	req := LimitLimitModelIncreaseAmountByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountByUserDistributionSegmentFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountByUserDistributionSegment {
	return LimitLimitModelIncreaseAmountByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p LimitLimitModelIncreaseAmountByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p LimitLimitModelIncreaseAmountByUserDistributionSegment) Pointer() *LimitLimitModelIncreaseAmountByUserDistributionSegment {
	return &p
}

func CastLimitLimitModelIncreaseAmountByUserDistributionSegments(data []interface{}) []LimitLimitModelIncreaseAmountByUserDistributionSegment {
	v := make([]LimitLimitModelIncreaseAmountByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountByUserDistributionSegmentsFromDict(data []LimitLimitModelIncreaseAmountByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountByUserDistribution struct {
	Statistics   *LimitLimitModelIncreaseAmountByUserDistributionStatistics `json:"statistics"`
	Distribution []LimitLimitModelIncreaseAmountByUserDistributionSegment   `json:"distribution"`
}

func (p *LimitLimitModelIncreaseAmountByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountByUserDistribution{}
	} else {
		*p = LimitLimitModelIncreaseAmountByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountByUserDistributionFromJson(data string) LimitLimitModelIncreaseAmountByUserDistribution {
	req := LimitLimitModelIncreaseAmountByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountByUserDistributionFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountByUserDistribution {
	return LimitLimitModelIncreaseAmountByUserDistribution{
		Statistics:   NewLimitLimitModelIncreaseAmountByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLimitLimitModelIncreaseAmountByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LimitLimitModelIncreaseAmountByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLimitLimitModelIncreaseAmountByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LimitLimitModelIncreaseAmountByUserDistribution) Pointer() *LimitLimitModelIncreaseAmountByUserDistribution {
	return &p
}

func CastLimitLimitModelIncreaseAmountByUserDistributions(data []interface{}) []LimitLimitModelIncreaseAmountByUserDistribution {
	v := make([]LimitLimitModelIncreaseAmountByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountByUserDistributionsFromDict(data []LimitLimitModelIncreaseAmountByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelDistributions struct {
	Increase             *LimitLimitModelIncreaseDistribution             `json:"increase"`
	IncreaseAmount       *LimitLimitModelIncreaseAmountDistribution       `json:"increaseAmount"`
	IncreaseByUser       *LimitLimitModelIncreaseByUserDistribution       `json:"increaseByUser"`
	IncreaseAmountByUser *LimitLimitModelIncreaseAmountByUserDistribution `json:"increaseAmountByUser"`
}

func (p *LimitLimitModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelDistributions{}
	} else {
		*p = LimitLimitModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
		if v, ok := d["increaseAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmount)
		}
		if v, ok := d["increaseByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseByUser)
		}
		if v, ok := d["increaseAmountByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmountByUser)
		}
	}
	return nil
}

func NewLimitLimitModelDistributionsFromJson(data string) LimitLimitModelDistributions {
	req := LimitLimitModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelDistributionsFromDict(data map[string]interface{}) LimitLimitModelDistributions {
	return LimitLimitModelDistributions{
		Increase:             NewLimitLimitModelIncreaseDistributionFromDict(core.CastMap(data["increase"])).Pointer(),
		IncreaseAmount:       NewLimitLimitModelIncreaseAmountDistributionFromDict(core.CastMap(data["increaseAmount"])).Pointer(),
		IncreaseByUser:       NewLimitLimitModelIncreaseByUserDistributionFromDict(core.CastMap(data["increaseByUser"])).Pointer(),
		IncreaseAmountByUser: NewLimitLimitModelIncreaseAmountByUserDistributionFromDict(core.CastMap(data["increaseAmountByUser"])).Pointer(),
	}
}

func (p LimitLimitModelDistributions) ToDict() map[string]interface{} {

	var increase map[string]interface{}
	if p.Increase != nil {
		increase = p.Increase.ToDict()
	}
	var increaseAmount map[string]interface{}
	if p.IncreaseAmount != nil {
		increaseAmount = p.IncreaseAmount.ToDict()
	}
	var increaseByUser map[string]interface{}
	if p.IncreaseByUser != nil {
		increaseByUser = p.IncreaseByUser.ToDict()
	}
	var increaseAmountByUser map[string]interface{}
	if p.IncreaseAmountByUser != nil {
		increaseAmountByUser = p.IncreaseAmountByUser.ToDict()
	}
	return map[string]interface{}{
		"increase":             increase,
		"increaseAmount":       increaseAmount,
		"increaseByUser":       increaseByUser,
		"increaseAmountByUser": increaseAmountByUser,
	}
}

func (p LimitLimitModelDistributions) Pointer() *LimitLimitModelDistributions {
	return &p
}

func CastLimitLimitModelDistributionses(data []interface{}) []LimitLimitModelDistributions {
	v := make([]LimitLimitModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelDistributionsesFromDict(data []LimitLimitModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModel struct {
	LimitModelId  *string                       `json:"limitModelId"`
	LimitName     *string                       `json:"limitName"`
	Statistics    *LimitLimitModelStatistics    `json:"statistics"`
	Distributions *LimitLimitModelDistributions `json:"distributions"`
	Counters      []LimitCounter                `json:"counters"`
}

func (p *LimitLimitModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModel{}
	} else {
		*p = LimitLimitModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["limitModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LimitModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LimitModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LimitModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LimitModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LimitModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LimitModelId)
				}
			}
		}
		if v, ok := d["limitName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LimitName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LimitName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LimitName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LimitName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["counters"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Counters)
		}
	}
	return nil
}

func NewLimitLimitModelFromJson(data string) LimitLimitModel {
	req := LimitLimitModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelFromDict(data map[string]interface{}) LimitLimitModel {
	return LimitLimitModel{
		LimitModelId:  core.CastString(data["limitModelId"]),
		LimitName:     core.CastString(data["limitName"]),
		Statistics:    NewLimitLimitModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewLimitLimitModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		Counters:      CastLimitCounters(core.CastArray(data["counters"])),
	}
}

func (p LimitLimitModel) ToDict() map[string]interface{} {

	var limitModelId *string
	if p.LimitModelId != nil {
		limitModelId = p.LimitModelId
	}
	var limitName *string
	if p.LimitName != nil {
		limitName = p.LimitName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var counters []interface{}
	if p.Counters != nil {
		counters = CastLimitCountersFromDict(
			p.Counters,
		)
	}
	return map[string]interface{}{
		"limitModelId":  limitModelId,
		"limitName":     limitName,
		"statistics":    statistics,
		"distributions": distributions,
		"counters":      counters,
	}
}

func (p LimitLimitModel) Pointer() *LimitLimitModel {
	return &p
}

func CastLimitLimitModels(data []interface{}) []LimitLimitModel {
	v := make([]LimitLimitModel, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelsFromDict(data []LimitLimitModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespaceStatistics struct {
	Increase *int64 `json:"increase"`
}

func (p *LimitNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespaceStatistics{}
	} else {
		*p = LimitNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
	}
	return nil
}

func NewLimitNamespaceStatisticsFromJson(data string) LimitNamespaceStatistics {
	req := LimitNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceStatisticsFromDict(data map[string]interface{}) LimitNamespaceStatistics {
	return LimitNamespaceStatistics{
		Increase: core.CastInt64(data["increase"]),
	}
}

func (p LimitNamespaceStatistics) ToDict() map[string]interface{} {

	var increase *int64
	if p.Increase != nil {
		increase = p.Increase
	}
	return map[string]interface{}{
		"increase": increase,
	}
}

func (p LimitNamespaceStatistics) Pointer() *LimitNamespaceStatistics {
	return &p
}

func CastLimitNamespaceStatisticses(data []interface{}) []LimitNamespaceStatistics {
	v := make([]LimitNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespaceStatisticsesFromDict(data []LimitNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespaceIncreaseDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitNamespaceIncreaseDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespaceIncreaseDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespaceIncreaseDistributionStatistics{}
	} else {
		*p = LimitNamespaceIncreaseDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitNamespaceIncreaseDistributionStatisticsFromJson(data string) LimitNamespaceIncreaseDistributionStatistics {
	req := LimitNamespaceIncreaseDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceIncreaseDistributionStatisticsFromDict(data map[string]interface{}) LimitNamespaceIncreaseDistributionStatistics {
	return LimitNamespaceIncreaseDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LimitNamespaceIncreaseDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LimitNamespaceIncreaseDistributionStatistics) Pointer() *LimitNamespaceIncreaseDistributionStatistics {
	return &p
}

func CastLimitNamespaceIncreaseDistributionStatisticses(data []interface{}) []LimitNamespaceIncreaseDistributionStatistics {
	v := make([]LimitNamespaceIncreaseDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceIncreaseDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespaceIncreaseDistributionStatisticsesFromDict(data []LimitNamespaceIncreaseDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespaceIncreaseDistributionSegment struct {
	LimitName *string `json:"limitName"`
	Count     *int64  `json:"count"`
}

func (p *LimitNamespaceIncreaseDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespaceIncreaseDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespaceIncreaseDistributionSegment{}
	} else {
		*p = LimitNamespaceIncreaseDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["limitName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LimitName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LimitName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LimitName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LimitName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLimitNamespaceIncreaseDistributionSegmentFromJson(data string) LimitNamespaceIncreaseDistributionSegment {
	req := LimitNamespaceIncreaseDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceIncreaseDistributionSegmentFromDict(data map[string]interface{}) LimitNamespaceIncreaseDistributionSegment {
	return LimitNamespaceIncreaseDistributionSegment{
		LimitName: core.CastString(data["limitName"]),
		Count:     core.CastInt64(data["count"]),
	}
}

func (p LimitNamespaceIncreaseDistributionSegment) ToDict() map[string]interface{} {

	var limitName *string
	if p.LimitName != nil {
		limitName = p.LimitName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"limitName": limitName,
		"count":     count,
	}
}

func (p LimitNamespaceIncreaseDistributionSegment) Pointer() *LimitNamespaceIncreaseDistributionSegment {
	return &p
}

func CastLimitNamespaceIncreaseDistributionSegments(data []interface{}) []LimitNamespaceIncreaseDistributionSegment {
	v := make([]LimitNamespaceIncreaseDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceIncreaseDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespaceIncreaseDistributionSegmentsFromDict(data []LimitNamespaceIncreaseDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespaceIncreaseDistribution struct {
	Statistics   *LimitNamespaceIncreaseDistributionStatistics `json:"statistics"`
	Distribution []LimitNamespaceIncreaseDistributionSegment   `json:"distribution"`
}

func (p *LimitNamespaceIncreaseDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespaceIncreaseDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespaceIncreaseDistribution{}
	} else {
		*p = LimitNamespaceIncreaseDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitNamespaceIncreaseDistributionFromJson(data string) LimitNamespaceIncreaseDistribution {
	req := LimitNamespaceIncreaseDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceIncreaseDistributionFromDict(data map[string]interface{}) LimitNamespaceIncreaseDistribution {
	return LimitNamespaceIncreaseDistribution{
		Statistics:   NewLimitNamespaceIncreaseDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLimitNamespaceIncreaseDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LimitNamespaceIncreaseDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLimitNamespaceIncreaseDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LimitNamespaceIncreaseDistribution) Pointer() *LimitNamespaceIncreaseDistribution {
	return &p
}

func CastLimitNamespaceIncreaseDistributions(data []interface{}) []LimitNamespaceIncreaseDistribution {
	v := make([]LimitNamespaceIncreaseDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceIncreaseDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespaceIncreaseDistributionsFromDict(data []LimitNamespaceIncreaseDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespaceDistributions struct {
	Increase *LimitNamespaceIncreaseDistribution `json:"increase"`
}

func (p *LimitNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespaceDistributions{}
	} else {
		*p = LimitNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
	}
	return nil
}

func NewLimitNamespaceDistributionsFromJson(data string) LimitNamespaceDistributions {
	req := LimitNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceDistributionsFromDict(data map[string]interface{}) LimitNamespaceDistributions {
	return LimitNamespaceDistributions{
		Increase: NewLimitNamespaceIncreaseDistributionFromDict(core.CastMap(data["increase"])).Pointer(),
	}
}

func (p LimitNamespaceDistributions) ToDict() map[string]interface{} {

	var increase map[string]interface{}
	if p.Increase != nil {
		increase = p.Increase.ToDict()
	}
	return map[string]interface{}{
		"increase": increase,
	}
}

func (p LimitNamespaceDistributions) Pointer() *LimitNamespaceDistributions {
	return &p
}

func CastLimitNamespaceDistributionses(data []interface{}) []LimitNamespaceDistributions {
	v := make([]LimitNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespaceDistributionsesFromDict(data []LimitNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespace struct {
	NamespaceId   *string                      `json:"namespaceId"`
	Year          *int32                       `json:"year"`
	Month         *int32                       `json:"month"`
	Day           *int32                       `json:"day"`
	NamespaceName *string                      `json:"namespaceName"`
	Statistics    *LimitNamespaceStatistics    `json:"statistics"`
	Distributions *LimitNamespaceDistributions `json:"distributions"`
	LimitModels   []LimitLimitModel            `json:"limitModels"`
}

func (p *LimitNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespace{}
	} else {
		*p = LimitNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["limitModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.LimitModels)
		}
	}
	return nil
}

func NewLimitNamespaceFromJson(data string) LimitNamespace {
	req := LimitNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceFromDict(data map[string]interface{}) LimitNamespace {
	return LimitNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewLimitNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewLimitNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		LimitModels:   CastLimitLimitModels(core.CastArray(data["limitModels"])),
	}
}

func (p LimitNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var limitModels []interface{}
	if p.LimitModels != nil {
		limitModels = CastLimitLimitModelsFromDict(
			p.LimitModels,
		)
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
		"limitModels":   limitModels,
	}
}

func (p LimitNamespace) Pointer() *LimitNamespace {
	return &p
}

func CastLimitNamespaces(data []interface{}) []LimitNamespace {
	v := make([]LimitNamespace, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespacesFromDict(data []LimitNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryStatistics struct {
	Draw       *int64 `json:"draw"`
	DrawAmount *int64 `json:"drawAmount"`
}

func (p *LotteryLotteryStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryStatistics{}
	} else {
		*p = LotteryLotteryStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["draw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Draw)
		}
		if v, ok := d["drawAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawAmount)
		}
	}
	return nil
}

func NewLotteryLotteryStatisticsFromJson(data string) LotteryLotteryStatistics {
	req := LotteryLotteryStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryStatisticsFromDict(data map[string]interface{}) LotteryLotteryStatistics {
	return LotteryLotteryStatistics{
		Draw:       core.CastInt64(data["draw"]),
		DrawAmount: core.CastInt64(data["drawAmount"]),
	}
}

func (p LotteryLotteryStatistics) ToDict() map[string]interface{} {

	var draw *int64
	if p.Draw != nil {
		draw = p.Draw
	}
	var drawAmount *int64
	if p.DrawAmount != nil {
		drawAmount = p.DrawAmount
	}
	return map[string]interface{}{
		"draw":       draw,
		"drawAmount": drawAmount,
	}
}

func (p LotteryLotteryStatistics) Pointer() *LotteryLotteryStatistics {
	return &p
}

func CastLotteryLotteryStatisticses(data []interface{}) []LotteryLotteryStatistics {
	v := make([]LotteryLotteryStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryStatisticsesFromDict(data []LotteryLotteryStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryDrawResultDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LotteryLotteryDrawResultDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryDrawResultDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryDrawResultDistributionStatistics{}
	} else {
		*p = LotteryLotteryDrawResultDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLotteryLotteryDrawResultDistributionStatisticsFromJson(data string) LotteryLotteryDrawResultDistributionStatistics {
	req := LotteryLotteryDrawResultDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryDrawResultDistributionStatisticsFromDict(data map[string]interface{}) LotteryLotteryDrawResultDistributionStatistics {
	return LotteryLotteryDrawResultDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LotteryLotteryDrawResultDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LotteryLotteryDrawResultDistributionStatistics) Pointer() *LotteryLotteryDrawResultDistributionStatistics {
	return &p
}

func CastLotteryLotteryDrawResultDistributionStatisticses(data []interface{}) []LotteryLotteryDrawResultDistributionStatistics {
	v := make([]LotteryLotteryDrawResultDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryDrawResultDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryDrawResultDistributionStatisticsesFromDict(data []LotteryLotteryDrawResultDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryDrawResultDistributionSegment struct {
	PrizeId *string `json:"prizeId"`
	Count   *int64  `json:"count"`
}

func (p *LotteryLotteryDrawResultDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryDrawResultDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryDrawResultDistributionSegment{}
	} else {
		*p = LotteryLotteryDrawResultDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["prizeId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.PrizeId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.PrizeId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.PrizeId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.PrizeId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.PrizeId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.PrizeId)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLotteryLotteryDrawResultDistributionSegmentFromJson(data string) LotteryLotteryDrawResultDistributionSegment {
	req := LotteryLotteryDrawResultDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryDrawResultDistributionSegmentFromDict(data map[string]interface{}) LotteryLotteryDrawResultDistributionSegment {
	return LotteryLotteryDrawResultDistributionSegment{
		PrizeId: core.CastString(data["prizeId"]),
		Count:   core.CastInt64(data["count"]),
	}
}

func (p LotteryLotteryDrawResultDistributionSegment) ToDict() map[string]interface{} {

	var prizeId *string
	if p.PrizeId != nil {
		prizeId = p.PrizeId
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"prizeId": prizeId,
		"count":   count,
	}
}

func (p LotteryLotteryDrawResultDistributionSegment) Pointer() *LotteryLotteryDrawResultDistributionSegment {
	return &p
}

func CastLotteryLotteryDrawResultDistributionSegments(data []interface{}) []LotteryLotteryDrawResultDistributionSegment {
	v := make([]LotteryLotteryDrawResultDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryDrawResultDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryDrawResultDistributionSegmentsFromDict(data []LotteryLotteryDrawResultDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryDrawResultDistribution struct {
	Statistics   *LotteryLotteryDrawResultDistributionStatistics `json:"statistics"`
	Distribution []LotteryLotteryDrawResultDistributionSegment   `json:"distribution"`
}

func (p *LotteryLotteryDrawResultDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryDrawResultDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryDrawResultDistribution{}
	} else {
		*p = LotteryLotteryDrawResultDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLotteryLotteryDrawResultDistributionFromJson(data string) LotteryLotteryDrawResultDistribution {
	req := LotteryLotteryDrawResultDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryDrawResultDistributionFromDict(data map[string]interface{}) LotteryLotteryDrawResultDistribution {
	return LotteryLotteryDrawResultDistribution{
		Statistics:   NewLotteryLotteryDrawResultDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLotteryLotteryDrawResultDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LotteryLotteryDrawResultDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLotteryLotteryDrawResultDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LotteryLotteryDrawResultDistribution) Pointer() *LotteryLotteryDrawResultDistribution {
	return &p
}

func CastLotteryLotteryDrawResultDistributions(data []interface{}) []LotteryLotteryDrawResultDistribution {
	v := make([]LotteryLotteryDrawResultDistribution, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryDrawResultDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryDrawResultDistributionsFromDict(data []LotteryLotteryDrawResultDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryDistributions struct {
	DrawResult *LotteryLotteryDrawResultDistribution `json:"drawResult"`
}

func (p *LotteryLotteryDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryDistributions{}
	} else {
		*p = LotteryLotteryDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["drawResult"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawResult)
		}
	}
	return nil
}

func NewLotteryLotteryDistributionsFromJson(data string) LotteryLotteryDistributions {
	req := LotteryLotteryDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryDistributionsFromDict(data map[string]interface{}) LotteryLotteryDistributions {
	return LotteryLotteryDistributions{
		DrawResult: NewLotteryLotteryDrawResultDistributionFromDict(core.CastMap(data["drawResult"])).Pointer(),
	}
}

func (p LotteryLotteryDistributions) ToDict() map[string]interface{} {

	var drawResult map[string]interface{}
	if p.DrawResult != nil {
		drawResult = p.DrawResult.ToDict()
	}
	return map[string]interface{}{
		"drawResult": drawResult,
	}
}

func (p LotteryLotteryDistributions) Pointer() *LotteryLotteryDistributions {
	return &p
}

func CastLotteryLotteryDistributionses(data []interface{}) []LotteryLotteryDistributions {
	v := make([]LotteryLotteryDistributions, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryDistributionsesFromDict(data []LotteryLotteryDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLottery struct {
	LotteryId     *string                      `json:"lotteryId"`
	LotteryName   *string                      `json:"lotteryName"`
	Statistics    *LotteryLotteryStatistics    `json:"statistics"`
	Distributions *LotteryLotteryDistributions `json:"distributions"`
}

func (p *LotteryLottery) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLottery{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLottery{}
	} else {
		*p = LotteryLottery{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["lotteryId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryId)
				}
			}
		}
		if v, ok := d["lotteryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewLotteryLotteryFromJson(data string) LotteryLottery {
	req := LotteryLottery{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryFromDict(data map[string]interface{}) LotteryLottery {
	return LotteryLottery{
		LotteryId:     core.CastString(data["lotteryId"]),
		LotteryName:   core.CastString(data["lotteryName"]),
		Statistics:    NewLotteryLotteryStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewLotteryLotteryDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p LotteryLottery) ToDict() map[string]interface{} {

	var lotteryId *string
	if p.LotteryId != nil {
		lotteryId = p.LotteryId
	}
	var lotteryName *string
	if p.LotteryName != nil {
		lotteryName = p.LotteryName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"lotteryId":     lotteryId,
		"lotteryName":   lotteryName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p LotteryLottery) Pointer() *LotteryLottery {
	return &p
}

func CastLotteryLotteries(data []interface{}) []LotteryLottery {
	v := make([]LotteryLottery, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteriesFromDict(data []LotteryLottery) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceStatistics struct {
	Draw       *int64 `json:"draw"`
	DrawAmount *int64 `json:"drawAmount"`
}

func (p *LotteryNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceStatistics{}
	} else {
		*p = LotteryNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["draw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Draw)
		}
		if v, ok := d["drawAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawAmount)
		}
	}
	return nil
}

func NewLotteryNamespaceStatisticsFromJson(data string) LotteryNamespaceStatistics {
	req := LotteryNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceStatisticsFromDict(data map[string]interface{}) LotteryNamespaceStatistics {
	return LotteryNamespaceStatistics{
		Draw:       core.CastInt64(data["draw"]),
		DrawAmount: core.CastInt64(data["drawAmount"]),
	}
}

func (p LotteryNamespaceStatistics) ToDict() map[string]interface{} {

	var draw *int64
	if p.Draw != nil {
		draw = p.Draw
	}
	var drawAmount *int64
	if p.DrawAmount != nil {
		drawAmount = p.DrawAmount
	}
	return map[string]interface{}{
		"draw":       draw,
		"drawAmount": drawAmount,
	}
}

func (p LotteryNamespaceStatistics) Pointer() *LotteryNamespaceStatistics {
	return &p
}

func CastLotteryNamespaceStatisticses(data []interface{}) []LotteryNamespaceStatistics {
	v := make([]LotteryNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceStatisticsesFromDict(data []LotteryNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LotteryNamespaceDrawDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawDistributionStatistics{}
	} else {
		*p = LotteryNamespaceDrawDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawDistributionStatisticsFromJson(data string) LotteryNamespaceDrawDistributionStatistics {
	req := LotteryNamespaceDrawDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawDistributionStatisticsFromDict(data map[string]interface{}) LotteryNamespaceDrawDistributionStatistics {
	return LotteryNamespaceDrawDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LotteryNamespaceDrawDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LotteryNamespaceDrawDistributionStatistics) Pointer() *LotteryNamespaceDrawDistributionStatistics {
	return &p
}

func CastLotteryNamespaceDrawDistributionStatisticses(data []interface{}) []LotteryNamespaceDrawDistributionStatistics {
	v := make([]LotteryNamespaceDrawDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawDistributionStatisticsesFromDict(data []LotteryNamespaceDrawDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawDistributionSegment struct {
	LotteryName *string `json:"lotteryName"`
	Count       *int64  `json:"count"`
}

func (p *LotteryNamespaceDrawDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawDistributionSegment{}
	} else {
		*p = LotteryNamespaceDrawDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["lotteryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawDistributionSegmentFromJson(data string) LotteryNamespaceDrawDistributionSegment {
	req := LotteryNamespaceDrawDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawDistributionSegmentFromDict(data map[string]interface{}) LotteryNamespaceDrawDistributionSegment {
	return LotteryNamespaceDrawDistributionSegment{
		LotteryName: core.CastString(data["lotteryName"]),
		Count:       core.CastInt64(data["count"]),
	}
}

func (p LotteryNamespaceDrawDistributionSegment) ToDict() map[string]interface{} {

	var lotteryName *string
	if p.LotteryName != nil {
		lotteryName = p.LotteryName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"lotteryName": lotteryName,
		"count":       count,
	}
}

func (p LotteryNamespaceDrawDistributionSegment) Pointer() *LotteryNamespaceDrawDistributionSegment {
	return &p
}

func CastLotteryNamespaceDrawDistributionSegments(data []interface{}) []LotteryNamespaceDrawDistributionSegment {
	v := make([]LotteryNamespaceDrawDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawDistributionSegmentsFromDict(data []LotteryNamespaceDrawDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawDistribution struct {
	Statistics   *LotteryNamespaceDrawDistributionStatistics `json:"statistics"`
	Distribution []LotteryNamespaceDrawDistributionSegment   `json:"distribution"`
}

func (p *LotteryNamespaceDrawDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawDistribution{}
	} else {
		*p = LotteryNamespaceDrawDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawDistributionFromJson(data string) LotteryNamespaceDrawDistribution {
	req := LotteryNamespaceDrawDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawDistributionFromDict(data map[string]interface{}) LotteryNamespaceDrawDistribution {
	return LotteryNamespaceDrawDistribution{
		Statistics:   NewLotteryNamespaceDrawDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLotteryNamespaceDrawDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LotteryNamespaceDrawDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLotteryNamespaceDrawDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LotteryNamespaceDrawDistribution) Pointer() *LotteryNamespaceDrawDistribution {
	return &p
}

func CastLotteryNamespaceDrawDistributions(data []interface{}) []LotteryNamespaceDrawDistribution {
	v := make([]LotteryNamespaceDrawDistribution, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawDistributionsFromDict(data []LotteryNamespaceDrawDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LotteryNamespaceDrawAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountDistributionStatistics{}
	} else {
		*p = LotteryNamespaceDrawAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountDistributionStatisticsFromJson(data string) LotteryNamespaceDrawAmountDistributionStatistics {
	req := LotteryNamespaceDrawAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountDistributionStatisticsFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountDistributionStatistics {
	return LotteryNamespaceDrawAmountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LotteryNamespaceDrawAmountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LotteryNamespaceDrawAmountDistributionStatistics) Pointer() *LotteryNamespaceDrawAmountDistributionStatistics {
	return &p
}

func CastLotteryNamespaceDrawAmountDistributionStatisticses(data []interface{}) []LotteryNamespaceDrawAmountDistributionStatistics {
	v := make([]LotteryNamespaceDrawAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountDistributionStatisticsesFromDict(data []LotteryNamespaceDrawAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountDistributionSegment struct {
	LotteryName *string `json:"lotteryName"`
	Sum         *int64  `json:"sum"`
}

func (p *LotteryNamespaceDrawAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountDistributionSegment{}
	} else {
		*p = LotteryNamespaceDrawAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["lotteryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountDistributionSegmentFromJson(data string) LotteryNamespaceDrawAmountDistributionSegment {
	req := LotteryNamespaceDrawAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountDistributionSegmentFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountDistributionSegment {
	return LotteryNamespaceDrawAmountDistributionSegment{
		LotteryName: core.CastString(data["lotteryName"]),
		Sum:         core.CastInt64(data["sum"]),
	}
}

func (p LotteryNamespaceDrawAmountDistributionSegment) ToDict() map[string]interface{} {

	var lotteryName *string
	if p.LotteryName != nil {
		lotteryName = p.LotteryName
	}
	var sum *int64
	if p.Sum != nil {
		sum = p.Sum
	}
	return map[string]interface{}{
		"lotteryName": lotteryName,
		"sum":         sum,
	}
}

func (p LotteryNamespaceDrawAmountDistributionSegment) Pointer() *LotteryNamespaceDrawAmountDistributionSegment {
	return &p
}

func CastLotteryNamespaceDrawAmountDistributionSegments(data []interface{}) []LotteryNamespaceDrawAmountDistributionSegment {
	v := make([]LotteryNamespaceDrawAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountDistributionSegmentsFromDict(data []LotteryNamespaceDrawAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountDistribution struct {
	Statistics   *LotteryNamespaceDrawAmountDistributionStatistics `json:"statistics"`
	Distribution []LotteryNamespaceDrawAmountDistributionSegment   `json:"distribution"`
}

func (p *LotteryNamespaceDrawAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountDistribution{}
	} else {
		*p = LotteryNamespaceDrawAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountDistributionFromJson(data string) LotteryNamespaceDrawAmountDistribution {
	req := LotteryNamespaceDrawAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountDistributionFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountDistribution {
	return LotteryNamespaceDrawAmountDistribution{
		Statistics:   NewLotteryNamespaceDrawAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLotteryNamespaceDrawAmountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LotteryNamespaceDrawAmountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLotteryNamespaceDrawAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LotteryNamespaceDrawAmountDistribution) Pointer() *LotteryNamespaceDrawAmountDistribution {
	return &p
}

func CastLotteryNamespaceDrawAmountDistributions(data []interface{}) []LotteryNamespaceDrawAmountDistribution {
	v := make([]LotteryNamespaceDrawAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountDistributionsFromDict(data []LotteryNamespaceDrawAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LotteryNamespaceDrawByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawByUserDistributionStatistics{}
	} else {
		*p = LotteryNamespaceDrawByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawByUserDistributionStatisticsFromJson(data string) LotteryNamespaceDrawByUserDistributionStatistics {
	req := LotteryNamespaceDrawByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawByUserDistributionStatisticsFromDict(data map[string]interface{}) LotteryNamespaceDrawByUserDistributionStatistics {
	return LotteryNamespaceDrawByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LotteryNamespaceDrawByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LotteryNamespaceDrawByUserDistributionStatistics) Pointer() *LotteryNamespaceDrawByUserDistributionStatistics {
	return &p
}

func CastLotteryNamespaceDrawByUserDistributionStatisticses(data []interface{}) []LotteryNamespaceDrawByUserDistributionStatistics {
	v := make([]LotteryNamespaceDrawByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawByUserDistributionStatisticsesFromDict(data []LotteryNamespaceDrawByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *LotteryNamespaceDrawByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawByUserDistributionSegment{}
	} else {
		*p = LotteryNamespaceDrawByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawByUserDistributionSegmentFromJson(data string) LotteryNamespaceDrawByUserDistributionSegment {
	req := LotteryNamespaceDrawByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawByUserDistributionSegmentFromDict(data map[string]interface{}) LotteryNamespaceDrawByUserDistributionSegment {
	return LotteryNamespaceDrawByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p LotteryNamespaceDrawByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p LotteryNamespaceDrawByUserDistributionSegment) Pointer() *LotteryNamespaceDrawByUserDistributionSegment {
	return &p
}

func CastLotteryNamespaceDrawByUserDistributionSegments(data []interface{}) []LotteryNamespaceDrawByUserDistributionSegment {
	v := make([]LotteryNamespaceDrawByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawByUserDistributionSegmentsFromDict(data []LotteryNamespaceDrawByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawByUserDistribution struct {
	Statistics   *LotteryNamespaceDrawByUserDistributionStatistics `json:"statistics"`
	Distribution []LotteryNamespaceDrawByUserDistributionSegment   `json:"distribution"`
}

func (p *LotteryNamespaceDrawByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawByUserDistribution{}
	} else {
		*p = LotteryNamespaceDrawByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawByUserDistributionFromJson(data string) LotteryNamespaceDrawByUserDistribution {
	req := LotteryNamespaceDrawByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawByUserDistributionFromDict(data map[string]interface{}) LotteryNamespaceDrawByUserDistribution {
	return LotteryNamespaceDrawByUserDistribution{
		Statistics:   NewLotteryNamespaceDrawByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLotteryNamespaceDrawByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LotteryNamespaceDrawByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLotteryNamespaceDrawByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LotteryNamespaceDrawByUserDistribution) Pointer() *LotteryNamespaceDrawByUserDistribution {
	return &p
}

func CastLotteryNamespaceDrawByUserDistributions(data []interface{}) []LotteryNamespaceDrawByUserDistribution {
	v := make([]LotteryNamespaceDrawByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawByUserDistributionsFromDict(data []LotteryNamespaceDrawByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LotteryNamespaceDrawAmountByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountByUserDistributionStatistics{}
	} else {
		*p = LotteryNamespaceDrawAmountByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountByUserDistributionStatisticsFromJson(data string) LotteryNamespaceDrawAmountByUserDistributionStatistics {
	req := LotteryNamespaceDrawAmountByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountByUserDistributionStatisticsFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountByUserDistributionStatistics {
	return LotteryNamespaceDrawAmountByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p LotteryNamespaceDrawAmountByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p LotteryNamespaceDrawAmountByUserDistributionStatistics) Pointer() *LotteryNamespaceDrawAmountByUserDistributionStatistics {
	return &p
}

func CastLotteryNamespaceDrawAmountByUserDistributionStatisticses(data []interface{}) []LotteryNamespaceDrawAmountByUserDistributionStatistics {
	v := make([]LotteryNamespaceDrawAmountByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountByUserDistributionStatisticsesFromDict(data []LotteryNamespaceDrawAmountByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *LotteryNamespaceDrawAmountByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountByUserDistributionSegment{}
	} else {
		*p = LotteryNamespaceDrawAmountByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountByUserDistributionSegmentFromJson(data string) LotteryNamespaceDrawAmountByUserDistributionSegment {
	req := LotteryNamespaceDrawAmountByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountByUserDistributionSegmentFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountByUserDistributionSegment {
	return LotteryNamespaceDrawAmountByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p LotteryNamespaceDrawAmountByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p LotteryNamespaceDrawAmountByUserDistributionSegment) Pointer() *LotteryNamespaceDrawAmountByUserDistributionSegment {
	return &p
}

func CastLotteryNamespaceDrawAmountByUserDistributionSegments(data []interface{}) []LotteryNamespaceDrawAmountByUserDistributionSegment {
	v := make([]LotteryNamespaceDrawAmountByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountByUserDistributionSegmentsFromDict(data []LotteryNamespaceDrawAmountByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountByUserDistribution struct {
	Statistics   *LotteryNamespaceDrawAmountByUserDistributionStatistics `json:"statistics"`
	Distribution []LotteryNamespaceDrawAmountByUserDistributionSegment   `json:"distribution"`
}

func (p *LotteryNamespaceDrawAmountByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountByUserDistribution{}
	} else {
		*p = LotteryNamespaceDrawAmountByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountByUserDistributionFromJson(data string) LotteryNamespaceDrawAmountByUserDistribution {
	req := LotteryNamespaceDrawAmountByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountByUserDistributionFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountByUserDistribution {
	return LotteryNamespaceDrawAmountByUserDistribution{
		Statistics:   NewLotteryNamespaceDrawAmountByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastLotteryNamespaceDrawAmountByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p LotteryNamespaceDrawAmountByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastLotteryNamespaceDrawAmountByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p LotteryNamespaceDrawAmountByUserDistribution) Pointer() *LotteryNamespaceDrawAmountByUserDistribution {
	return &p
}

func CastLotteryNamespaceDrawAmountByUserDistributions(data []interface{}) []LotteryNamespaceDrawAmountByUserDistribution {
	v := make([]LotteryNamespaceDrawAmountByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountByUserDistributionsFromDict(data []LotteryNamespaceDrawAmountByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDistributions struct {
	Draw             *LotteryNamespaceDrawDistribution             `json:"draw"`
	DrawAmount       *LotteryNamespaceDrawAmountDistribution       `json:"drawAmount"`
	DrawByUser       *LotteryNamespaceDrawByUserDistribution       `json:"drawByUser"`
	DrawAmountByUser *LotteryNamespaceDrawAmountByUserDistribution `json:"drawAmountByUser"`
}

func (p *LotteryNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDistributions{}
	} else {
		*p = LotteryNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["draw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Draw)
		}
		if v, ok := d["drawAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawAmount)
		}
		if v, ok := d["drawByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawByUser)
		}
		if v, ok := d["drawAmountByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawAmountByUser)
		}
	}
	return nil
}

func NewLotteryNamespaceDistributionsFromJson(data string) LotteryNamespaceDistributions {
	req := LotteryNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDistributionsFromDict(data map[string]interface{}) LotteryNamespaceDistributions {
	return LotteryNamespaceDistributions{
		Draw:             NewLotteryNamespaceDrawDistributionFromDict(core.CastMap(data["draw"])).Pointer(),
		DrawAmount:       NewLotteryNamespaceDrawAmountDistributionFromDict(core.CastMap(data["drawAmount"])).Pointer(),
		DrawByUser:       NewLotteryNamespaceDrawByUserDistributionFromDict(core.CastMap(data["drawByUser"])).Pointer(),
		DrawAmountByUser: NewLotteryNamespaceDrawAmountByUserDistributionFromDict(core.CastMap(data["drawAmountByUser"])).Pointer(),
	}
}

func (p LotteryNamespaceDistributions) ToDict() map[string]interface{} {

	var draw map[string]interface{}
	if p.Draw != nil {
		draw = p.Draw.ToDict()
	}
	var drawAmount map[string]interface{}
	if p.DrawAmount != nil {
		drawAmount = p.DrawAmount.ToDict()
	}
	var drawByUser map[string]interface{}
	if p.DrawByUser != nil {
		drawByUser = p.DrawByUser.ToDict()
	}
	var drawAmountByUser map[string]interface{}
	if p.DrawAmountByUser != nil {
		drawAmountByUser = p.DrawAmountByUser.ToDict()
	}
	return map[string]interface{}{
		"draw":             draw,
		"drawAmount":       drawAmount,
		"drawByUser":       drawByUser,
		"drawAmountByUser": drawAmountByUser,
	}
}

func (p LotteryNamespaceDistributions) Pointer() *LotteryNamespaceDistributions {
	return &p
}

func CastLotteryNamespaceDistributionses(data []interface{}) []LotteryNamespaceDistributions {
	v := make([]LotteryNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDistributionsesFromDict(data []LotteryNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespace struct {
	NamespaceId   *string                        `json:"namespaceId"`
	Year          *int32                         `json:"year"`
	Month         *int32                         `json:"month"`
	Day           *int32                         `json:"day"`
	NamespaceName *string                        `json:"namespaceName"`
	Statistics    *LotteryNamespaceStatistics    `json:"statistics"`
	Distributions *LotteryNamespaceDistributions `json:"distributions"`
	Lotteries     []LotteryLottery               `json:"lotteries"`
}

func (p *LotteryNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespace{}
	} else {
		*p = LotteryNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["lotteries"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Lotteries)
		}
	}
	return nil
}

func NewLotteryNamespaceFromJson(data string) LotteryNamespace {
	req := LotteryNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceFromDict(data map[string]interface{}) LotteryNamespace {
	return LotteryNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewLotteryNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewLotteryNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		Lotteries:     CastLotteryLotteries(core.CastArray(data["lotteries"])),
	}
}

func (p LotteryNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var lotteries []interface{}
	if p.Lotteries != nil {
		lotteries = CastLotteryLotteriesFromDict(
			p.Lotteries,
		)
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
		"lotteries":     lotteries,
	}
}

func (p LotteryNamespace) Pointer() *LotteryNamespace {
	return &p
}

func CastLotteryNamespaces(data []interface{}) []LotteryNamespace {
	v := make([]LotteryNamespace, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespacesFromDict(data []LotteryNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryModel struct {
	LotteryModelId *string `json:"lotteryModelId"`
	LotteryName    *string `json:"lotteryName"`
}

func (p *LotteryLotteryModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryModel{}
	} else {
		*p = LotteryLotteryModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["lotteryModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryModelId)
				}
			}
		}
		if v, ok := d["lotteryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryName)
				}
			}
		}
	}
	return nil
}

func NewLotteryLotteryModelFromJson(data string) LotteryLotteryModel {
	req := LotteryLotteryModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryModelFromDict(data map[string]interface{}) LotteryLotteryModel {
	return LotteryLotteryModel{
		LotteryModelId: core.CastString(data["lotteryModelId"]),
		LotteryName:    core.CastString(data["lotteryName"]),
	}
}

func (p LotteryLotteryModel) ToDict() map[string]interface{} {

	var lotteryModelId *string
	if p.LotteryModelId != nil {
		lotteryModelId = p.LotteryModelId
	}
	var lotteryName *string
	if p.LotteryName != nil {
		lotteryName = p.LotteryName
	}
	return map[string]interface{}{
		"lotteryModelId": lotteryModelId,
		"lotteryName":    lotteryName,
	}
}

func (p LotteryLotteryModel) Pointer() *LotteryLotteryModel {
	return &p
}

func CastLotteryLotteryModels(data []interface{}) []LotteryLotteryModel {
	v := make([]LotteryLotteryModel, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryModelsFromDict(data []LotteryLotteryModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceStatistics struct {
	CreateGathering *int64   `json:"createGathering"`
	Matchmaking     *int64   `json:"matchmaking"`
	CompleteRate    *float32 `json:"completeRate"`
}

func (p *MatchmakingNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceStatistics{}
	} else {
		*p = MatchmakingNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["createGathering"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CreateGathering)
		}
		if v, ok := d["matchmaking"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Matchmaking)
		}
		if v, ok := d["completeRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CompleteRate)
		}
	}
	return nil
}

func NewMatchmakingNamespaceStatisticsFromJson(data string) MatchmakingNamespaceStatistics {
	req := MatchmakingNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceStatisticsFromDict(data map[string]interface{}) MatchmakingNamespaceStatistics {
	return MatchmakingNamespaceStatistics{
		CreateGathering: core.CastInt64(data["createGathering"]),
		Matchmaking:     core.CastInt64(data["matchmaking"]),
		CompleteRate:    core.CastFloat32(data["completeRate"]),
	}
}

func (p MatchmakingNamespaceStatistics) ToDict() map[string]interface{} {

	var createGathering *int64
	if p.CreateGathering != nil {
		createGathering = p.CreateGathering
	}
	var matchmaking *int64
	if p.Matchmaking != nil {
		matchmaking = p.Matchmaking
	}
	var completeRate *float32
	if p.CompleteRate != nil {
		completeRate = p.CompleteRate
	}
	return map[string]interface{}{
		"createGathering": createGathering,
		"matchmaking":     matchmaking,
		"completeRate":    completeRate,
	}
}

func (p MatchmakingNamespaceStatistics) Pointer() *MatchmakingNamespaceStatistics {
	return &p
}

func CastMatchmakingNamespaceStatisticses(data []interface{}) []MatchmakingNamespaceStatistics {
	v := make([]MatchmakingNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceStatisticsesFromDict(data []MatchmakingNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceResultDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MatchmakingNamespaceResultDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceResultDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceResultDistributionStatistics{}
	} else {
		*p = MatchmakingNamespaceResultDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMatchmakingNamespaceResultDistributionStatisticsFromJson(data string) MatchmakingNamespaceResultDistributionStatistics {
	req := MatchmakingNamespaceResultDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceResultDistributionStatisticsFromDict(data map[string]interface{}) MatchmakingNamespaceResultDistributionStatistics {
	return MatchmakingNamespaceResultDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MatchmakingNamespaceResultDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MatchmakingNamespaceResultDistributionStatistics) Pointer() *MatchmakingNamespaceResultDistributionStatistics {
	return &p
}

func CastMatchmakingNamespaceResultDistributionStatisticses(data []interface{}) []MatchmakingNamespaceResultDistributionStatistics {
	v := make([]MatchmakingNamespaceResultDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceResultDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceResultDistributionStatisticsesFromDict(data []MatchmakingNamespaceResultDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceResultDistributionSegment struct {
	Result *string `json:"result"`
	Count  *int64  `json:"count"`
}

func (p *MatchmakingNamespaceResultDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceResultDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceResultDistributionSegment{}
	} else {
		*p = MatchmakingNamespaceResultDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["result"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Result = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Result = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Result = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Result = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Result = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Result)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMatchmakingNamespaceResultDistributionSegmentFromJson(data string) MatchmakingNamespaceResultDistributionSegment {
	req := MatchmakingNamespaceResultDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceResultDistributionSegmentFromDict(data map[string]interface{}) MatchmakingNamespaceResultDistributionSegment {
	return MatchmakingNamespaceResultDistributionSegment{
		Result: core.CastString(data["result"]),
		Count:  core.CastInt64(data["count"]),
	}
}

func (p MatchmakingNamespaceResultDistributionSegment) ToDict() map[string]interface{} {

	var result *string
	if p.Result != nil {
		result = p.Result
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"result": result,
		"count":  count,
	}
}

func (p MatchmakingNamespaceResultDistributionSegment) Pointer() *MatchmakingNamespaceResultDistributionSegment {
	return &p
}

func CastMatchmakingNamespaceResultDistributionSegments(data []interface{}) []MatchmakingNamespaceResultDistributionSegment {
	v := make([]MatchmakingNamespaceResultDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceResultDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceResultDistributionSegmentsFromDict(data []MatchmakingNamespaceResultDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceResultDistribution struct {
	Statistics   *MatchmakingNamespaceResultDistributionStatistics `json:"statistics"`
	Distribution []MatchmakingNamespaceResultDistributionSegment   `json:"distribution"`
}

func (p *MatchmakingNamespaceResultDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceResultDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceResultDistribution{}
	} else {
		*p = MatchmakingNamespaceResultDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMatchmakingNamespaceResultDistributionFromJson(data string) MatchmakingNamespaceResultDistribution {
	req := MatchmakingNamespaceResultDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceResultDistributionFromDict(data map[string]interface{}) MatchmakingNamespaceResultDistribution {
	return MatchmakingNamespaceResultDistribution{
		Statistics:   NewMatchmakingNamespaceResultDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMatchmakingNamespaceResultDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MatchmakingNamespaceResultDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMatchmakingNamespaceResultDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MatchmakingNamespaceResultDistribution) Pointer() *MatchmakingNamespaceResultDistribution {
	return &p
}

func CastMatchmakingNamespaceResultDistributions(data []interface{}) []MatchmakingNamespaceResultDistribution {
	v := make([]MatchmakingNamespaceResultDistribution, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceResultDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceResultDistributionsFromDict(data []MatchmakingNamespaceResultDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics{}
	} else {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticsFromJson(data string) MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics {
	req := MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticsFromDict(data map[string]interface{}) MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics {
	return MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics) Pointer() *MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics {
	return &p
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticses(data []interface{}) []MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics {
	v := make([]MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticsesFromDict(data []MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceWaitElapsedSecondsDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *MatchmakingNamespaceWaitElapsedSecondsDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionSegment{}
	} else {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionSegmentFromJson(data string) MatchmakingNamespaceWaitElapsedSecondsDistributionSegment {
	req := MatchmakingNamespaceWaitElapsedSecondsDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionSegmentFromDict(data map[string]interface{}) MatchmakingNamespaceWaitElapsedSecondsDistributionSegment {
	return MatchmakingNamespaceWaitElapsedSecondsDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistributionSegment) Pointer() *MatchmakingNamespaceWaitElapsedSecondsDistributionSegment {
	return &p
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributionSegments(data []interface{}) []MatchmakingNamespaceWaitElapsedSecondsDistributionSegment {
	v := make([]MatchmakingNamespaceWaitElapsedSecondsDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceWaitElapsedSecondsDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributionSegmentsFromDict(data []MatchmakingNamespaceWaitElapsedSecondsDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceWaitElapsedSecondsDistribution struct {
	Statistics   *MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics `json:"statistics"`
	Distribution []MatchmakingNamespaceWaitElapsedSecondsDistributionSegment   `json:"distribution"`
}

func (p *MatchmakingNamespaceWaitElapsedSecondsDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistribution{}
	} else {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionFromJson(data string) MatchmakingNamespaceWaitElapsedSecondsDistribution {
	req := MatchmakingNamespaceWaitElapsedSecondsDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionFromDict(data map[string]interface{}) MatchmakingNamespaceWaitElapsedSecondsDistribution {
	return MatchmakingNamespaceWaitElapsedSecondsDistribution{
		Statistics:   NewMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMatchmakingNamespaceWaitElapsedSecondsDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMatchmakingNamespaceWaitElapsedSecondsDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistribution) Pointer() *MatchmakingNamespaceWaitElapsedSecondsDistribution {
	return &p
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributions(data []interface{}) []MatchmakingNamespaceWaitElapsedSecondsDistribution {
	v := make([]MatchmakingNamespaceWaitElapsedSecondsDistribution, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceWaitElapsedSecondsDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributionsFromDict(data []MatchmakingNamespaceWaitElapsedSecondsDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceDistributions struct {
	Result             *MatchmakingNamespaceResultDistribution             `json:"result"`
	WaitElapsedSeconds *MatchmakingNamespaceWaitElapsedSecondsDistribution `json:"waitElapsedSeconds"`
}

func (p *MatchmakingNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceDistributions{}
	} else {
		*p = MatchmakingNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["result"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Result)
		}
		if v, ok := d["waitElapsedSeconds"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.WaitElapsedSeconds)
		}
	}
	return nil
}

func NewMatchmakingNamespaceDistributionsFromJson(data string) MatchmakingNamespaceDistributions {
	req := MatchmakingNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceDistributionsFromDict(data map[string]interface{}) MatchmakingNamespaceDistributions {
	return MatchmakingNamespaceDistributions{
		Result:             NewMatchmakingNamespaceResultDistributionFromDict(core.CastMap(data["result"])).Pointer(),
		WaitElapsedSeconds: NewMatchmakingNamespaceWaitElapsedSecondsDistributionFromDict(core.CastMap(data["waitElapsedSeconds"])).Pointer(),
	}
}

func (p MatchmakingNamespaceDistributions) ToDict() map[string]interface{} {

	var result map[string]interface{}
	if p.Result != nil {
		result = p.Result.ToDict()
	}
	var waitElapsedSeconds map[string]interface{}
	if p.WaitElapsedSeconds != nil {
		waitElapsedSeconds = p.WaitElapsedSeconds.ToDict()
	}
	return map[string]interface{}{
		"result":             result,
		"waitElapsedSeconds": waitElapsedSeconds,
	}
}

func (p MatchmakingNamespaceDistributions) Pointer() *MatchmakingNamespaceDistributions {
	return &p
}

func CastMatchmakingNamespaceDistributionses(data []interface{}) []MatchmakingNamespaceDistributions {
	v := make([]MatchmakingNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceDistributionsesFromDict(data []MatchmakingNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespace struct {
	NamespaceId   *string                            `json:"namespaceId"`
	Year          *int32                             `json:"year"`
	Month         *int32                             `json:"month"`
	Day           *int32                             `json:"day"`
	NamespaceName *string                            `json:"namespaceName"`
	Statistics    *MatchmakingNamespaceStatistics    `json:"statistics"`
	Distributions *MatchmakingNamespaceDistributions `json:"distributions"`
}

func (p *MatchmakingNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespace{}
	} else {
		*p = MatchmakingNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewMatchmakingNamespaceFromJson(data string) MatchmakingNamespace {
	req := MatchmakingNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceFromDict(data map[string]interface{}) MatchmakingNamespace {
	return MatchmakingNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewMatchmakingNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewMatchmakingNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p MatchmakingNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p MatchmakingNamespace) Pointer() *MatchmakingNamespace {
	return &p
}

func CastMatchmakingNamespaces(data []interface{}) []MatchmakingNamespace {
	v := make([]MatchmakingNamespace, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespacesFromDict(data []MatchmakingNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionCounterCounterDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MissionCounterCounterDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionCounterCounterDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionCounterCounterDistributionStatistics{}
	} else {
		*p = MissionCounterCounterDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMissionCounterCounterDistributionStatisticsFromJson(data string) MissionCounterCounterDistributionStatistics {
	req := MissionCounterCounterDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionCounterCounterDistributionStatisticsFromDict(data map[string]interface{}) MissionCounterCounterDistributionStatistics {
	return MissionCounterCounterDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MissionCounterCounterDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MissionCounterCounterDistributionStatistics) Pointer() *MissionCounterCounterDistributionStatistics {
	return &p
}

func CastMissionCounterCounterDistributionStatisticses(data []interface{}) []MissionCounterCounterDistributionStatistics {
	v := make([]MissionCounterCounterDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionCounterCounterDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionCounterCounterDistributionStatisticsesFromDict(data []MissionCounterCounterDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionCounterCounterDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *MissionCounterCounterDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionCounterCounterDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionCounterCounterDistributionSegment{}
	} else {
		*p = MissionCounterCounterDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMissionCounterCounterDistributionSegmentFromJson(data string) MissionCounterCounterDistributionSegment {
	req := MissionCounterCounterDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionCounterCounterDistributionSegmentFromDict(data map[string]interface{}) MissionCounterCounterDistributionSegment {
	return MissionCounterCounterDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p MissionCounterCounterDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p MissionCounterCounterDistributionSegment) Pointer() *MissionCounterCounterDistributionSegment {
	return &p
}

func CastMissionCounterCounterDistributionSegments(data []interface{}) []MissionCounterCounterDistributionSegment {
	v := make([]MissionCounterCounterDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMissionCounterCounterDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionCounterCounterDistributionSegmentsFromDict(data []MissionCounterCounterDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionCounterCounterDistribution struct {
	Statistics   *MissionCounterCounterDistributionStatistics `json:"statistics"`
	Distribution []MissionCounterCounterDistributionSegment   `json:"distribution"`
}

func (p *MissionCounterCounterDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionCounterCounterDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionCounterCounterDistribution{}
	} else {
		*p = MissionCounterCounterDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMissionCounterCounterDistributionFromJson(data string) MissionCounterCounterDistribution {
	req := MissionCounterCounterDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionCounterCounterDistributionFromDict(data map[string]interface{}) MissionCounterCounterDistribution {
	return MissionCounterCounterDistribution{
		Statistics:   NewMissionCounterCounterDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMissionCounterCounterDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MissionCounterCounterDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMissionCounterCounterDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MissionCounterCounterDistribution) Pointer() *MissionCounterCounterDistribution {
	return &p
}

func CastMissionCounterCounterDistributions(data []interface{}) []MissionCounterCounterDistribution {
	v := make([]MissionCounterCounterDistribution, 0)
	for _, d := range data {
		v = append(v, NewMissionCounterCounterDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionCounterCounterDistributionsFromDict(data []MissionCounterCounterDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionCounterDistributions struct {
	Counter *MissionCounterCounterDistribution `json:"counter"`
}

func (p *MissionCounterDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionCounterDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionCounterDistributions{}
	} else {
		*p = MissionCounterDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counter"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Counter)
		}
	}
	return nil
}

func NewMissionCounterDistributionsFromJson(data string) MissionCounterDistributions {
	req := MissionCounterDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionCounterDistributionsFromDict(data map[string]interface{}) MissionCounterDistributions {
	return MissionCounterDistributions{
		Counter: NewMissionCounterCounterDistributionFromDict(core.CastMap(data["counter"])).Pointer(),
	}
}

func (p MissionCounterDistributions) ToDict() map[string]interface{} {

	var counter map[string]interface{}
	if p.Counter != nil {
		counter = p.Counter.ToDict()
	}
	return map[string]interface{}{
		"counter": counter,
	}
}

func (p MissionCounterDistributions) Pointer() *MissionCounterDistributions {
	return &p
}

func CastMissionCounterDistributionses(data []interface{}) []MissionCounterDistributions {
	v := make([]MissionCounterDistributions, 0)
	for _, d := range data {
		v = append(v, NewMissionCounterDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionCounterDistributionsesFromDict(data []MissionCounterDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionCounter struct {
	CounterId     *string                      `json:"counterId"`
	CounterName   *string                      `json:"counterName"`
	Distributions *MissionCounterDistributions `json:"distributions"`
}

func (p *MissionCounter) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionCounter{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionCounter{}
	} else {
		*p = MissionCounter{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterId)
				}
			}
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewMissionCounterFromJson(data string) MissionCounter {
	req := MissionCounter{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionCounterFromDict(data map[string]interface{}) MissionCounter {
	return MissionCounter{
		CounterId:     core.CastString(data["counterId"]),
		CounterName:   core.CastString(data["counterName"]),
		Distributions: NewMissionCounterDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p MissionCounter) ToDict() map[string]interface{} {

	var counterId *string
	if p.CounterId != nil {
		counterId = p.CounterId
	}
	var counterName *string
	if p.CounterName != nil {
		counterName = p.CounterName
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"counterId":     counterId,
		"counterName":   counterName,
		"distributions": distributions,
	}
}

func (p MissionCounter) Pointer() *MissionCounter {
	return &p
}

func CastMissionCounters(data []interface{}) []MissionCounter {
	v := make([]MissionCounter, 0)
	for _, d := range data {
		v = append(v, NewMissionCounterFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionCountersFromDict(data []MissionCounter) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModelStatistics struct {
	Receive *int64 `json:"receive"`
}

func (p *MissionMissionGroupModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModelStatistics{}
	} else {
		*p = MissionMissionGroupModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["receive"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Receive)
		}
	}
	return nil
}

func NewMissionMissionGroupModelStatisticsFromJson(data string) MissionMissionGroupModelStatistics {
	req := MissionMissionGroupModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelStatisticsFromDict(data map[string]interface{}) MissionMissionGroupModelStatistics {
	return MissionMissionGroupModelStatistics{
		Receive: core.CastInt64(data["receive"]),
	}
}

func (p MissionMissionGroupModelStatistics) ToDict() map[string]interface{} {

	var receive *int64
	if p.Receive != nil {
		receive = p.Receive
	}
	return map[string]interface{}{
		"receive": receive,
	}
}

func (p MissionMissionGroupModelStatistics) Pointer() *MissionMissionGroupModelStatistics {
	return &p
}

func CastMissionMissionGroupModelStatisticses(data []interface{}) []MissionMissionGroupModelStatistics {
	v := make([]MissionMissionGroupModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelStatisticsesFromDict(data []MissionMissionGroupModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModelReceiveDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MissionMissionGroupModelReceiveDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModelReceiveDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModelReceiveDistributionStatistics{}
	} else {
		*p = MissionMissionGroupModelReceiveDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMissionMissionGroupModelReceiveDistributionStatisticsFromJson(data string) MissionMissionGroupModelReceiveDistributionStatistics {
	req := MissionMissionGroupModelReceiveDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelReceiveDistributionStatisticsFromDict(data map[string]interface{}) MissionMissionGroupModelReceiveDistributionStatistics {
	return MissionMissionGroupModelReceiveDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MissionMissionGroupModelReceiveDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MissionMissionGroupModelReceiveDistributionStatistics) Pointer() *MissionMissionGroupModelReceiveDistributionStatistics {
	return &p
}

func CastMissionMissionGroupModelReceiveDistributionStatisticses(data []interface{}) []MissionMissionGroupModelReceiveDistributionStatistics {
	v := make([]MissionMissionGroupModelReceiveDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelReceiveDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelReceiveDistributionStatisticsesFromDict(data []MissionMissionGroupModelReceiveDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModelReceiveDistributionSegment struct {
	MissionTaskName *string `json:"missionTaskName"`
	Count           *int64  `json:"count"`
}

func (p *MissionMissionGroupModelReceiveDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModelReceiveDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModelReceiveDistributionSegment{}
	} else {
		*p = MissionMissionGroupModelReceiveDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["missionTaskName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionTaskName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionTaskName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionTaskName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionTaskName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMissionMissionGroupModelReceiveDistributionSegmentFromJson(data string) MissionMissionGroupModelReceiveDistributionSegment {
	req := MissionMissionGroupModelReceiveDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelReceiveDistributionSegmentFromDict(data map[string]interface{}) MissionMissionGroupModelReceiveDistributionSegment {
	return MissionMissionGroupModelReceiveDistributionSegment{
		MissionTaskName: core.CastString(data["missionTaskName"]),
		Count:           core.CastInt64(data["count"]),
	}
}

func (p MissionMissionGroupModelReceiveDistributionSegment) ToDict() map[string]interface{} {

	var missionTaskName *string
	if p.MissionTaskName != nil {
		missionTaskName = p.MissionTaskName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"missionTaskName": missionTaskName,
		"count":           count,
	}
}

func (p MissionMissionGroupModelReceiveDistributionSegment) Pointer() *MissionMissionGroupModelReceiveDistributionSegment {
	return &p
}

func CastMissionMissionGroupModelReceiveDistributionSegments(data []interface{}) []MissionMissionGroupModelReceiveDistributionSegment {
	v := make([]MissionMissionGroupModelReceiveDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelReceiveDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelReceiveDistributionSegmentsFromDict(data []MissionMissionGroupModelReceiveDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModelReceiveDistribution struct {
	Statistics   *MissionMissionGroupModelReceiveDistributionStatistics `json:"statistics"`
	Distribution []MissionMissionGroupModelReceiveDistributionSegment   `json:"distribution"`
}

func (p *MissionMissionGroupModelReceiveDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModelReceiveDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModelReceiveDistribution{}
	} else {
		*p = MissionMissionGroupModelReceiveDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMissionMissionGroupModelReceiveDistributionFromJson(data string) MissionMissionGroupModelReceiveDistribution {
	req := MissionMissionGroupModelReceiveDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelReceiveDistributionFromDict(data map[string]interface{}) MissionMissionGroupModelReceiveDistribution {
	return MissionMissionGroupModelReceiveDistribution{
		Statistics:   NewMissionMissionGroupModelReceiveDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMissionMissionGroupModelReceiveDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MissionMissionGroupModelReceiveDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMissionMissionGroupModelReceiveDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MissionMissionGroupModelReceiveDistribution) Pointer() *MissionMissionGroupModelReceiveDistribution {
	return &p
}

func CastMissionMissionGroupModelReceiveDistributions(data []interface{}) []MissionMissionGroupModelReceiveDistribution {
	v := make([]MissionMissionGroupModelReceiveDistribution, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelReceiveDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelReceiveDistributionsFromDict(data []MissionMissionGroupModelReceiveDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModelDistributions struct {
	Receive *MissionMissionGroupModelReceiveDistribution `json:"receive"`
}

func (p *MissionMissionGroupModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModelDistributions{}
	} else {
		*p = MissionMissionGroupModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["receive"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Receive)
		}
	}
	return nil
}

func NewMissionMissionGroupModelDistributionsFromJson(data string) MissionMissionGroupModelDistributions {
	req := MissionMissionGroupModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelDistributionsFromDict(data map[string]interface{}) MissionMissionGroupModelDistributions {
	return MissionMissionGroupModelDistributions{
		Receive: NewMissionMissionGroupModelReceiveDistributionFromDict(core.CastMap(data["receive"])).Pointer(),
	}
}

func (p MissionMissionGroupModelDistributions) ToDict() map[string]interface{} {

	var receive map[string]interface{}
	if p.Receive != nil {
		receive = p.Receive.ToDict()
	}
	return map[string]interface{}{
		"receive": receive,
	}
}

func (p MissionMissionGroupModelDistributions) Pointer() *MissionMissionGroupModelDistributions {
	return &p
}

func CastMissionMissionGroupModelDistributionses(data []interface{}) []MissionMissionGroupModelDistributions {
	v := make([]MissionMissionGroupModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelDistributionsesFromDict(data []MissionMissionGroupModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModel struct {
	MissionGroupModelId *string                                `json:"missionGroupModelId"`
	MissionGroupName    *string                                `json:"missionGroupName"`
	Statistics          *MissionMissionGroupModelStatistics    `json:"statistics"`
	Distributions       *MissionMissionGroupModelDistributions `json:"distributions"`
}

func (p *MissionMissionGroupModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModel{}
	} else {
		*p = MissionMissionGroupModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["missionGroupModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionGroupModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionGroupModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionGroupModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionGroupModelId)
				}
			}
		}
		if v, ok := d["missionGroupName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionGroupName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionGroupName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionGroupName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionGroupName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewMissionMissionGroupModelFromJson(data string) MissionMissionGroupModel {
	req := MissionMissionGroupModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelFromDict(data map[string]interface{}) MissionMissionGroupModel {
	return MissionMissionGroupModel{
		MissionGroupModelId: core.CastString(data["missionGroupModelId"]),
		MissionGroupName:    core.CastString(data["missionGroupName"]),
		Statistics:          NewMissionMissionGroupModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions:       NewMissionMissionGroupModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p MissionMissionGroupModel) ToDict() map[string]interface{} {

	var missionGroupModelId *string
	if p.MissionGroupModelId != nil {
		missionGroupModelId = p.MissionGroupModelId
	}
	var missionGroupName *string
	if p.MissionGroupName != nil {
		missionGroupName = p.MissionGroupName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"missionGroupModelId": missionGroupModelId,
		"missionGroupName":    missionGroupName,
		"statistics":          statistics,
		"distributions":       distributions,
	}
}

func (p MissionMissionGroupModel) Pointer() *MissionMissionGroupModel {
	return &p
}

func CastMissionMissionGroupModels(data []interface{}) []MissionMissionGroupModel {
	v := make([]MissionMissionGroupModel, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelsFromDict(data []MissionMissionGroupModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionTaskModel struct {
	MissionTaskModelId *string `json:"missionTaskModelId"`
	MissionTaskName    *string `json:"missionTaskName"`
}

func (p *MissionMissionTaskModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionTaskModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionTaskModel{}
	} else {
		*p = MissionMissionTaskModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["missionTaskModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionTaskModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionTaskModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionTaskModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionTaskModelId)
				}
			}
		}
		if v, ok := d["missionTaskName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionTaskName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionTaskName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionTaskName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionTaskName)
				}
			}
		}
	}
	return nil
}

func NewMissionMissionTaskModelFromJson(data string) MissionMissionTaskModel {
	req := MissionMissionTaskModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionTaskModelFromDict(data map[string]interface{}) MissionMissionTaskModel {
	return MissionMissionTaskModel{
		MissionTaskModelId: core.CastString(data["missionTaskModelId"]),
		MissionTaskName:    core.CastString(data["missionTaskName"]),
	}
}

func (p MissionMissionTaskModel) ToDict() map[string]interface{} {

	var missionTaskModelId *string
	if p.MissionTaskModelId != nil {
		missionTaskModelId = p.MissionTaskModelId
	}
	var missionTaskName *string
	if p.MissionTaskName != nil {
		missionTaskName = p.MissionTaskName
	}
	return map[string]interface{}{
		"missionTaskModelId": missionTaskModelId,
		"missionTaskName":    missionTaskName,
	}
}

func (p MissionMissionTaskModel) Pointer() *MissionMissionTaskModel {
	return &p
}

func CastMissionMissionTaskModels(data []interface{}) []MissionMissionTaskModel {
	v := make([]MissionMissionTaskModel, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionTaskModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionTaskModelsFromDict(data []MissionMissionTaskModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceStatistics struct {
	Increase       *int64 `json:"increase"`
	IncreaseAmount *int64 `json:"increaseAmount"`
	Receive        *int64 `json:"receive"`
}

func (p *MissionNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceStatistics{}
	} else {
		*p = MissionNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
		if v, ok := d["increaseAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmount)
		}
		if v, ok := d["receive"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Receive)
		}
	}
	return nil
}

func NewMissionNamespaceStatisticsFromJson(data string) MissionNamespaceStatistics {
	req := MissionNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceStatisticsFromDict(data map[string]interface{}) MissionNamespaceStatistics {
	return MissionNamespaceStatistics{
		Increase:       core.CastInt64(data["increase"]),
		IncreaseAmount: core.CastInt64(data["increaseAmount"]),
		Receive:        core.CastInt64(data["receive"]),
	}
}

func (p MissionNamespaceStatistics) ToDict() map[string]interface{} {

	var increase *int64
	if p.Increase != nil {
		increase = p.Increase
	}
	var increaseAmount *int64
	if p.IncreaseAmount != nil {
		increaseAmount = p.IncreaseAmount
	}
	var receive *int64
	if p.Receive != nil {
		receive = p.Receive
	}
	return map[string]interface{}{
		"increase":       increase,
		"increaseAmount": increaseAmount,
		"receive":        receive,
	}
}

func (p MissionNamespaceStatistics) Pointer() *MissionNamespaceStatistics {
	return &p
}

func CastMissionNamespaceStatisticses(data []interface{}) []MissionNamespaceStatistics {
	v := make([]MissionNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceStatisticsesFromDict(data []MissionNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MissionNamespaceIncreaseDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseDistributionStatistics{}
	} else {
		*p = MissionNamespaceIncreaseDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseDistributionStatisticsFromJson(data string) MissionNamespaceIncreaseDistributionStatistics {
	req := MissionNamespaceIncreaseDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseDistributionStatisticsFromDict(data map[string]interface{}) MissionNamespaceIncreaseDistributionStatistics {
	return MissionNamespaceIncreaseDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MissionNamespaceIncreaseDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MissionNamespaceIncreaseDistributionStatistics) Pointer() *MissionNamespaceIncreaseDistributionStatistics {
	return &p
}

func CastMissionNamespaceIncreaseDistributionStatisticses(data []interface{}) []MissionNamespaceIncreaseDistributionStatistics {
	v := make([]MissionNamespaceIncreaseDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseDistributionStatisticsesFromDict(data []MissionNamespaceIncreaseDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseDistributionSegment struct {
	CounterName *string `json:"counterName"`
	Count       *int64  `json:"count"`
}

func (p *MissionNamespaceIncreaseDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseDistributionSegment{}
	} else {
		*p = MissionNamespaceIncreaseDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseDistributionSegmentFromJson(data string) MissionNamespaceIncreaseDistributionSegment {
	req := MissionNamespaceIncreaseDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseDistributionSegmentFromDict(data map[string]interface{}) MissionNamespaceIncreaseDistributionSegment {
	return MissionNamespaceIncreaseDistributionSegment{
		CounterName: core.CastString(data["counterName"]),
		Count:       core.CastInt64(data["count"]),
	}
}

func (p MissionNamespaceIncreaseDistributionSegment) ToDict() map[string]interface{} {

	var counterName *string
	if p.CounterName != nil {
		counterName = p.CounterName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"counterName": counterName,
		"count":       count,
	}
}

func (p MissionNamespaceIncreaseDistributionSegment) Pointer() *MissionNamespaceIncreaseDistributionSegment {
	return &p
}

func CastMissionNamespaceIncreaseDistributionSegments(data []interface{}) []MissionNamespaceIncreaseDistributionSegment {
	v := make([]MissionNamespaceIncreaseDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseDistributionSegmentsFromDict(data []MissionNamespaceIncreaseDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseDistribution struct {
	Statistics   *MissionNamespaceIncreaseDistributionStatistics `json:"statistics"`
	Distribution []MissionNamespaceIncreaseDistributionSegment   `json:"distribution"`
}

func (p *MissionNamespaceIncreaseDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseDistribution{}
	} else {
		*p = MissionNamespaceIncreaseDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseDistributionFromJson(data string) MissionNamespaceIncreaseDistribution {
	req := MissionNamespaceIncreaseDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseDistributionFromDict(data map[string]interface{}) MissionNamespaceIncreaseDistribution {
	return MissionNamespaceIncreaseDistribution{
		Statistics:   NewMissionNamespaceIncreaseDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMissionNamespaceIncreaseDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MissionNamespaceIncreaseDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMissionNamespaceIncreaseDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MissionNamespaceIncreaseDistribution) Pointer() *MissionNamespaceIncreaseDistribution {
	return &p
}

func CastMissionNamespaceIncreaseDistributions(data []interface{}) []MissionNamespaceIncreaseDistribution {
	v := make([]MissionNamespaceIncreaseDistribution, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseDistributionsFromDict(data []MissionNamespaceIncreaseDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MissionNamespaceIncreaseAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseAmountDistributionStatistics{}
	} else {
		*p = MissionNamespaceIncreaseAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseAmountDistributionStatisticsFromJson(data string) MissionNamespaceIncreaseAmountDistributionStatistics {
	req := MissionNamespaceIncreaseAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseAmountDistributionStatisticsFromDict(data map[string]interface{}) MissionNamespaceIncreaseAmountDistributionStatistics {
	return MissionNamespaceIncreaseAmountDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MissionNamespaceIncreaseAmountDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MissionNamespaceIncreaseAmountDistributionStatistics) Pointer() *MissionNamespaceIncreaseAmountDistributionStatistics {
	return &p
}

func CastMissionNamespaceIncreaseAmountDistributionStatisticses(data []interface{}) []MissionNamespaceIncreaseAmountDistributionStatistics {
	v := make([]MissionNamespaceIncreaseAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseAmountDistributionStatisticsesFromDict(data []MissionNamespaceIncreaseAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseAmountDistributionSegment struct {
	CounterName *string `json:"counterName"`
	Sum         *int64  `json:"sum"`
}

func (p *MissionNamespaceIncreaseAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseAmountDistributionSegment{}
	} else {
		*p = MissionNamespaceIncreaseAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseAmountDistributionSegmentFromJson(data string) MissionNamespaceIncreaseAmountDistributionSegment {
	req := MissionNamespaceIncreaseAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseAmountDistributionSegmentFromDict(data map[string]interface{}) MissionNamespaceIncreaseAmountDistributionSegment {
	return MissionNamespaceIncreaseAmountDistributionSegment{
		CounterName: core.CastString(data["counterName"]),
		Sum:         core.CastInt64(data["sum"]),
	}
}

func (p MissionNamespaceIncreaseAmountDistributionSegment) ToDict() map[string]interface{} {

	var counterName *string
	if p.CounterName != nil {
		counterName = p.CounterName
	}
	var sum *int64
	if p.Sum != nil {
		sum = p.Sum
	}
	return map[string]interface{}{
		"counterName": counterName,
		"sum":         sum,
	}
}

func (p MissionNamespaceIncreaseAmountDistributionSegment) Pointer() *MissionNamespaceIncreaseAmountDistributionSegment {
	return &p
}

func CastMissionNamespaceIncreaseAmountDistributionSegments(data []interface{}) []MissionNamespaceIncreaseAmountDistributionSegment {
	v := make([]MissionNamespaceIncreaseAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseAmountDistributionSegmentsFromDict(data []MissionNamespaceIncreaseAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseAmountDistribution struct {
	Statistics   *MissionNamespaceIncreaseAmountDistributionStatistics `json:"statistics"`
	Distribution []MissionNamespaceIncreaseAmountDistributionSegment   `json:"distribution"`
}

func (p *MissionNamespaceIncreaseAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseAmountDistribution{}
	} else {
		*p = MissionNamespaceIncreaseAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseAmountDistributionFromJson(data string) MissionNamespaceIncreaseAmountDistribution {
	req := MissionNamespaceIncreaseAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseAmountDistributionFromDict(data map[string]interface{}) MissionNamespaceIncreaseAmountDistribution {
	return MissionNamespaceIncreaseAmountDistribution{
		Statistics:   NewMissionNamespaceIncreaseAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMissionNamespaceIncreaseAmountDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MissionNamespaceIncreaseAmountDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMissionNamespaceIncreaseAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MissionNamespaceIncreaseAmountDistribution) Pointer() *MissionNamespaceIncreaseAmountDistribution {
	return &p
}

func CastMissionNamespaceIncreaseAmountDistributions(data []interface{}) []MissionNamespaceIncreaseAmountDistribution {
	v := make([]MissionNamespaceIncreaseAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseAmountDistributionsFromDict(data []MissionNamespaceIncreaseAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceReceiveDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MissionNamespaceReceiveDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceReceiveDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceReceiveDistributionStatistics{}
	} else {
		*p = MissionNamespaceReceiveDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMissionNamespaceReceiveDistributionStatisticsFromJson(data string) MissionNamespaceReceiveDistributionStatistics {
	req := MissionNamespaceReceiveDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceReceiveDistributionStatisticsFromDict(data map[string]interface{}) MissionNamespaceReceiveDistributionStatistics {
	return MissionNamespaceReceiveDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MissionNamespaceReceiveDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MissionNamespaceReceiveDistributionStatistics) Pointer() *MissionNamespaceReceiveDistributionStatistics {
	return &p
}

func CastMissionNamespaceReceiveDistributionStatisticses(data []interface{}) []MissionNamespaceReceiveDistributionStatistics {
	v := make([]MissionNamespaceReceiveDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceReceiveDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceReceiveDistributionStatisticsesFromDict(data []MissionNamespaceReceiveDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceReceiveDistributionSegment struct {
	MissionGroupName *string `json:"missionGroupName"`
	Count            *int64  `json:"count"`
}

func (p *MissionNamespaceReceiveDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceReceiveDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceReceiveDistributionSegment{}
	} else {
		*p = MissionNamespaceReceiveDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["missionGroupName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionGroupName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionGroupName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionGroupName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionGroupName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMissionNamespaceReceiveDistributionSegmentFromJson(data string) MissionNamespaceReceiveDistributionSegment {
	req := MissionNamespaceReceiveDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceReceiveDistributionSegmentFromDict(data map[string]interface{}) MissionNamespaceReceiveDistributionSegment {
	return MissionNamespaceReceiveDistributionSegment{
		MissionGroupName: core.CastString(data["missionGroupName"]),
		Count:            core.CastInt64(data["count"]),
	}
}

func (p MissionNamespaceReceiveDistributionSegment) ToDict() map[string]interface{} {

	var missionGroupName *string
	if p.MissionGroupName != nil {
		missionGroupName = p.MissionGroupName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"missionGroupName": missionGroupName,
		"count":            count,
	}
}

func (p MissionNamespaceReceiveDistributionSegment) Pointer() *MissionNamespaceReceiveDistributionSegment {
	return &p
}

func CastMissionNamespaceReceiveDistributionSegments(data []interface{}) []MissionNamespaceReceiveDistributionSegment {
	v := make([]MissionNamespaceReceiveDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceReceiveDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceReceiveDistributionSegmentsFromDict(data []MissionNamespaceReceiveDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceReceiveDistribution struct {
	Statistics   *MissionNamespaceReceiveDistributionStatistics `json:"statistics"`
	Distribution []MissionNamespaceReceiveDistributionSegment   `json:"distribution"`
}

func (p *MissionNamespaceReceiveDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceReceiveDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceReceiveDistribution{}
	} else {
		*p = MissionNamespaceReceiveDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMissionNamespaceReceiveDistributionFromJson(data string) MissionNamespaceReceiveDistribution {
	req := MissionNamespaceReceiveDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceReceiveDistributionFromDict(data map[string]interface{}) MissionNamespaceReceiveDistribution {
	return MissionNamespaceReceiveDistribution{
		Statistics:   NewMissionNamespaceReceiveDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMissionNamespaceReceiveDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MissionNamespaceReceiveDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMissionNamespaceReceiveDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MissionNamespaceReceiveDistribution) Pointer() *MissionNamespaceReceiveDistribution {
	return &p
}

func CastMissionNamespaceReceiveDistributions(data []interface{}) []MissionNamespaceReceiveDistribution {
	v := make([]MissionNamespaceReceiveDistribution, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceReceiveDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceReceiveDistributionsFromDict(data []MissionNamespaceReceiveDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceDistributions struct {
	Increase       *MissionNamespaceIncreaseDistribution       `json:"increase"`
	IncreaseAmount *MissionNamespaceIncreaseAmountDistribution `json:"increaseAmount"`
	Receive        *MissionNamespaceReceiveDistribution        `json:"receive"`
}

func (p *MissionNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceDistributions{}
	} else {
		*p = MissionNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
		if v, ok := d["increaseAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmount)
		}
		if v, ok := d["receive"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Receive)
		}
	}
	return nil
}

func NewMissionNamespaceDistributionsFromJson(data string) MissionNamespaceDistributions {
	req := MissionNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceDistributionsFromDict(data map[string]interface{}) MissionNamespaceDistributions {
	return MissionNamespaceDistributions{
		Increase:       NewMissionNamespaceIncreaseDistributionFromDict(core.CastMap(data["increase"])).Pointer(),
		IncreaseAmount: NewMissionNamespaceIncreaseAmountDistributionFromDict(core.CastMap(data["increaseAmount"])).Pointer(),
		Receive:        NewMissionNamespaceReceiveDistributionFromDict(core.CastMap(data["receive"])).Pointer(),
	}
}

func (p MissionNamespaceDistributions) ToDict() map[string]interface{} {

	var increase map[string]interface{}
	if p.Increase != nil {
		increase = p.Increase.ToDict()
	}
	var increaseAmount map[string]interface{}
	if p.IncreaseAmount != nil {
		increaseAmount = p.IncreaseAmount.ToDict()
	}
	var receive map[string]interface{}
	if p.Receive != nil {
		receive = p.Receive.ToDict()
	}
	return map[string]interface{}{
		"increase":       increase,
		"increaseAmount": increaseAmount,
		"receive":        receive,
	}
}

func (p MissionNamespaceDistributions) Pointer() *MissionNamespaceDistributions {
	return &p
}

func CastMissionNamespaceDistributionses(data []interface{}) []MissionNamespaceDistributions {
	v := make([]MissionNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceDistributionsesFromDict(data []MissionNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespace struct {
	NamespaceId        *string                        `json:"namespaceId"`
	Year               *int32                         `json:"year"`
	Month              *int32                         `json:"month"`
	Day                *int32                         `json:"day"`
	NamespaceName      *string                        `json:"namespaceName"`
	Statistics         *MissionNamespaceStatistics    `json:"statistics"`
	Distributions      *MissionNamespaceDistributions `json:"distributions"`
	MissionGroupModels []MissionMissionGroupModel     `json:"missionGroupModels"`
	Counters           []MissionCounter               `json:"counters"`
}

func (p *MissionNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespace{}
	} else {
		*p = MissionNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["missionGroupModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.MissionGroupModels)
		}
		if v, ok := d["counters"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Counters)
		}
	}
	return nil
}

func NewMissionNamespaceFromJson(data string) MissionNamespace {
	req := MissionNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceFromDict(data map[string]interface{}) MissionNamespace {
	return MissionNamespace{
		NamespaceId:        core.CastString(data["namespaceId"]),
		Year:               core.CastInt32(data["year"]),
		Month:              core.CastInt32(data["month"]),
		Day:                core.CastInt32(data["day"]),
		NamespaceName:      core.CastString(data["namespaceName"]),
		Statistics:         NewMissionNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions:      NewMissionNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		MissionGroupModels: CastMissionMissionGroupModels(core.CastArray(data["missionGroupModels"])),
		Counters:           CastMissionCounters(core.CastArray(data["counters"])),
	}
}

func (p MissionNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var missionGroupModels []interface{}
	if p.MissionGroupModels != nil {
		missionGroupModels = CastMissionMissionGroupModelsFromDict(
			p.MissionGroupModels,
		)
	}
	var counters []interface{}
	if p.Counters != nil {
		counters = CastMissionCountersFromDict(
			p.Counters,
		)
	}
	return map[string]interface{}{
		"namespaceId":        namespaceId,
		"year":               year,
		"month":              month,
		"day":                day,
		"namespaceName":      namespaceName,
		"statistics":         statistics,
		"distributions":      distributions,
		"missionGroupModels": missionGroupModels,
		"counters":           counters,
	}
}

func (p MissionNamespace) Pointer() *MissionNamespace {
	return &p
}

func CastMissionNamespaces(data []interface{}) []MissionNamespace {
	v := make([]MissionNamespace, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespacesFromDict(data []MissionNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletStatistics struct {
	Deposit        *int64 `json:"deposit"`
	DepositAmount  *int64 `json:"depositAmount"`
	Withdraw       *int64 `json:"withdraw"`
	WithdrawAmount *int64 `json:"withdrawAmount"`
	Revenue        *int64 `json:"revenue"`
}

func (p *MoneyWalletStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletStatistics{}
	} else {
		*p = MoneyWalletStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["deposit"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Deposit)
		}
		if v, ok := d["depositAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DepositAmount)
		}
		if v, ok := d["withdraw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Withdraw)
		}
		if v, ok := d["withdrawAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.WithdrawAmount)
		}
		if v, ok := d["revenue"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Revenue)
		}
	}
	return nil
}

func NewMoneyWalletStatisticsFromJson(data string) MoneyWalletStatistics {
	req := MoneyWalletStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletStatisticsFromDict(data map[string]interface{}) MoneyWalletStatistics {
	return MoneyWalletStatistics{
		Deposit:        core.CastInt64(data["deposit"]),
		DepositAmount:  core.CastInt64(data["depositAmount"]),
		Withdraw:       core.CastInt64(data["withdraw"]),
		WithdrawAmount: core.CastInt64(data["withdrawAmount"]),
		Revenue:        core.CastInt64(data["revenue"]),
	}
}

func (p MoneyWalletStatistics) ToDict() map[string]interface{} {

	var deposit *int64
	if p.Deposit != nil {
		deposit = p.Deposit
	}
	var depositAmount *int64
	if p.DepositAmount != nil {
		depositAmount = p.DepositAmount
	}
	var withdraw *int64
	if p.Withdraw != nil {
		withdraw = p.Withdraw
	}
	var withdrawAmount *int64
	if p.WithdrawAmount != nil {
		withdrawAmount = p.WithdrawAmount
	}
	var revenue *int64
	if p.Revenue != nil {
		revenue = p.Revenue
	}
	return map[string]interface{}{
		"deposit":        deposit,
		"depositAmount":  depositAmount,
		"withdraw":       withdraw,
		"withdrawAmount": withdrawAmount,
		"revenue":        revenue,
	}
}

func (p MoneyWalletStatistics) Pointer() *MoneyWalletStatistics {
	return &p
}

func CastMoneyWalletStatisticses(data []interface{}) []MoneyWalletStatistics {
	v := make([]MoneyWalletStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletStatisticsesFromDict(data []MoneyWalletStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletFreeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyWalletFreeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletFreeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletFreeDistributionStatistics{}
	} else {
		*p = MoneyWalletFreeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyWalletFreeDistributionStatisticsFromJson(data string) MoneyWalletFreeDistributionStatistics {
	req := MoneyWalletFreeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletFreeDistributionStatisticsFromDict(data map[string]interface{}) MoneyWalletFreeDistributionStatistics {
	return MoneyWalletFreeDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MoneyWalletFreeDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MoneyWalletFreeDistributionStatistics) Pointer() *MoneyWalletFreeDistributionStatistics {
	return &p
}

func CastMoneyWalletFreeDistributionStatisticses(data []interface{}) []MoneyWalletFreeDistributionStatistics {
	v := make([]MoneyWalletFreeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletFreeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletFreeDistributionStatisticsesFromDict(data []MoneyWalletFreeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletFreeDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *MoneyWalletFreeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletFreeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletFreeDistributionSegment{}
	} else {
		*p = MoneyWalletFreeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyWalletFreeDistributionSegmentFromJson(data string) MoneyWalletFreeDistributionSegment {
	req := MoneyWalletFreeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletFreeDistributionSegmentFromDict(data map[string]interface{}) MoneyWalletFreeDistributionSegment {
	return MoneyWalletFreeDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p MoneyWalletFreeDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p MoneyWalletFreeDistributionSegment) Pointer() *MoneyWalletFreeDistributionSegment {
	return &p
}

func CastMoneyWalletFreeDistributionSegments(data []interface{}) []MoneyWalletFreeDistributionSegment {
	v := make([]MoneyWalletFreeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletFreeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletFreeDistributionSegmentsFromDict(data []MoneyWalletFreeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletFreeDistribution struct {
	Statistics   *MoneyWalletFreeDistributionStatistics `json:"statistics"`
	Distribution []MoneyWalletFreeDistributionSegment   `json:"distribution"`
}

func (p *MoneyWalletFreeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletFreeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletFreeDistribution{}
	} else {
		*p = MoneyWalletFreeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyWalletFreeDistributionFromJson(data string) MoneyWalletFreeDistribution {
	req := MoneyWalletFreeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletFreeDistributionFromDict(data map[string]interface{}) MoneyWalletFreeDistribution {
	return MoneyWalletFreeDistribution{
		Statistics:   NewMoneyWalletFreeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMoneyWalletFreeDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MoneyWalletFreeDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMoneyWalletFreeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MoneyWalletFreeDistribution) Pointer() *MoneyWalletFreeDistribution {
	return &p
}

func CastMoneyWalletFreeDistributions(data []interface{}) []MoneyWalletFreeDistribution {
	v := make([]MoneyWalletFreeDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletFreeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletFreeDistributionsFromDict(data []MoneyWalletFreeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletPaidDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyWalletPaidDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletPaidDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletPaidDistributionStatistics{}
	} else {
		*p = MoneyWalletPaidDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyWalletPaidDistributionStatisticsFromJson(data string) MoneyWalletPaidDistributionStatistics {
	req := MoneyWalletPaidDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletPaidDistributionStatisticsFromDict(data map[string]interface{}) MoneyWalletPaidDistributionStatistics {
	return MoneyWalletPaidDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MoneyWalletPaidDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MoneyWalletPaidDistributionStatistics) Pointer() *MoneyWalletPaidDistributionStatistics {
	return &p
}

func CastMoneyWalletPaidDistributionStatisticses(data []interface{}) []MoneyWalletPaidDistributionStatistics {
	v := make([]MoneyWalletPaidDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletPaidDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletPaidDistributionStatisticsesFromDict(data []MoneyWalletPaidDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletPaidDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *MoneyWalletPaidDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletPaidDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletPaidDistributionSegment{}
	} else {
		*p = MoneyWalletPaidDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyWalletPaidDistributionSegmentFromJson(data string) MoneyWalletPaidDistributionSegment {
	req := MoneyWalletPaidDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletPaidDistributionSegmentFromDict(data map[string]interface{}) MoneyWalletPaidDistributionSegment {
	return MoneyWalletPaidDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p MoneyWalletPaidDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p MoneyWalletPaidDistributionSegment) Pointer() *MoneyWalletPaidDistributionSegment {
	return &p
}

func CastMoneyWalletPaidDistributionSegments(data []interface{}) []MoneyWalletPaidDistributionSegment {
	v := make([]MoneyWalletPaidDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletPaidDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletPaidDistributionSegmentsFromDict(data []MoneyWalletPaidDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletPaidDistribution struct {
	Statistics   *MoneyWalletPaidDistributionStatistics `json:"statistics"`
	Distribution []MoneyWalletPaidDistributionSegment   `json:"distribution"`
}

func (p *MoneyWalletPaidDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletPaidDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletPaidDistribution{}
	} else {
		*p = MoneyWalletPaidDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyWalletPaidDistributionFromJson(data string) MoneyWalletPaidDistribution {
	req := MoneyWalletPaidDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletPaidDistributionFromDict(data map[string]interface{}) MoneyWalletPaidDistribution {
	return MoneyWalletPaidDistribution{
		Statistics:   NewMoneyWalletPaidDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMoneyWalletPaidDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MoneyWalletPaidDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMoneyWalletPaidDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MoneyWalletPaidDistribution) Pointer() *MoneyWalletPaidDistribution {
	return &p
}

func CastMoneyWalletPaidDistributions(data []interface{}) []MoneyWalletPaidDistribution {
	v := make([]MoneyWalletPaidDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletPaidDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletPaidDistributionsFromDict(data []MoneyWalletPaidDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletDistributions struct {
	Free *MoneyWalletFreeDistribution `json:"free"`
	Paid *MoneyWalletPaidDistribution `json:"paid"`
}

func (p *MoneyWalletDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletDistributions{}
	} else {
		*p = MoneyWalletDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["free"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Free)
		}
		if v, ok := d["paid"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Paid)
		}
	}
	return nil
}

func NewMoneyWalletDistributionsFromJson(data string) MoneyWalletDistributions {
	req := MoneyWalletDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletDistributionsFromDict(data map[string]interface{}) MoneyWalletDistributions {
	return MoneyWalletDistributions{
		Free: NewMoneyWalletFreeDistributionFromDict(core.CastMap(data["free"])).Pointer(),
		Paid: NewMoneyWalletPaidDistributionFromDict(core.CastMap(data["paid"])).Pointer(),
	}
}

func (p MoneyWalletDistributions) ToDict() map[string]interface{} {

	var free map[string]interface{}
	if p.Free != nil {
		free = p.Free.ToDict()
	}
	var paid map[string]interface{}
	if p.Paid != nil {
		paid = p.Paid.ToDict()
	}
	return map[string]interface{}{
		"free": free,
		"paid": paid,
	}
}

func (p MoneyWalletDistributions) Pointer() *MoneyWalletDistributions {
	return &p
}

func CastMoneyWalletDistributionses(data []interface{}) []MoneyWalletDistributions {
	v := make([]MoneyWalletDistributions, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletDistributionsesFromDict(data []MoneyWalletDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWallet struct {
	WalletId      *string                   `json:"walletId"`
	Slot          *int32                    `json:"slot"`
	Statistics    *MoneyWalletStatistics    `json:"statistics"`
	Distributions *MoneyWalletDistributions `json:"distributions"`
}

func (p *MoneyWallet) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWallet{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWallet{}
	} else {
		*p = MoneyWallet{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["walletId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.WalletId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.WalletId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.WalletId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.WalletId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.WalletId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.WalletId)
				}
			}
		}
		if v, ok := d["slot"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Slot)
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewMoneyWalletFromJson(data string) MoneyWallet {
	req := MoneyWallet{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletFromDict(data map[string]interface{}) MoneyWallet {
	return MoneyWallet{
		WalletId:      core.CastString(data["walletId"]),
		Slot:          core.CastInt32(data["slot"]),
		Statistics:    NewMoneyWalletStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewMoneyWalletDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p MoneyWallet) ToDict() map[string]interface{} {

	var walletId *string
	if p.WalletId != nil {
		walletId = p.WalletId
	}
	var slot *int32
	if p.Slot != nil {
		slot = p.Slot
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"walletId":      walletId,
		"slot":          slot,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p MoneyWallet) Pointer() *MoneyWallet {
	return &p
}

func CastMoneyWallets(data []interface{}) []MoneyWallet {
	v := make([]MoneyWallet, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletsFromDict(data []MoneyWallet) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceiptStatistics struct {
	Verification *int64 `json:"verification"`
}

func (p *MoneyReceiptStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceiptStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceiptStatistics{}
	} else {
		*p = MoneyReceiptStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["verification"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Verification)
		}
	}
	return nil
}

func NewMoneyReceiptStatisticsFromJson(data string) MoneyReceiptStatistics {
	req := MoneyReceiptStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptStatisticsFromDict(data map[string]interface{}) MoneyReceiptStatistics {
	return MoneyReceiptStatistics{
		Verification: core.CastInt64(data["verification"]),
	}
}

func (p MoneyReceiptStatistics) ToDict() map[string]interface{} {

	var verification *int64
	if p.Verification != nil {
		verification = p.Verification
	}
	return map[string]interface{}{
		"verification": verification,
	}
}

func (p MoneyReceiptStatistics) Pointer() *MoneyReceiptStatistics {
	return &p
}

func CastMoneyReceiptStatisticses(data []interface{}) []MoneyReceiptStatistics {
	v := make([]MoneyReceiptStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptStatisticsesFromDict(data []MoneyReceiptStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceiptVerificationByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyReceiptVerificationByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceiptVerificationByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceiptVerificationByUserDistributionStatistics{}
	} else {
		*p = MoneyReceiptVerificationByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyReceiptVerificationByUserDistributionStatisticsFromJson(data string) MoneyReceiptVerificationByUserDistributionStatistics {
	req := MoneyReceiptVerificationByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptVerificationByUserDistributionStatisticsFromDict(data map[string]interface{}) MoneyReceiptVerificationByUserDistributionStatistics {
	return MoneyReceiptVerificationByUserDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MoneyReceiptVerificationByUserDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MoneyReceiptVerificationByUserDistributionStatistics) Pointer() *MoneyReceiptVerificationByUserDistributionStatistics {
	return &p
}

func CastMoneyReceiptVerificationByUserDistributionStatisticses(data []interface{}) []MoneyReceiptVerificationByUserDistributionStatistics {
	v := make([]MoneyReceiptVerificationByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptVerificationByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptVerificationByUserDistributionStatisticsesFromDict(data []MoneyReceiptVerificationByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceiptVerificationByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *MoneyReceiptVerificationByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceiptVerificationByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceiptVerificationByUserDistributionSegment{}
	} else {
		*p = MoneyReceiptVerificationByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyReceiptVerificationByUserDistributionSegmentFromJson(data string) MoneyReceiptVerificationByUserDistributionSegment {
	req := MoneyReceiptVerificationByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptVerificationByUserDistributionSegmentFromDict(data map[string]interface{}) MoneyReceiptVerificationByUserDistributionSegment {
	return MoneyReceiptVerificationByUserDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p MoneyReceiptVerificationByUserDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p MoneyReceiptVerificationByUserDistributionSegment) Pointer() *MoneyReceiptVerificationByUserDistributionSegment {
	return &p
}

func CastMoneyReceiptVerificationByUserDistributionSegments(data []interface{}) []MoneyReceiptVerificationByUserDistributionSegment {
	v := make([]MoneyReceiptVerificationByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptVerificationByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptVerificationByUserDistributionSegmentsFromDict(data []MoneyReceiptVerificationByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceiptVerificationByUserDistribution struct {
	Statistics   *MoneyReceiptVerificationByUserDistributionStatistics `json:"statistics"`
	Distribution []MoneyReceiptVerificationByUserDistributionSegment   `json:"distribution"`
}

func (p *MoneyReceiptVerificationByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceiptVerificationByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceiptVerificationByUserDistribution{}
	} else {
		*p = MoneyReceiptVerificationByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyReceiptVerificationByUserDistributionFromJson(data string) MoneyReceiptVerificationByUserDistribution {
	req := MoneyReceiptVerificationByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptVerificationByUserDistributionFromDict(data map[string]interface{}) MoneyReceiptVerificationByUserDistribution {
	return MoneyReceiptVerificationByUserDistribution{
		Statistics:   NewMoneyReceiptVerificationByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMoneyReceiptVerificationByUserDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MoneyReceiptVerificationByUserDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMoneyReceiptVerificationByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MoneyReceiptVerificationByUserDistribution) Pointer() *MoneyReceiptVerificationByUserDistribution {
	return &p
}

func CastMoneyReceiptVerificationByUserDistributions(data []interface{}) []MoneyReceiptVerificationByUserDistribution {
	v := make([]MoneyReceiptVerificationByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptVerificationByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptVerificationByUserDistributionsFromDict(data []MoneyReceiptVerificationByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceiptDistributions struct {
	VerificationByUser *MoneyReceiptVerificationByUserDistribution `json:"verificationByUser"`
}

func (p *MoneyReceiptDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceiptDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceiptDistributions{}
	} else {
		*p = MoneyReceiptDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["verificationByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.VerificationByUser)
		}
	}
	return nil
}

func NewMoneyReceiptDistributionsFromJson(data string) MoneyReceiptDistributions {
	req := MoneyReceiptDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptDistributionsFromDict(data map[string]interface{}) MoneyReceiptDistributions {
	return MoneyReceiptDistributions{
		VerificationByUser: NewMoneyReceiptVerificationByUserDistributionFromDict(core.CastMap(data["verificationByUser"])).Pointer(),
	}
}

func (p MoneyReceiptDistributions) ToDict() map[string]interface{} {

	var verificationByUser map[string]interface{}
	if p.VerificationByUser != nil {
		verificationByUser = p.VerificationByUser.ToDict()
	}
	return map[string]interface{}{
		"verificationByUser": verificationByUser,
	}
}

func (p MoneyReceiptDistributions) Pointer() *MoneyReceiptDistributions {
	return &p
}

func CastMoneyReceiptDistributionses(data []interface{}) []MoneyReceiptDistributions {
	v := make([]MoneyReceiptDistributions, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptDistributionsesFromDict(data []MoneyReceiptDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceipt struct {
	ReceiptId     *string                    `json:"receiptId"`
	ContentsId    *string                    `json:"contentsId"`
	Statistics    *MoneyReceiptStatistics    `json:"statistics"`
	Distributions *MoneyReceiptDistributions `json:"distributions"`
}

func (p *MoneyReceipt) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceipt{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceipt{}
	} else {
		*p = MoneyReceipt{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["receiptId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ReceiptId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ReceiptId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ReceiptId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ReceiptId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ReceiptId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ReceiptId)
				}
			}
		}
		if v, ok := d["contentsId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ContentsId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ContentsId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ContentsId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ContentsId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ContentsId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ContentsId)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewMoneyReceiptFromJson(data string) MoneyReceipt {
	req := MoneyReceipt{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptFromDict(data map[string]interface{}) MoneyReceipt {
	return MoneyReceipt{
		ReceiptId:     core.CastString(data["receiptId"]),
		ContentsId:    core.CastString(data["contentsId"]),
		Statistics:    NewMoneyReceiptStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewMoneyReceiptDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p MoneyReceipt) ToDict() map[string]interface{} {

	var receiptId *string
	if p.ReceiptId != nil {
		receiptId = p.ReceiptId
	}
	var contentsId *string
	if p.ContentsId != nil {
		contentsId = p.ContentsId
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"receiptId":     receiptId,
		"contentsId":    contentsId,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p MoneyReceipt) Pointer() *MoneyReceipt {
	return &p
}

func CastMoneyReceipts(data []interface{}) []MoneyReceipt {
	v := make([]MoneyReceipt, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptsFromDict(data []MoneyReceipt) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceStatistics struct {
	Verification *int64 `json:"verification"`
	Deposit      *int64 `json:"deposit"`
	Withdraw     *int64 `json:"withdraw"`
	Revenue      *int64 `json:"revenue"`
}

func (p *MoneyNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceStatistics{}
	} else {
		*p = MoneyNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["verification"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Verification)
		}
		if v, ok := d["deposit"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Deposit)
		}
		if v, ok := d["withdraw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Withdraw)
		}
		if v, ok := d["revenue"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Revenue)
		}
	}
	return nil
}

func NewMoneyNamespaceStatisticsFromJson(data string) MoneyNamespaceStatistics {
	req := MoneyNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceStatisticsFromDict(data map[string]interface{}) MoneyNamespaceStatistics {
	return MoneyNamespaceStatistics{
		Verification: core.CastInt64(data["verification"]),
		Deposit:      core.CastInt64(data["deposit"]),
		Withdraw:     core.CastInt64(data["withdraw"]),
		Revenue:      core.CastInt64(data["revenue"]),
	}
}

func (p MoneyNamespaceStatistics) ToDict() map[string]interface{} {

	var verification *int64
	if p.Verification != nil {
		verification = p.Verification
	}
	var deposit *int64
	if p.Deposit != nil {
		deposit = p.Deposit
	}
	var withdraw *int64
	if p.Withdraw != nil {
		withdraw = p.Withdraw
	}
	var revenue *int64
	if p.Revenue != nil {
		revenue = p.Revenue
	}
	return map[string]interface{}{
		"verification": verification,
		"deposit":      deposit,
		"withdraw":     withdraw,
		"revenue":      revenue,
	}
}

func (p MoneyNamespaceStatistics) Pointer() *MoneyNamespaceStatistics {
	return &p
}

func CastMoneyNamespaceStatisticses(data []interface{}) []MoneyNamespaceStatistics {
	v := make([]MoneyNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceStatisticsesFromDict(data []MoneyNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceVerificationDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyNamespaceVerificationDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceVerificationDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceVerificationDistributionStatistics{}
	} else {
		*p = MoneyNamespaceVerificationDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyNamespaceVerificationDistributionStatisticsFromJson(data string) MoneyNamespaceVerificationDistributionStatistics {
	req := MoneyNamespaceVerificationDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceVerificationDistributionStatisticsFromDict(data map[string]interface{}) MoneyNamespaceVerificationDistributionStatistics {
	return MoneyNamespaceVerificationDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MoneyNamespaceVerificationDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MoneyNamespaceVerificationDistributionStatistics) Pointer() *MoneyNamespaceVerificationDistributionStatistics {
	return &p
}

func CastMoneyNamespaceVerificationDistributionStatisticses(data []interface{}) []MoneyNamespaceVerificationDistributionStatistics {
	v := make([]MoneyNamespaceVerificationDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceVerificationDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceVerificationDistributionStatisticsesFromDict(data []MoneyNamespaceVerificationDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceVerificationDistributionSegment struct {
	ContentsId *string `json:"contentsId"`
	Count      *int64  `json:"count"`
}

func (p *MoneyNamespaceVerificationDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceVerificationDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceVerificationDistributionSegment{}
	} else {
		*p = MoneyNamespaceVerificationDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["contentsId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ContentsId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ContentsId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ContentsId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ContentsId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ContentsId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ContentsId)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyNamespaceVerificationDistributionSegmentFromJson(data string) MoneyNamespaceVerificationDistributionSegment {
	req := MoneyNamespaceVerificationDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceVerificationDistributionSegmentFromDict(data map[string]interface{}) MoneyNamespaceVerificationDistributionSegment {
	return MoneyNamespaceVerificationDistributionSegment{
		ContentsId: core.CastString(data["contentsId"]),
		Count:      core.CastInt64(data["count"]),
	}
}

func (p MoneyNamespaceVerificationDistributionSegment) ToDict() map[string]interface{} {

	var contentsId *string
	if p.ContentsId != nil {
		contentsId = p.ContentsId
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"contentsId": contentsId,
		"count":      count,
	}
}

func (p MoneyNamespaceVerificationDistributionSegment) Pointer() *MoneyNamespaceVerificationDistributionSegment {
	return &p
}

func CastMoneyNamespaceVerificationDistributionSegments(data []interface{}) []MoneyNamespaceVerificationDistributionSegment {
	v := make([]MoneyNamespaceVerificationDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceVerificationDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceVerificationDistributionSegmentsFromDict(data []MoneyNamespaceVerificationDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceVerificationDistribution struct {
	Statistics   *MoneyNamespaceVerificationDistributionStatistics `json:"statistics"`
	Distribution []MoneyNamespaceVerificationDistributionSegment   `json:"distribution"`
}

func (p *MoneyNamespaceVerificationDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceVerificationDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceVerificationDistribution{}
	} else {
		*p = MoneyNamespaceVerificationDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyNamespaceVerificationDistributionFromJson(data string) MoneyNamespaceVerificationDistribution {
	req := MoneyNamespaceVerificationDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceVerificationDistributionFromDict(data map[string]interface{}) MoneyNamespaceVerificationDistribution {
	return MoneyNamespaceVerificationDistribution{
		Statistics:   NewMoneyNamespaceVerificationDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMoneyNamespaceVerificationDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MoneyNamespaceVerificationDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMoneyNamespaceVerificationDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MoneyNamespaceVerificationDistribution) Pointer() *MoneyNamespaceVerificationDistribution {
	return &p
}

func CastMoneyNamespaceVerificationDistributions(data []interface{}) []MoneyNamespaceVerificationDistribution {
	v := make([]MoneyNamespaceVerificationDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceVerificationDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceVerificationDistributionsFromDict(data []MoneyNamespaceVerificationDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceDepositDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyNamespaceDepositDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceDepositDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceDepositDistributionStatistics{}
	} else {
		*p = MoneyNamespaceDepositDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyNamespaceDepositDistributionStatisticsFromJson(data string) MoneyNamespaceDepositDistributionStatistics {
	req := MoneyNamespaceDepositDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceDepositDistributionStatisticsFromDict(data map[string]interface{}) MoneyNamespaceDepositDistributionStatistics {
	return MoneyNamespaceDepositDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MoneyNamespaceDepositDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MoneyNamespaceDepositDistributionStatistics) Pointer() *MoneyNamespaceDepositDistributionStatistics {
	return &p
}

func CastMoneyNamespaceDepositDistributionStatisticses(data []interface{}) []MoneyNamespaceDepositDistributionStatistics {
	v := make([]MoneyNamespaceDepositDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceDepositDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceDepositDistributionStatisticsesFromDict(data []MoneyNamespaceDepositDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceDepositDistributionSegment struct {
	Slot  *int32 `json:"slot"`
	Count *int64 `json:"count"`
}

func (p *MoneyNamespaceDepositDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceDepositDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceDepositDistributionSegment{}
	} else {
		*p = MoneyNamespaceDepositDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["slot"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Slot)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyNamespaceDepositDistributionSegmentFromJson(data string) MoneyNamespaceDepositDistributionSegment {
	req := MoneyNamespaceDepositDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceDepositDistributionSegmentFromDict(data map[string]interface{}) MoneyNamespaceDepositDistributionSegment {
	return MoneyNamespaceDepositDistributionSegment{
		Slot:  core.CastInt32(data["slot"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p MoneyNamespaceDepositDistributionSegment) ToDict() map[string]interface{} {

	var slot *int32
	if p.Slot != nil {
		slot = p.Slot
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"slot":  slot,
		"count": count,
	}
}

func (p MoneyNamespaceDepositDistributionSegment) Pointer() *MoneyNamespaceDepositDistributionSegment {
	return &p
}

func CastMoneyNamespaceDepositDistributionSegments(data []interface{}) []MoneyNamespaceDepositDistributionSegment {
	v := make([]MoneyNamespaceDepositDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceDepositDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceDepositDistributionSegmentsFromDict(data []MoneyNamespaceDepositDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceDepositDistribution struct {
	Statistics   *MoneyNamespaceDepositDistributionStatistics `json:"statistics"`
	Distribution []MoneyNamespaceDepositDistributionSegment   `json:"distribution"`
}

func (p *MoneyNamespaceDepositDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceDepositDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceDepositDistribution{}
	} else {
		*p = MoneyNamespaceDepositDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyNamespaceDepositDistributionFromJson(data string) MoneyNamespaceDepositDistribution {
	req := MoneyNamespaceDepositDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceDepositDistributionFromDict(data map[string]interface{}) MoneyNamespaceDepositDistribution {
	return MoneyNamespaceDepositDistribution{
		Statistics:   NewMoneyNamespaceDepositDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMoneyNamespaceDepositDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MoneyNamespaceDepositDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMoneyNamespaceDepositDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MoneyNamespaceDepositDistribution) Pointer() *MoneyNamespaceDepositDistribution {
	return &p
}

func CastMoneyNamespaceDepositDistributions(data []interface{}) []MoneyNamespaceDepositDistribution {
	v := make([]MoneyNamespaceDepositDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceDepositDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceDepositDistributionsFromDict(data []MoneyNamespaceDepositDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceWithdrawDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyNamespaceWithdrawDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceWithdrawDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceWithdrawDistributionStatistics{}
	} else {
		*p = MoneyNamespaceWithdrawDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyNamespaceWithdrawDistributionStatisticsFromJson(data string) MoneyNamespaceWithdrawDistributionStatistics {
	req := MoneyNamespaceWithdrawDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceWithdrawDistributionStatisticsFromDict(data map[string]interface{}) MoneyNamespaceWithdrawDistributionStatistics {
	return MoneyNamespaceWithdrawDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MoneyNamespaceWithdrawDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MoneyNamespaceWithdrawDistributionStatistics) Pointer() *MoneyNamespaceWithdrawDistributionStatistics {
	return &p
}

func CastMoneyNamespaceWithdrawDistributionStatisticses(data []interface{}) []MoneyNamespaceWithdrawDistributionStatistics {
	v := make([]MoneyNamespaceWithdrawDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceWithdrawDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceWithdrawDistributionStatisticsesFromDict(data []MoneyNamespaceWithdrawDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceWithdrawDistributionSegment struct {
	Slot  *int32 `json:"slot"`
	Count *int64 `json:"count"`
}

func (p *MoneyNamespaceWithdrawDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceWithdrawDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceWithdrawDistributionSegment{}
	} else {
		*p = MoneyNamespaceWithdrawDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["slot"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Slot)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyNamespaceWithdrawDistributionSegmentFromJson(data string) MoneyNamespaceWithdrawDistributionSegment {
	req := MoneyNamespaceWithdrawDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceWithdrawDistributionSegmentFromDict(data map[string]interface{}) MoneyNamespaceWithdrawDistributionSegment {
	return MoneyNamespaceWithdrawDistributionSegment{
		Slot:  core.CastInt32(data["slot"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p MoneyNamespaceWithdrawDistributionSegment) ToDict() map[string]interface{} {

	var slot *int32
	if p.Slot != nil {
		slot = p.Slot
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"slot":  slot,
		"count": count,
	}
}

func (p MoneyNamespaceWithdrawDistributionSegment) Pointer() *MoneyNamespaceWithdrawDistributionSegment {
	return &p
}

func CastMoneyNamespaceWithdrawDistributionSegments(data []interface{}) []MoneyNamespaceWithdrawDistributionSegment {
	v := make([]MoneyNamespaceWithdrawDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceWithdrawDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceWithdrawDistributionSegmentsFromDict(data []MoneyNamespaceWithdrawDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceWithdrawDistribution struct {
	Statistics   *MoneyNamespaceWithdrawDistributionStatistics `json:"statistics"`
	Distribution []MoneyNamespaceWithdrawDistributionSegment   `json:"distribution"`
}

func (p *MoneyNamespaceWithdrawDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceWithdrawDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceWithdrawDistribution{}
	} else {
		*p = MoneyNamespaceWithdrawDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyNamespaceWithdrawDistributionFromJson(data string) MoneyNamespaceWithdrawDistribution {
	req := MoneyNamespaceWithdrawDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceWithdrawDistributionFromDict(data map[string]interface{}) MoneyNamespaceWithdrawDistribution {
	return MoneyNamespaceWithdrawDistribution{
		Statistics:   NewMoneyNamespaceWithdrawDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMoneyNamespaceWithdrawDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MoneyNamespaceWithdrawDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMoneyNamespaceWithdrawDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MoneyNamespaceWithdrawDistribution) Pointer() *MoneyNamespaceWithdrawDistribution {
	return &p
}

func CastMoneyNamespaceWithdrawDistributions(data []interface{}) []MoneyNamespaceWithdrawDistribution {
	v := make([]MoneyNamespaceWithdrawDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceWithdrawDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceWithdrawDistributionsFromDict(data []MoneyNamespaceWithdrawDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceRevenueDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyNamespaceRevenueDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceRevenueDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceRevenueDistributionStatistics{}
	} else {
		*p = MoneyNamespaceRevenueDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyNamespaceRevenueDistributionStatisticsFromJson(data string) MoneyNamespaceRevenueDistributionStatistics {
	req := MoneyNamespaceRevenueDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceRevenueDistributionStatisticsFromDict(data map[string]interface{}) MoneyNamespaceRevenueDistributionStatistics {
	return MoneyNamespaceRevenueDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p MoneyNamespaceRevenueDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p MoneyNamespaceRevenueDistributionStatistics) Pointer() *MoneyNamespaceRevenueDistributionStatistics {
	return &p
}

func CastMoneyNamespaceRevenueDistributionStatisticses(data []interface{}) []MoneyNamespaceRevenueDistributionStatistics {
	v := make([]MoneyNamespaceRevenueDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceRevenueDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceRevenueDistributionStatisticsesFromDict(data []MoneyNamespaceRevenueDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceRevenueDistributionSegment struct {
	Slot *int32 `json:"slot"`
	Sum  *int64 `json:"sum"`
}

func (p *MoneyNamespaceRevenueDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceRevenueDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceRevenueDistributionSegment{}
	} else {
		*p = MoneyNamespaceRevenueDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["slot"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Slot)
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewMoneyNamespaceRevenueDistributionSegmentFromJson(data string) MoneyNamespaceRevenueDistributionSegment {
	req := MoneyNamespaceRevenueDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceRevenueDistributionSegmentFromDict(data map[string]interface{}) MoneyNamespaceRevenueDistributionSegment {
	return MoneyNamespaceRevenueDistributionSegment{
		Slot: core.CastInt32(data["slot"]),
		Sum:  core.CastInt64(data["sum"]),
	}
}

func (p MoneyNamespaceRevenueDistributionSegment) ToDict() map[string]interface{} {

	var slot *int32
	if p.Slot != nil {
		slot = p.Slot
	}
	var sum *int64
	if p.Sum != nil {
		sum = p.Sum
	}
	return map[string]interface{}{
		"slot": slot,
		"sum":  sum,
	}
}

func (p MoneyNamespaceRevenueDistributionSegment) Pointer() *MoneyNamespaceRevenueDistributionSegment {
	return &p
}

func CastMoneyNamespaceRevenueDistributionSegments(data []interface{}) []MoneyNamespaceRevenueDistributionSegment {
	v := make([]MoneyNamespaceRevenueDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceRevenueDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceRevenueDistributionSegmentsFromDict(data []MoneyNamespaceRevenueDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceRevenueDistribution struct {
	Statistics   *MoneyNamespaceRevenueDistributionStatistics `json:"statistics"`
	Distribution []MoneyNamespaceRevenueDistributionSegment   `json:"distribution"`
}

func (p *MoneyNamespaceRevenueDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceRevenueDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceRevenueDistribution{}
	} else {
		*p = MoneyNamespaceRevenueDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyNamespaceRevenueDistributionFromJson(data string) MoneyNamespaceRevenueDistribution {
	req := MoneyNamespaceRevenueDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceRevenueDistributionFromDict(data map[string]interface{}) MoneyNamespaceRevenueDistribution {
	return MoneyNamespaceRevenueDistribution{
		Statistics:   NewMoneyNamespaceRevenueDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastMoneyNamespaceRevenueDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p MoneyNamespaceRevenueDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastMoneyNamespaceRevenueDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p MoneyNamespaceRevenueDistribution) Pointer() *MoneyNamespaceRevenueDistribution {
	return &p
}

func CastMoneyNamespaceRevenueDistributions(data []interface{}) []MoneyNamespaceRevenueDistribution {
	v := make([]MoneyNamespaceRevenueDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceRevenueDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceRevenueDistributionsFromDict(data []MoneyNamespaceRevenueDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceDistributions struct {
	Verification *MoneyNamespaceVerificationDistribution `json:"verification"`
	Deposit      *MoneyNamespaceDepositDistribution      `json:"deposit"`
	Withdraw     *MoneyNamespaceWithdrawDistribution     `json:"withdraw"`
	Revenue      *MoneyNamespaceRevenueDistribution      `json:"revenue"`
}

func (p *MoneyNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceDistributions{}
	} else {
		*p = MoneyNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["verification"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Verification)
		}
		if v, ok := d["deposit"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Deposit)
		}
		if v, ok := d["withdraw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Withdraw)
		}
		if v, ok := d["revenue"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Revenue)
		}
	}
	return nil
}

func NewMoneyNamespaceDistributionsFromJson(data string) MoneyNamespaceDistributions {
	req := MoneyNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceDistributionsFromDict(data map[string]interface{}) MoneyNamespaceDistributions {
	return MoneyNamespaceDistributions{
		Verification: NewMoneyNamespaceVerificationDistributionFromDict(core.CastMap(data["verification"])).Pointer(),
		Deposit:      NewMoneyNamespaceDepositDistributionFromDict(core.CastMap(data["deposit"])).Pointer(),
		Withdraw:     NewMoneyNamespaceWithdrawDistributionFromDict(core.CastMap(data["withdraw"])).Pointer(),
		Revenue:      NewMoneyNamespaceRevenueDistributionFromDict(core.CastMap(data["revenue"])).Pointer(),
	}
}

func (p MoneyNamespaceDistributions) ToDict() map[string]interface{} {

	var verification map[string]interface{}
	if p.Verification != nil {
		verification = p.Verification.ToDict()
	}
	var deposit map[string]interface{}
	if p.Deposit != nil {
		deposit = p.Deposit.ToDict()
	}
	var withdraw map[string]interface{}
	if p.Withdraw != nil {
		withdraw = p.Withdraw.ToDict()
	}
	var revenue map[string]interface{}
	if p.Revenue != nil {
		revenue = p.Revenue.ToDict()
	}
	return map[string]interface{}{
		"verification": verification,
		"deposit":      deposit,
		"withdraw":     withdraw,
		"revenue":      revenue,
	}
}

func (p MoneyNamespaceDistributions) Pointer() *MoneyNamespaceDistributions {
	return &p
}

func CastMoneyNamespaceDistributionses(data []interface{}) []MoneyNamespaceDistributions {
	v := make([]MoneyNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceDistributionsesFromDict(data []MoneyNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespace struct {
	NamespaceId   *string                      `json:"namespaceId"`
	Year          *int32                       `json:"year"`
	Month         *int32                       `json:"month"`
	Day           *int32                       `json:"day"`
	NamespaceName *string                      `json:"namespaceName"`
	Statistics    *MoneyNamespaceStatistics    `json:"statistics"`
	Distributions *MoneyNamespaceDistributions `json:"distributions"`
	Wallets       []MoneyWallet                `json:"wallets"`
	Receipts      []MoneyReceipt               `json:"receipts"`
}

func (p *MoneyNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespace{}
	} else {
		*p = MoneyNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["wallets"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Wallets)
		}
		if v, ok := d["receipts"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Receipts)
		}
	}
	return nil
}

func NewMoneyNamespaceFromJson(data string) MoneyNamespace {
	req := MoneyNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceFromDict(data map[string]interface{}) MoneyNamespace {
	return MoneyNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewMoneyNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewMoneyNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		Wallets:       CastMoneyWallets(core.CastArray(data["wallets"])),
		Receipts:      CastMoneyReceipts(core.CastArray(data["receipts"])),
	}
}

func (p MoneyNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var wallets []interface{}
	if p.Wallets != nil {
		wallets = CastMoneyWalletsFromDict(
			p.Wallets,
		)
	}
	var receipts []interface{}
	if p.Receipts != nil {
		receipts = CastMoneyReceiptsFromDict(
			p.Receipts,
		)
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
		"wallets":       wallets,
		"receipts":      receipts,
	}
}

func (p MoneyNamespace) Pointer() *MoneyNamespace {
	return &p
}

func CastMoneyNamespaces(data []interface{}) []MoneyNamespace {
	v := make([]MoneyNamespace, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespacesFromDict(data []MoneyNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModelStatistics struct {
	StartQuest     *int64   `json:"startQuest"`
	EndQuest       *int64   `json:"endQuest"`
	Successful     *int64   `json:"successful"`
	SuccessfulRate *float32 `json:"successfulRate"`
}

func (p *QuestQuestModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModelStatistics{}
	} else {
		*p = QuestQuestModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["startQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.StartQuest)
		}
		if v, ok := d["endQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EndQuest)
		}
		if v, ok := d["successful"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Successful)
		}
		if v, ok := d["successfulRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SuccessfulRate)
		}
	}
	return nil
}

func NewQuestQuestModelStatisticsFromJson(data string) QuestQuestModelStatistics {
	req := QuestQuestModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelStatisticsFromDict(data map[string]interface{}) QuestQuestModelStatistics {
	return QuestQuestModelStatistics{
		StartQuest:     core.CastInt64(data["startQuest"]),
		EndQuest:       core.CastInt64(data["endQuest"]),
		Successful:     core.CastInt64(data["successful"]),
		SuccessfulRate: core.CastFloat32(data["successfulRate"]),
	}
}

func (p QuestQuestModelStatistics) ToDict() map[string]interface{} {

	var startQuest *int64
	if p.StartQuest != nil {
		startQuest = p.StartQuest
	}
	var endQuest *int64
	if p.EndQuest != nil {
		endQuest = p.EndQuest
	}
	var successful *int64
	if p.Successful != nil {
		successful = p.Successful
	}
	var successfulRate *float32
	if p.SuccessfulRate != nil {
		successfulRate = p.SuccessfulRate
	}
	return map[string]interface{}{
		"startQuest":     startQuest,
		"endQuest":       endQuest,
		"successful":     successful,
		"successfulRate": successfulRate,
	}
}

func (p QuestQuestModelStatistics) Pointer() *QuestQuestModelStatistics {
	return &p
}

func CastQuestQuestModelStatisticses(data []interface{}) []QuestQuestModelStatistics {
	v := make([]QuestQuestModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelStatisticsesFromDict(data []QuestQuestModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModelPlayTimeSecondsDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *QuestQuestModelPlayTimeSecondsDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModelPlayTimeSecondsDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModelPlayTimeSecondsDistributionStatistics{}
	} else {
		*p = QuestQuestModelPlayTimeSecondsDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewQuestQuestModelPlayTimeSecondsDistributionStatisticsFromJson(data string) QuestQuestModelPlayTimeSecondsDistributionStatistics {
	req := QuestQuestModelPlayTimeSecondsDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelPlayTimeSecondsDistributionStatisticsFromDict(data map[string]interface{}) QuestQuestModelPlayTimeSecondsDistributionStatistics {
	return QuestQuestModelPlayTimeSecondsDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p QuestQuestModelPlayTimeSecondsDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p QuestQuestModelPlayTimeSecondsDistributionStatistics) Pointer() *QuestQuestModelPlayTimeSecondsDistributionStatistics {
	return &p
}

func CastQuestQuestModelPlayTimeSecondsDistributionStatisticses(data []interface{}) []QuestQuestModelPlayTimeSecondsDistributionStatistics {
	v := make([]QuestQuestModelPlayTimeSecondsDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelPlayTimeSecondsDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelPlayTimeSecondsDistributionStatisticsesFromDict(data []QuestQuestModelPlayTimeSecondsDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModelPlayTimeSecondsDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *QuestQuestModelPlayTimeSecondsDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModelPlayTimeSecondsDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModelPlayTimeSecondsDistributionSegment{}
	} else {
		*p = QuestQuestModelPlayTimeSecondsDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewQuestQuestModelPlayTimeSecondsDistributionSegmentFromJson(data string) QuestQuestModelPlayTimeSecondsDistributionSegment {
	req := QuestQuestModelPlayTimeSecondsDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelPlayTimeSecondsDistributionSegmentFromDict(data map[string]interface{}) QuestQuestModelPlayTimeSecondsDistributionSegment {
	return QuestQuestModelPlayTimeSecondsDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p QuestQuestModelPlayTimeSecondsDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p QuestQuestModelPlayTimeSecondsDistributionSegment) Pointer() *QuestQuestModelPlayTimeSecondsDistributionSegment {
	return &p
}

func CastQuestQuestModelPlayTimeSecondsDistributionSegments(data []interface{}) []QuestQuestModelPlayTimeSecondsDistributionSegment {
	v := make([]QuestQuestModelPlayTimeSecondsDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelPlayTimeSecondsDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelPlayTimeSecondsDistributionSegmentsFromDict(data []QuestQuestModelPlayTimeSecondsDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModelPlayTimeSecondsDistribution struct {
	Statistics   *QuestQuestModelPlayTimeSecondsDistributionStatistics `json:"statistics"`
	Distribution []QuestQuestModelPlayTimeSecondsDistributionSegment   `json:"distribution"`
}

func (p *QuestQuestModelPlayTimeSecondsDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModelPlayTimeSecondsDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModelPlayTimeSecondsDistribution{}
	} else {
		*p = QuestQuestModelPlayTimeSecondsDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewQuestQuestModelPlayTimeSecondsDistributionFromJson(data string) QuestQuestModelPlayTimeSecondsDistribution {
	req := QuestQuestModelPlayTimeSecondsDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelPlayTimeSecondsDistributionFromDict(data map[string]interface{}) QuestQuestModelPlayTimeSecondsDistribution {
	return QuestQuestModelPlayTimeSecondsDistribution{
		Statistics:   NewQuestQuestModelPlayTimeSecondsDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastQuestQuestModelPlayTimeSecondsDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p QuestQuestModelPlayTimeSecondsDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastQuestQuestModelPlayTimeSecondsDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p QuestQuestModelPlayTimeSecondsDistribution) Pointer() *QuestQuestModelPlayTimeSecondsDistribution {
	return &p
}

func CastQuestQuestModelPlayTimeSecondsDistributions(data []interface{}) []QuestQuestModelPlayTimeSecondsDistribution {
	v := make([]QuestQuestModelPlayTimeSecondsDistribution, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelPlayTimeSecondsDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelPlayTimeSecondsDistributionsFromDict(data []QuestQuestModelPlayTimeSecondsDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModelDistributions struct {
	PlayTimeSeconds *QuestQuestModelPlayTimeSecondsDistribution `json:"playTimeSeconds"`
}

func (p *QuestQuestModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModelDistributions{}
	} else {
		*p = QuestQuestModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["playTimeSeconds"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.PlayTimeSeconds)
		}
	}
	return nil
}

func NewQuestQuestModelDistributionsFromJson(data string) QuestQuestModelDistributions {
	req := QuestQuestModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelDistributionsFromDict(data map[string]interface{}) QuestQuestModelDistributions {
	return QuestQuestModelDistributions{
		PlayTimeSeconds: NewQuestQuestModelPlayTimeSecondsDistributionFromDict(core.CastMap(data["playTimeSeconds"])).Pointer(),
	}
}

func (p QuestQuestModelDistributions) ToDict() map[string]interface{} {

	var playTimeSeconds map[string]interface{}
	if p.PlayTimeSeconds != nil {
		playTimeSeconds = p.PlayTimeSeconds.ToDict()
	}
	return map[string]interface{}{
		"playTimeSeconds": playTimeSeconds,
	}
}

func (p QuestQuestModelDistributions) Pointer() *QuestQuestModelDistributions {
	return &p
}

func CastQuestQuestModelDistributionses(data []interface{}) []QuestQuestModelDistributions {
	v := make([]QuestQuestModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelDistributionsesFromDict(data []QuestQuestModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModel struct {
	QuestModelId  *string                       `json:"questModelId"`
	QuestName     *string                       `json:"questName"`
	Statistics    *QuestQuestModelStatistics    `json:"statistics"`
	Distributions *QuestQuestModelDistributions `json:"distributions"`
}

func (p *QuestQuestModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModel{}
	} else {
		*p = QuestQuestModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["questModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestModelId)
				}
			}
		}
		if v, ok := d["questName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewQuestQuestModelFromJson(data string) QuestQuestModel {
	req := QuestQuestModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelFromDict(data map[string]interface{}) QuestQuestModel {
	return QuestQuestModel{
		QuestModelId:  core.CastString(data["questModelId"]),
		QuestName:     core.CastString(data["questName"]),
		Statistics:    NewQuestQuestModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewQuestQuestModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p QuestQuestModel) ToDict() map[string]interface{} {

	var questModelId *string
	if p.QuestModelId != nil {
		questModelId = p.QuestModelId
	}
	var questName *string
	if p.QuestName != nil {
		questName = p.QuestName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"questModelId":  questModelId,
		"questName":     questName,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p QuestQuestModel) Pointer() *QuestQuestModel {
	return &p
}

func CastQuestQuestModels(data []interface{}) []QuestQuestModel {
	v := make([]QuestQuestModel, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelsFromDict(data []QuestQuestModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModelStatistics struct {
	StartQuest     *int64   `json:"startQuest"`
	EndQuest       *int64   `json:"endQuest"`
	Successful     *int64   `json:"successful"`
	SuccessfulRate *float32 `json:"successfulRate"`
}

func (p *QuestQuestGroupModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModelStatistics{}
	} else {
		*p = QuestQuestGroupModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["startQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.StartQuest)
		}
		if v, ok := d["endQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EndQuest)
		}
		if v, ok := d["successful"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Successful)
		}
		if v, ok := d["successfulRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SuccessfulRate)
		}
	}
	return nil
}

func NewQuestQuestGroupModelStatisticsFromJson(data string) QuestQuestGroupModelStatistics {
	req := QuestQuestGroupModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelStatisticsFromDict(data map[string]interface{}) QuestQuestGroupModelStatistics {
	return QuestQuestGroupModelStatistics{
		StartQuest:     core.CastInt64(data["startQuest"]),
		EndQuest:       core.CastInt64(data["endQuest"]),
		Successful:     core.CastInt64(data["successful"]),
		SuccessfulRate: core.CastFloat32(data["successfulRate"]),
	}
}

func (p QuestQuestGroupModelStatistics) ToDict() map[string]interface{} {

	var startQuest *int64
	if p.StartQuest != nil {
		startQuest = p.StartQuest
	}
	var endQuest *int64
	if p.EndQuest != nil {
		endQuest = p.EndQuest
	}
	var successful *int64
	if p.Successful != nil {
		successful = p.Successful
	}
	var successfulRate *float32
	if p.SuccessfulRate != nil {
		successfulRate = p.SuccessfulRate
	}
	return map[string]interface{}{
		"startQuest":     startQuest,
		"endQuest":       endQuest,
		"successful":     successful,
		"successfulRate": successfulRate,
	}
}

func (p QuestQuestGroupModelStatistics) Pointer() *QuestQuestGroupModelStatistics {
	return &p
}

func CastQuestQuestGroupModelStatisticses(data []interface{}) []QuestQuestGroupModelStatistics {
	v := make([]QuestQuestGroupModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelStatisticsesFromDict(data []QuestQuestGroupModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModelQuestDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *QuestQuestGroupModelQuestDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModelQuestDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModelQuestDistributionStatistics{}
	} else {
		*p = QuestQuestGroupModelQuestDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewQuestQuestGroupModelQuestDistributionStatisticsFromJson(data string) QuestQuestGroupModelQuestDistributionStatistics {
	req := QuestQuestGroupModelQuestDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelQuestDistributionStatisticsFromDict(data map[string]interface{}) QuestQuestGroupModelQuestDistributionStatistics {
	return QuestQuestGroupModelQuestDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p QuestQuestGroupModelQuestDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p QuestQuestGroupModelQuestDistributionStatistics) Pointer() *QuestQuestGroupModelQuestDistributionStatistics {
	return &p
}

func CastQuestQuestGroupModelQuestDistributionStatisticses(data []interface{}) []QuestQuestGroupModelQuestDistributionStatistics {
	v := make([]QuestQuestGroupModelQuestDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelQuestDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelQuestDistributionStatisticsesFromDict(data []QuestQuestGroupModelQuestDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModelQuestDistributionSegment struct {
	QuestName *string `json:"questName"`
	Count     *int64  `json:"count"`
}

func (p *QuestQuestGroupModelQuestDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModelQuestDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModelQuestDistributionSegment{}
	} else {
		*p = QuestQuestGroupModelQuestDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["questName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewQuestQuestGroupModelQuestDistributionSegmentFromJson(data string) QuestQuestGroupModelQuestDistributionSegment {
	req := QuestQuestGroupModelQuestDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelQuestDistributionSegmentFromDict(data map[string]interface{}) QuestQuestGroupModelQuestDistributionSegment {
	return QuestQuestGroupModelQuestDistributionSegment{
		QuestName: core.CastString(data["questName"]),
		Count:     core.CastInt64(data["count"]),
	}
}

func (p QuestQuestGroupModelQuestDistributionSegment) ToDict() map[string]interface{} {

	var questName *string
	if p.QuestName != nil {
		questName = p.QuestName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"questName": questName,
		"count":     count,
	}
}

func (p QuestQuestGroupModelQuestDistributionSegment) Pointer() *QuestQuestGroupModelQuestDistributionSegment {
	return &p
}

func CastQuestQuestGroupModelQuestDistributionSegments(data []interface{}) []QuestQuestGroupModelQuestDistributionSegment {
	v := make([]QuestQuestGroupModelQuestDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelQuestDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelQuestDistributionSegmentsFromDict(data []QuestQuestGroupModelQuestDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModelQuestDistribution struct {
	Statistics   *QuestQuestGroupModelQuestDistributionStatistics `json:"statistics"`
	Distribution []QuestQuestGroupModelQuestDistributionSegment   `json:"distribution"`
}

func (p *QuestQuestGroupModelQuestDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModelQuestDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModelQuestDistribution{}
	} else {
		*p = QuestQuestGroupModelQuestDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewQuestQuestGroupModelQuestDistributionFromJson(data string) QuestQuestGroupModelQuestDistribution {
	req := QuestQuestGroupModelQuestDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelQuestDistributionFromDict(data map[string]interface{}) QuestQuestGroupModelQuestDistribution {
	return QuestQuestGroupModelQuestDistribution{
		Statistics:   NewQuestQuestGroupModelQuestDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastQuestQuestGroupModelQuestDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p QuestQuestGroupModelQuestDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastQuestQuestGroupModelQuestDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p QuestQuestGroupModelQuestDistribution) Pointer() *QuestQuestGroupModelQuestDistribution {
	return &p
}

func CastQuestQuestGroupModelQuestDistributions(data []interface{}) []QuestQuestGroupModelQuestDistribution {
	v := make([]QuestQuestGroupModelQuestDistribution, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelQuestDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelQuestDistributionsFromDict(data []QuestQuestGroupModelQuestDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModelDistributions struct {
	Quest *QuestQuestGroupModelQuestDistribution `json:"quest"`
}

func (p *QuestQuestGroupModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModelDistributions{}
	} else {
		*p = QuestQuestGroupModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["quest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Quest)
		}
	}
	return nil
}

func NewQuestQuestGroupModelDistributionsFromJson(data string) QuestQuestGroupModelDistributions {
	req := QuestQuestGroupModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelDistributionsFromDict(data map[string]interface{}) QuestQuestGroupModelDistributions {
	return QuestQuestGroupModelDistributions{
		Quest: NewQuestQuestGroupModelQuestDistributionFromDict(core.CastMap(data["quest"])).Pointer(),
	}
}

func (p QuestQuestGroupModelDistributions) ToDict() map[string]interface{} {

	var quest map[string]interface{}
	if p.Quest != nil {
		quest = p.Quest.ToDict()
	}
	return map[string]interface{}{
		"quest": quest,
	}
}

func (p QuestQuestGroupModelDistributions) Pointer() *QuestQuestGroupModelDistributions {
	return &p
}

func CastQuestQuestGroupModelDistributionses(data []interface{}) []QuestQuestGroupModelDistributions {
	v := make([]QuestQuestGroupModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelDistributionsesFromDict(data []QuestQuestGroupModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModel struct {
	QuestGroupModelId *string                            `json:"questGroupModelId"`
	QuestGroupName    *string                            `json:"questGroupName"`
	Statistics        *QuestQuestGroupModelStatistics    `json:"statistics"`
	Distributions     *QuestQuestGroupModelDistributions `json:"distributions"`
	QuestModels       []QuestQuestModel                  `json:"questModels"`
}

func (p *QuestQuestGroupModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModel{}
	} else {
		*p = QuestQuestGroupModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["questGroupModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestGroupModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestGroupModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestGroupModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestGroupModelId)
				}
			}
		}
		if v, ok := d["questGroupName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestGroupName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestGroupName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestGroupName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestGroupName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["questModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.QuestModels)
		}
	}
	return nil
}

func NewQuestQuestGroupModelFromJson(data string) QuestQuestGroupModel {
	req := QuestQuestGroupModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelFromDict(data map[string]interface{}) QuestQuestGroupModel {
	return QuestQuestGroupModel{
		QuestGroupModelId: core.CastString(data["questGroupModelId"]),
		QuestGroupName:    core.CastString(data["questGroupName"]),
		Statistics:        NewQuestQuestGroupModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions:     NewQuestQuestGroupModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		QuestModels:       CastQuestQuestModels(core.CastArray(data["questModels"])),
	}
}

func (p QuestQuestGroupModel) ToDict() map[string]interface{} {

	var questGroupModelId *string
	if p.QuestGroupModelId != nil {
		questGroupModelId = p.QuestGroupModelId
	}
	var questGroupName *string
	if p.QuestGroupName != nil {
		questGroupName = p.QuestGroupName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var questModels []interface{}
	if p.QuestModels != nil {
		questModels = CastQuestQuestModelsFromDict(
			p.QuestModels,
		)
	}
	return map[string]interface{}{
		"questGroupModelId": questGroupModelId,
		"questGroupName":    questGroupName,
		"statistics":        statistics,
		"distributions":     distributions,
		"questModels":       questModels,
	}
}

func (p QuestQuestGroupModel) Pointer() *QuestQuestGroupModel {
	return &p
}

func CastQuestQuestGroupModels(data []interface{}) []QuestQuestGroupModel {
	v := make([]QuestQuestGroupModel, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelsFromDict(data []QuestQuestGroupModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespaceStatistics struct {
	StartQuest     *int64   `json:"startQuest"`
	EndQuest       *int64   `json:"endQuest"`
	Successful     *int64   `json:"successful"`
	SuccessfulRate *float32 `json:"successfulRate"`
}

func (p *QuestNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespaceStatistics{}
	} else {
		*p = QuestNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["startQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.StartQuest)
		}
		if v, ok := d["endQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EndQuest)
		}
		if v, ok := d["successful"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Successful)
		}
		if v, ok := d["successfulRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SuccessfulRate)
		}
	}
	return nil
}

func NewQuestNamespaceStatisticsFromJson(data string) QuestNamespaceStatistics {
	req := QuestNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceStatisticsFromDict(data map[string]interface{}) QuestNamespaceStatistics {
	return QuestNamespaceStatistics{
		StartQuest:     core.CastInt64(data["startQuest"]),
		EndQuest:       core.CastInt64(data["endQuest"]),
		Successful:     core.CastInt64(data["successful"]),
		SuccessfulRate: core.CastFloat32(data["successfulRate"]),
	}
}

func (p QuestNamespaceStatistics) ToDict() map[string]interface{} {

	var startQuest *int64
	if p.StartQuest != nil {
		startQuest = p.StartQuest
	}
	var endQuest *int64
	if p.EndQuest != nil {
		endQuest = p.EndQuest
	}
	var successful *int64
	if p.Successful != nil {
		successful = p.Successful
	}
	var successfulRate *float32
	if p.SuccessfulRate != nil {
		successfulRate = p.SuccessfulRate
	}
	return map[string]interface{}{
		"startQuest":     startQuest,
		"endQuest":       endQuest,
		"successful":     successful,
		"successfulRate": successfulRate,
	}
}

func (p QuestNamespaceStatistics) Pointer() *QuestNamespaceStatistics {
	return &p
}

func CastQuestNamespaceStatisticses(data []interface{}) []QuestNamespaceStatistics {
	v := make([]QuestNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespaceStatisticsesFromDict(data []QuestNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespaceQuestDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *QuestNamespaceQuestDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespaceQuestDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespaceQuestDistributionStatistics{}
	} else {
		*p = QuestNamespaceQuestDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewQuestNamespaceQuestDistributionStatisticsFromJson(data string) QuestNamespaceQuestDistributionStatistics {
	req := QuestNamespaceQuestDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceQuestDistributionStatisticsFromDict(data map[string]interface{}) QuestNamespaceQuestDistributionStatistics {
	return QuestNamespaceQuestDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p QuestNamespaceQuestDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p QuestNamespaceQuestDistributionStatistics) Pointer() *QuestNamespaceQuestDistributionStatistics {
	return &p
}

func CastQuestNamespaceQuestDistributionStatisticses(data []interface{}) []QuestNamespaceQuestDistributionStatistics {
	v := make([]QuestNamespaceQuestDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceQuestDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespaceQuestDistributionStatisticsesFromDict(data []QuestNamespaceQuestDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespaceQuestDistributionSegment struct {
	QuestGroupName *string `json:"questGroupName"`
	Count          *int64  `json:"count"`
}

func (p *QuestNamespaceQuestDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespaceQuestDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespaceQuestDistributionSegment{}
	} else {
		*p = QuestNamespaceQuestDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["questGroupName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestGroupName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestGroupName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestGroupName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestGroupName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewQuestNamespaceQuestDistributionSegmentFromJson(data string) QuestNamespaceQuestDistributionSegment {
	req := QuestNamespaceQuestDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceQuestDistributionSegmentFromDict(data map[string]interface{}) QuestNamespaceQuestDistributionSegment {
	return QuestNamespaceQuestDistributionSegment{
		QuestGroupName: core.CastString(data["questGroupName"]),
		Count:          core.CastInt64(data["count"]),
	}
}

func (p QuestNamespaceQuestDistributionSegment) ToDict() map[string]interface{} {

	var questGroupName *string
	if p.QuestGroupName != nil {
		questGroupName = p.QuestGroupName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"questGroupName": questGroupName,
		"count":          count,
	}
}

func (p QuestNamespaceQuestDistributionSegment) Pointer() *QuestNamespaceQuestDistributionSegment {
	return &p
}

func CastQuestNamespaceQuestDistributionSegments(data []interface{}) []QuestNamespaceQuestDistributionSegment {
	v := make([]QuestNamespaceQuestDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceQuestDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespaceQuestDistributionSegmentsFromDict(data []QuestNamespaceQuestDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespaceQuestDistribution struct {
	Statistics   *QuestNamespaceQuestDistributionStatistics `json:"statistics"`
	Distribution []QuestNamespaceQuestDistributionSegment   `json:"distribution"`
}

func (p *QuestNamespaceQuestDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespaceQuestDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespaceQuestDistribution{}
	} else {
		*p = QuestNamespaceQuestDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewQuestNamespaceQuestDistributionFromJson(data string) QuestNamespaceQuestDistribution {
	req := QuestNamespaceQuestDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceQuestDistributionFromDict(data map[string]interface{}) QuestNamespaceQuestDistribution {
	return QuestNamespaceQuestDistribution{
		Statistics:   NewQuestNamespaceQuestDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastQuestNamespaceQuestDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p QuestNamespaceQuestDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastQuestNamespaceQuestDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p QuestNamespaceQuestDistribution) Pointer() *QuestNamespaceQuestDistribution {
	return &p
}

func CastQuestNamespaceQuestDistributions(data []interface{}) []QuestNamespaceQuestDistribution {
	v := make([]QuestNamespaceQuestDistribution, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceQuestDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespaceQuestDistributionsFromDict(data []QuestNamespaceQuestDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespaceDistributions struct {
	Quest *QuestNamespaceQuestDistribution `json:"quest"`
}

func (p *QuestNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespaceDistributions{}
	} else {
		*p = QuestNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["quest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Quest)
		}
	}
	return nil
}

func NewQuestNamespaceDistributionsFromJson(data string) QuestNamespaceDistributions {
	req := QuestNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceDistributionsFromDict(data map[string]interface{}) QuestNamespaceDistributions {
	return QuestNamespaceDistributions{
		Quest: NewQuestNamespaceQuestDistributionFromDict(core.CastMap(data["quest"])).Pointer(),
	}
}

func (p QuestNamespaceDistributions) ToDict() map[string]interface{} {

	var quest map[string]interface{}
	if p.Quest != nil {
		quest = p.Quest.ToDict()
	}
	return map[string]interface{}{
		"quest": quest,
	}
}

func (p QuestNamespaceDistributions) Pointer() *QuestNamespaceDistributions {
	return &p
}

func CastQuestNamespaceDistributionses(data []interface{}) []QuestNamespaceDistributions {
	v := make([]QuestNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespaceDistributionsesFromDict(data []QuestNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespace struct {
	NamespaceId      *string                      `json:"namespaceId"`
	Year             *int32                       `json:"year"`
	Month            *int32                       `json:"month"`
	Day              *int32                       `json:"day"`
	NamespaceName    *string                      `json:"namespaceName"`
	Statistics       *QuestNamespaceStatistics    `json:"statistics"`
	Distributions    *QuestNamespaceDistributions `json:"distributions"`
	QuestGroupModels []QuestQuestGroupModel       `json:"questGroupModels"`
}

func (p *QuestNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespace{}
	} else {
		*p = QuestNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["questGroupModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.QuestGroupModels)
		}
	}
	return nil
}

func NewQuestNamespaceFromJson(data string) QuestNamespace {
	req := QuestNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceFromDict(data map[string]interface{}) QuestNamespace {
	return QuestNamespace{
		NamespaceId:      core.CastString(data["namespaceId"]),
		Year:             core.CastInt32(data["year"]),
		Month:            core.CastInt32(data["month"]),
		Day:              core.CastInt32(data["day"]),
		NamespaceName:    core.CastString(data["namespaceName"]),
		Statistics:       NewQuestNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions:    NewQuestNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		QuestGroupModels: CastQuestQuestGroupModels(core.CastArray(data["questGroupModels"])),
	}
}

func (p QuestNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var questGroupModels []interface{}
	if p.QuestGroupModels != nil {
		questGroupModels = CastQuestQuestGroupModelsFromDict(
			p.QuestGroupModels,
		)
	}
	return map[string]interface{}{
		"namespaceId":      namespaceId,
		"year":             year,
		"month":            month,
		"day":              day,
		"namespaceName":    namespaceName,
		"statistics":       statistics,
		"distributions":    distributions,
		"questGroupModels": questGroupModels,
	}
}

func (p QuestNamespace) Pointer() *QuestNamespace {
	return &p
}

func CastQuestNamespaces(data []interface{}) []QuestNamespace {
	v := make([]QuestNamespace, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespacesFromDict(data []QuestNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModelStatistics struct {
	Put *int64 `json:"put"`
}

func (p *RankingCategoryModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModelStatistics{}
	} else {
		*p = RankingCategoryModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["put"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Put)
		}
	}
	return nil
}

func NewRankingCategoryModelStatisticsFromJson(data string) RankingCategoryModelStatistics {
	req := RankingCategoryModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelStatisticsFromDict(data map[string]interface{}) RankingCategoryModelStatistics {
	return RankingCategoryModelStatistics{
		Put: core.CastInt64(data["put"]),
	}
}

func (p RankingCategoryModelStatistics) ToDict() map[string]interface{} {

	var put *int64
	if p.Put != nil {
		put = p.Put
	}
	return map[string]interface{}{
		"put": put,
	}
}

func (p RankingCategoryModelStatistics) Pointer() *RankingCategoryModelStatistics {
	return &p
}

func CastRankingCategoryModelStatisticses(data []interface{}) []RankingCategoryModelStatistics {
	v := make([]RankingCategoryModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelStatisticsesFromDict(data []RankingCategoryModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModelScoreDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *RankingCategoryModelScoreDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModelScoreDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModelScoreDistributionStatistics{}
	} else {
		*p = RankingCategoryModelScoreDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewRankingCategoryModelScoreDistributionStatisticsFromJson(data string) RankingCategoryModelScoreDistributionStatistics {
	req := RankingCategoryModelScoreDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelScoreDistributionStatisticsFromDict(data map[string]interface{}) RankingCategoryModelScoreDistributionStatistics {
	return RankingCategoryModelScoreDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p RankingCategoryModelScoreDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p RankingCategoryModelScoreDistributionStatistics) Pointer() *RankingCategoryModelScoreDistributionStatistics {
	return &p
}

func CastRankingCategoryModelScoreDistributionStatisticses(data []interface{}) []RankingCategoryModelScoreDistributionStatistics {
	v := make([]RankingCategoryModelScoreDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelScoreDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelScoreDistributionStatisticsesFromDict(data []RankingCategoryModelScoreDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModelScoreDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *RankingCategoryModelScoreDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModelScoreDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModelScoreDistributionSegment{}
	} else {
		*p = RankingCategoryModelScoreDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewRankingCategoryModelScoreDistributionSegmentFromJson(data string) RankingCategoryModelScoreDistributionSegment {
	req := RankingCategoryModelScoreDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelScoreDistributionSegmentFromDict(data map[string]interface{}) RankingCategoryModelScoreDistributionSegment {
	return RankingCategoryModelScoreDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p RankingCategoryModelScoreDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p RankingCategoryModelScoreDistributionSegment) Pointer() *RankingCategoryModelScoreDistributionSegment {
	return &p
}

func CastRankingCategoryModelScoreDistributionSegments(data []interface{}) []RankingCategoryModelScoreDistributionSegment {
	v := make([]RankingCategoryModelScoreDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelScoreDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelScoreDistributionSegmentsFromDict(data []RankingCategoryModelScoreDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModelScoreDistribution struct {
	Statistics   *RankingCategoryModelScoreDistributionStatistics `json:"statistics"`
	Distribution []RankingCategoryModelScoreDistributionSegment   `json:"distribution"`
}

func (p *RankingCategoryModelScoreDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModelScoreDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModelScoreDistribution{}
	} else {
		*p = RankingCategoryModelScoreDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewRankingCategoryModelScoreDistributionFromJson(data string) RankingCategoryModelScoreDistribution {
	req := RankingCategoryModelScoreDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelScoreDistributionFromDict(data map[string]interface{}) RankingCategoryModelScoreDistribution {
	return RankingCategoryModelScoreDistribution{
		Statistics:   NewRankingCategoryModelScoreDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastRankingCategoryModelScoreDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p RankingCategoryModelScoreDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastRankingCategoryModelScoreDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p RankingCategoryModelScoreDistribution) Pointer() *RankingCategoryModelScoreDistribution {
	return &p
}

func CastRankingCategoryModelScoreDistributions(data []interface{}) []RankingCategoryModelScoreDistribution {
	v := make([]RankingCategoryModelScoreDistribution, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelScoreDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelScoreDistributionsFromDict(data []RankingCategoryModelScoreDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModelDistributions struct {
	Score *RankingCategoryModelScoreDistribution `json:"score"`
}

func (p *RankingCategoryModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModelDistributions{}
	} else {
		*p = RankingCategoryModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["score"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Score)
		}
	}
	return nil
}

func NewRankingCategoryModelDistributionsFromJson(data string) RankingCategoryModelDistributions {
	req := RankingCategoryModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelDistributionsFromDict(data map[string]interface{}) RankingCategoryModelDistributions {
	return RankingCategoryModelDistributions{
		Score: NewRankingCategoryModelScoreDistributionFromDict(core.CastMap(data["score"])).Pointer(),
	}
}

func (p RankingCategoryModelDistributions) ToDict() map[string]interface{} {

	var score map[string]interface{}
	if p.Score != nil {
		score = p.Score.ToDict()
	}
	return map[string]interface{}{
		"score": score,
	}
}

func (p RankingCategoryModelDistributions) Pointer() *RankingCategoryModelDistributions {
	return &p
}

func CastRankingCategoryModelDistributionses(data []interface{}) []RankingCategoryModelDistributions {
	v := make([]RankingCategoryModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelDistributionsesFromDict(data []RankingCategoryModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModel struct {
	CategoryModelId *string                            `json:"categoryModelId"`
	CategoryName    *string                            `json:"categoryName"`
	Statistics      *RankingCategoryModelStatistics    `json:"statistics"`
	Distributions   *RankingCategoryModelDistributions `json:"distributions"`
}

func (p *RankingCategoryModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModel{}
	} else {
		*p = RankingCategoryModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["categoryModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CategoryModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CategoryModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CategoryModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CategoryModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CategoryModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CategoryModelId)
				}
			}
		}
		if v, ok := d["categoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CategoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CategoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CategoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CategoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CategoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CategoryName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewRankingCategoryModelFromJson(data string) RankingCategoryModel {
	req := RankingCategoryModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelFromDict(data map[string]interface{}) RankingCategoryModel {
	return RankingCategoryModel{
		CategoryModelId: core.CastString(data["categoryModelId"]),
		CategoryName:    core.CastString(data["categoryName"]),
		Statistics:      NewRankingCategoryModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions:   NewRankingCategoryModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p RankingCategoryModel) ToDict() map[string]interface{} {

	var categoryModelId *string
	if p.CategoryModelId != nil {
		categoryModelId = p.CategoryModelId
	}
	var categoryName *string
	if p.CategoryName != nil {
		categoryName = p.CategoryName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"categoryModelId": categoryModelId,
		"categoryName":    categoryName,
		"statistics":      statistics,
		"distributions":   distributions,
	}
}

func (p RankingCategoryModel) Pointer() *RankingCategoryModel {
	return &p
}

func CastRankingCategoryModels(data []interface{}) []RankingCategoryModel {
	v := make([]RankingCategoryModel, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelsFromDict(data []RankingCategoryModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespaceStatistics struct {
	Put *int64 `json:"put"`
}

func (p *RankingNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespaceStatistics{}
	} else {
		*p = RankingNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["put"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Put)
		}
	}
	return nil
}

func NewRankingNamespaceStatisticsFromJson(data string) RankingNamespaceStatistics {
	req := RankingNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespaceStatisticsFromDict(data map[string]interface{}) RankingNamespaceStatistics {
	return RankingNamespaceStatistics{
		Put: core.CastInt64(data["put"]),
	}
}

func (p RankingNamespaceStatistics) ToDict() map[string]interface{} {

	var put *int64
	if p.Put != nil {
		put = p.Put
	}
	return map[string]interface{}{
		"put": put,
	}
}

func (p RankingNamespaceStatistics) Pointer() *RankingNamespaceStatistics {
	return &p
}

func CastRankingNamespaceStatisticses(data []interface{}) []RankingNamespaceStatistics {
	v := make([]RankingNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespaceStatisticsesFromDict(data []RankingNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespacePutDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *RankingNamespacePutDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespacePutDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespacePutDistributionStatistics{}
	} else {
		*p = RankingNamespacePutDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewRankingNamespacePutDistributionStatisticsFromJson(data string) RankingNamespacePutDistributionStatistics {
	req := RankingNamespacePutDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespacePutDistributionStatisticsFromDict(data map[string]interface{}) RankingNamespacePutDistributionStatistics {
	return RankingNamespacePutDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p RankingNamespacePutDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p RankingNamespacePutDistributionStatistics) Pointer() *RankingNamespacePutDistributionStatistics {
	return &p
}

func CastRankingNamespacePutDistributionStatisticses(data []interface{}) []RankingNamespacePutDistributionStatistics {
	v := make([]RankingNamespacePutDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespacePutDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespacePutDistributionStatisticsesFromDict(data []RankingNamespacePutDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespacePutDistributionSegment struct {
	CategoryName *string `json:"categoryName"`
	Count        *int64  `json:"count"`
}

func (p *RankingNamespacePutDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespacePutDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespacePutDistributionSegment{}
	} else {
		*p = RankingNamespacePutDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["categoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CategoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CategoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CategoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CategoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CategoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CategoryName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewRankingNamespacePutDistributionSegmentFromJson(data string) RankingNamespacePutDistributionSegment {
	req := RankingNamespacePutDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespacePutDistributionSegmentFromDict(data map[string]interface{}) RankingNamespacePutDistributionSegment {
	return RankingNamespacePutDistributionSegment{
		CategoryName: core.CastString(data["categoryName"]),
		Count:        core.CastInt64(data["count"]),
	}
}

func (p RankingNamespacePutDistributionSegment) ToDict() map[string]interface{} {

	var categoryName *string
	if p.CategoryName != nil {
		categoryName = p.CategoryName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"categoryName": categoryName,
		"count":        count,
	}
}

func (p RankingNamespacePutDistributionSegment) Pointer() *RankingNamespacePutDistributionSegment {
	return &p
}

func CastRankingNamespacePutDistributionSegments(data []interface{}) []RankingNamespacePutDistributionSegment {
	v := make([]RankingNamespacePutDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespacePutDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespacePutDistributionSegmentsFromDict(data []RankingNamespacePutDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespacePutDistribution struct {
	Statistics   *RankingNamespacePutDistributionStatistics `json:"statistics"`
	Distribution []RankingNamespacePutDistributionSegment   `json:"distribution"`
}

func (p *RankingNamespacePutDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespacePutDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespacePutDistribution{}
	} else {
		*p = RankingNamespacePutDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewRankingNamespacePutDistributionFromJson(data string) RankingNamespacePutDistribution {
	req := RankingNamespacePutDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespacePutDistributionFromDict(data map[string]interface{}) RankingNamespacePutDistribution {
	return RankingNamespacePutDistribution{
		Statistics:   NewRankingNamespacePutDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastRankingNamespacePutDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p RankingNamespacePutDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastRankingNamespacePutDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p RankingNamespacePutDistribution) Pointer() *RankingNamespacePutDistribution {
	return &p
}

func CastRankingNamespacePutDistributions(data []interface{}) []RankingNamespacePutDistribution {
	v := make([]RankingNamespacePutDistribution, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespacePutDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespacePutDistributionsFromDict(data []RankingNamespacePutDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespaceDistributions struct {
	Put *RankingNamespacePutDistribution `json:"put"`
}

func (p *RankingNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespaceDistributions{}
	} else {
		*p = RankingNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["put"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Put)
		}
	}
	return nil
}

func NewRankingNamespaceDistributionsFromJson(data string) RankingNamespaceDistributions {
	req := RankingNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespaceDistributionsFromDict(data map[string]interface{}) RankingNamespaceDistributions {
	return RankingNamespaceDistributions{
		Put: NewRankingNamespacePutDistributionFromDict(core.CastMap(data["put"])).Pointer(),
	}
}

func (p RankingNamespaceDistributions) ToDict() map[string]interface{} {

	var put map[string]interface{}
	if p.Put != nil {
		put = p.Put.ToDict()
	}
	return map[string]interface{}{
		"put": put,
	}
}

func (p RankingNamespaceDistributions) Pointer() *RankingNamespaceDistributions {
	return &p
}

func CastRankingNamespaceDistributionses(data []interface{}) []RankingNamespaceDistributions {
	v := make([]RankingNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespaceDistributionsesFromDict(data []RankingNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespace struct {
	NamespaceId    *string                        `json:"namespaceId"`
	Year           *int32                         `json:"year"`
	Month          *int32                         `json:"month"`
	Day            *int32                         `json:"day"`
	NamespaceName  *string                        `json:"namespaceName"`
	Statistics     *RankingNamespaceStatistics    `json:"statistics"`
	Distributions  *RankingNamespaceDistributions `json:"distributions"`
	CategoryModels []RankingCategoryModel         `json:"categoryModels"`
}

func (p *RankingNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespace{}
	} else {
		*p = RankingNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["categoryModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CategoryModels)
		}
	}
	return nil
}

func NewRankingNamespaceFromJson(data string) RankingNamespace {
	req := RankingNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespaceFromDict(data map[string]interface{}) RankingNamespace {
	return RankingNamespace{
		NamespaceId:    core.CastString(data["namespaceId"]),
		Year:           core.CastInt32(data["year"]),
		Month:          core.CastInt32(data["month"]),
		Day:            core.CastInt32(data["day"]),
		NamespaceName:  core.CastString(data["namespaceName"]),
		Statistics:     NewRankingNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions:  NewRankingNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		CategoryModels: CastRankingCategoryModels(core.CastArray(data["categoryModels"])),
	}
}

func (p RankingNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var categoryModels []interface{}
	if p.CategoryModels != nil {
		categoryModels = CastRankingCategoryModelsFromDict(
			p.CategoryModels,
		)
	}
	return map[string]interface{}{
		"namespaceId":    namespaceId,
		"year":           year,
		"month":          month,
		"day":            day,
		"namespaceName":  namespaceName,
		"statistics":     statistics,
		"distributions":  distributions,
		"categoryModels": categoryModels,
	}
}

func (p RankingNamespace) Pointer() *RankingNamespace {
	return &p
}

func CastRankingNamespaces(data []interface{}) []RankingNamespace {
	v := make([]RankingNamespace, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespacesFromDict(data []RankingNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItemStatistics struct {
	Buy *int64 `json:"buy"`
}

func (p *ShowcaseDisplayItemStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItemStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItemStatistics{}
	} else {
		*p = ShowcaseDisplayItemStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["buy"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Buy)
		}
	}
	return nil
}

func NewShowcaseDisplayItemStatisticsFromJson(data string) ShowcaseDisplayItemStatistics {
	req := ShowcaseDisplayItemStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemStatisticsFromDict(data map[string]interface{}) ShowcaseDisplayItemStatistics {
	return ShowcaseDisplayItemStatistics{
		Buy: core.CastInt64(data["buy"]),
	}
}

func (p ShowcaseDisplayItemStatistics) ToDict() map[string]interface{} {

	var buy *int64
	if p.Buy != nil {
		buy = p.Buy
	}
	return map[string]interface{}{
		"buy": buy,
	}
}

func (p ShowcaseDisplayItemStatistics) Pointer() *ShowcaseDisplayItemStatistics {
	return &p
}

func CastShowcaseDisplayItemStatisticses(data []interface{}) []ShowcaseDisplayItemStatistics {
	v := make([]ShowcaseDisplayItemStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemStatisticsesFromDict(data []ShowcaseDisplayItemStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItemQuantityDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ShowcaseDisplayItemQuantityDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItemQuantityDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItemQuantityDistributionStatistics{}
	} else {
		*p = ShowcaseDisplayItemQuantityDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewShowcaseDisplayItemQuantityDistributionStatisticsFromJson(data string) ShowcaseDisplayItemQuantityDistributionStatistics {
	req := ShowcaseDisplayItemQuantityDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemQuantityDistributionStatisticsFromDict(data map[string]interface{}) ShowcaseDisplayItemQuantityDistributionStatistics {
	return ShowcaseDisplayItemQuantityDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ShowcaseDisplayItemQuantityDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ShowcaseDisplayItemQuantityDistributionStatistics) Pointer() *ShowcaseDisplayItemQuantityDistributionStatistics {
	return &p
}

func CastShowcaseDisplayItemQuantityDistributionStatisticses(data []interface{}) []ShowcaseDisplayItemQuantityDistributionStatistics {
	v := make([]ShowcaseDisplayItemQuantityDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemQuantityDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemQuantityDistributionStatisticsesFromDict(data []ShowcaseDisplayItemQuantityDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItemQuantityDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ShowcaseDisplayItemQuantityDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItemQuantityDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItemQuantityDistributionSegment{}
	} else {
		*p = ShowcaseDisplayItemQuantityDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewShowcaseDisplayItemQuantityDistributionSegmentFromJson(data string) ShowcaseDisplayItemQuantityDistributionSegment {
	req := ShowcaseDisplayItemQuantityDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemQuantityDistributionSegmentFromDict(data map[string]interface{}) ShowcaseDisplayItemQuantityDistributionSegment {
	return ShowcaseDisplayItemQuantityDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p ShowcaseDisplayItemQuantityDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p ShowcaseDisplayItemQuantityDistributionSegment) Pointer() *ShowcaseDisplayItemQuantityDistributionSegment {
	return &p
}

func CastShowcaseDisplayItemQuantityDistributionSegments(data []interface{}) []ShowcaseDisplayItemQuantityDistributionSegment {
	v := make([]ShowcaseDisplayItemQuantityDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemQuantityDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemQuantityDistributionSegmentsFromDict(data []ShowcaseDisplayItemQuantityDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItemQuantityDistribution struct {
	Statistics   *ShowcaseDisplayItemQuantityDistributionStatistics `json:"statistics"`
	Distribution []ShowcaseDisplayItemQuantityDistributionSegment   `json:"distribution"`
}

func (p *ShowcaseDisplayItemQuantityDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItemQuantityDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItemQuantityDistribution{}
	} else {
		*p = ShowcaseDisplayItemQuantityDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewShowcaseDisplayItemQuantityDistributionFromJson(data string) ShowcaseDisplayItemQuantityDistribution {
	req := ShowcaseDisplayItemQuantityDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemQuantityDistributionFromDict(data map[string]interface{}) ShowcaseDisplayItemQuantityDistribution {
	return ShowcaseDisplayItemQuantityDistribution{
		Statistics:   NewShowcaseDisplayItemQuantityDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastShowcaseDisplayItemQuantityDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ShowcaseDisplayItemQuantityDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastShowcaseDisplayItemQuantityDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ShowcaseDisplayItemQuantityDistribution) Pointer() *ShowcaseDisplayItemQuantityDistribution {
	return &p
}

func CastShowcaseDisplayItemQuantityDistributions(data []interface{}) []ShowcaseDisplayItemQuantityDistribution {
	v := make([]ShowcaseDisplayItemQuantityDistribution, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemQuantityDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemQuantityDistributionsFromDict(data []ShowcaseDisplayItemQuantityDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItemDistributions struct {
	Quantity *ShowcaseDisplayItemQuantityDistribution `json:"quantity"`
}

func (p *ShowcaseDisplayItemDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItemDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItemDistributions{}
	} else {
		*p = ShowcaseDisplayItemDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["quantity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Quantity)
		}
	}
	return nil
}

func NewShowcaseDisplayItemDistributionsFromJson(data string) ShowcaseDisplayItemDistributions {
	req := ShowcaseDisplayItemDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemDistributionsFromDict(data map[string]interface{}) ShowcaseDisplayItemDistributions {
	return ShowcaseDisplayItemDistributions{
		Quantity: NewShowcaseDisplayItemQuantityDistributionFromDict(core.CastMap(data["quantity"])).Pointer(),
	}
}

func (p ShowcaseDisplayItemDistributions) ToDict() map[string]interface{} {

	var quantity map[string]interface{}
	if p.Quantity != nil {
		quantity = p.Quantity.ToDict()
	}
	return map[string]interface{}{
		"quantity": quantity,
	}
}

func (p ShowcaseDisplayItemDistributions) Pointer() *ShowcaseDisplayItemDistributions {
	return &p
}

func CastShowcaseDisplayItemDistributionses(data []interface{}) []ShowcaseDisplayItemDistributions {
	v := make([]ShowcaseDisplayItemDistributions, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemDistributionsesFromDict(data []ShowcaseDisplayItemDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItem struct {
	DisplayItemId *string                           `json:"displayItemId"`
	Statistics    *ShowcaseDisplayItemStatistics    `json:"statistics"`
	Distributions *ShowcaseDisplayItemDistributions `json:"distributions"`
}

func (p *ShowcaseDisplayItem) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItem{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItem{}
	} else {
		*p = ShowcaseDisplayItem{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["displayItemId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.DisplayItemId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.DisplayItemId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.DisplayItemId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.DisplayItemId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.DisplayItemId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.DisplayItemId)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewShowcaseDisplayItemFromJson(data string) ShowcaseDisplayItem {
	req := ShowcaseDisplayItem{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemFromDict(data map[string]interface{}) ShowcaseDisplayItem {
	return ShowcaseDisplayItem{
		DisplayItemId: core.CastString(data["displayItemId"]),
		Statistics:    NewShowcaseDisplayItemStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewShowcaseDisplayItemDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p ShowcaseDisplayItem) ToDict() map[string]interface{} {

	var displayItemId *string
	if p.DisplayItemId != nil {
		displayItemId = p.DisplayItemId
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"displayItemId": displayItemId,
		"statistics":    statistics,
		"distributions": distributions,
	}
}

func (p ShowcaseDisplayItem) Pointer() *ShowcaseDisplayItem {
	return &p
}

func CastShowcaseDisplayItems(data []interface{}) []ShowcaseDisplayItem {
	v := make([]ShowcaseDisplayItem, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemsFromDict(data []ShowcaseDisplayItem) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcaseStatistics struct {
	Buy *int64 `json:"buy"`
}

func (p *ShowcaseShowcaseStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcaseStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcaseStatistics{}
	} else {
		*p = ShowcaseShowcaseStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["buy"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Buy)
		}
	}
	return nil
}

func NewShowcaseShowcaseStatisticsFromJson(data string) ShowcaseShowcaseStatistics {
	req := ShowcaseShowcaseStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseStatisticsFromDict(data map[string]interface{}) ShowcaseShowcaseStatistics {
	return ShowcaseShowcaseStatistics{
		Buy: core.CastInt64(data["buy"]),
	}
}

func (p ShowcaseShowcaseStatistics) ToDict() map[string]interface{} {

	var buy *int64
	if p.Buy != nil {
		buy = p.Buy
	}
	return map[string]interface{}{
		"buy": buy,
	}
}

func (p ShowcaseShowcaseStatistics) Pointer() *ShowcaseShowcaseStatistics {
	return &p
}

func CastShowcaseShowcaseStatisticses(data []interface{}) []ShowcaseShowcaseStatistics {
	v := make([]ShowcaseShowcaseStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcaseStatisticsesFromDict(data []ShowcaseShowcaseStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcaseBuyDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ShowcaseShowcaseBuyDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcaseBuyDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcaseBuyDistributionStatistics{}
	} else {
		*p = ShowcaseShowcaseBuyDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewShowcaseShowcaseBuyDistributionStatisticsFromJson(data string) ShowcaseShowcaseBuyDistributionStatistics {
	req := ShowcaseShowcaseBuyDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseBuyDistributionStatisticsFromDict(data map[string]interface{}) ShowcaseShowcaseBuyDistributionStatistics {
	return ShowcaseShowcaseBuyDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ShowcaseShowcaseBuyDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ShowcaseShowcaseBuyDistributionStatistics) Pointer() *ShowcaseShowcaseBuyDistributionStatistics {
	return &p
}

func CastShowcaseShowcaseBuyDistributionStatisticses(data []interface{}) []ShowcaseShowcaseBuyDistributionStatistics {
	v := make([]ShowcaseShowcaseBuyDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseBuyDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcaseBuyDistributionStatisticsesFromDict(data []ShowcaseShowcaseBuyDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcaseBuyDistributionSegment struct {
	DisplayItemId *string `json:"displayItemId"`
	Count         *int64  `json:"count"`
}

func (p *ShowcaseShowcaseBuyDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcaseBuyDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcaseBuyDistributionSegment{}
	} else {
		*p = ShowcaseShowcaseBuyDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["displayItemId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.DisplayItemId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.DisplayItemId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.DisplayItemId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.DisplayItemId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.DisplayItemId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.DisplayItemId)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewShowcaseShowcaseBuyDistributionSegmentFromJson(data string) ShowcaseShowcaseBuyDistributionSegment {
	req := ShowcaseShowcaseBuyDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseBuyDistributionSegmentFromDict(data map[string]interface{}) ShowcaseShowcaseBuyDistributionSegment {
	return ShowcaseShowcaseBuyDistributionSegment{
		DisplayItemId: core.CastString(data["displayItemId"]),
		Count:         core.CastInt64(data["count"]),
	}
}

func (p ShowcaseShowcaseBuyDistributionSegment) ToDict() map[string]interface{} {

	var displayItemId *string
	if p.DisplayItemId != nil {
		displayItemId = p.DisplayItemId
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"displayItemId": displayItemId,
		"count":         count,
	}
}

func (p ShowcaseShowcaseBuyDistributionSegment) Pointer() *ShowcaseShowcaseBuyDistributionSegment {
	return &p
}

func CastShowcaseShowcaseBuyDistributionSegments(data []interface{}) []ShowcaseShowcaseBuyDistributionSegment {
	v := make([]ShowcaseShowcaseBuyDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseBuyDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcaseBuyDistributionSegmentsFromDict(data []ShowcaseShowcaseBuyDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcaseBuyDistribution struct {
	Statistics   *ShowcaseShowcaseBuyDistributionStatistics `json:"statistics"`
	Distribution []ShowcaseShowcaseBuyDistributionSegment   `json:"distribution"`
}

func (p *ShowcaseShowcaseBuyDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcaseBuyDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcaseBuyDistribution{}
	} else {
		*p = ShowcaseShowcaseBuyDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewShowcaseShowcaseBuyDistributionFromJson(data string) ShowcaseShowcaseBuyDistribution {
	req := ShowcaseShowcaseBuyDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseBuyDistributionFromDict(data map[string]interface{}) ShowcaseShowcaseBuyDistribution {
	return ShowcaseShowcaseBuyDistribution{
		Statistics:   NewShowcaseShowcaseBuyDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastShowcaseShowcaseBuyDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ShowcaseShowcaseBuyDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastShowcaseShowcaseBuyDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ShowcaseShowcaseBuyDistribution) Pointer() *ShowcaseShowcaseBuyDistribution {
	return &p
}

func CastShowcaseShowcaseBuyDistributions(data []interface{}) []ShowcaseShowcaseBuyDistribution {
	v := make([]ShowcaseShowcaseBuyDistribution, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseBuyDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcaseBuyDistributionsFromDict(data []ShowcaseShowcaseBuyDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcaseDistributions struct {
	Buy *ShowcaseShowcaseBuyDistribution `json:"buy"`
}

func (p *ShowcaseShowcaseDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcaseDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcaseDistributions{}
	} else {
		*p = ShowcaseShowcaseDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["buy"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Buy)
		}
	}
	return nil
}

func NewShowcaseShowcaseDistributionsFromJson(data string) ShowcaseShowcaseDistributions {
	req := ShowcaseShowcaseDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseDistributionsFromDict(data map[string]interface{}) ShowcaseShowcaseDistributions {
	return ShowcaseShowcaseDistributions{
		Buy: NewShowcaseShowcaseBuyDistributionFromDict(core.CastMap(data["buy"])).Pointer(),
	}
}

func (p ShowcaseShowcaseDistributions) ToDict() map[string]interface{} {

	var buy map[string]interface{}
	if p.Buy != nil {
		buy = p.Buy.ToDict()
	}
	return map[string]interface{}{
		"buy": buy,
	}
}

func (p ShowcaseShowcaseDistributions) Pointer() *ShowcaseShowcaseDistributions {
	return &p
}

func CastShowcaseShowcaseDistributionses(data []interface{}) []ShowcaseShowcaseDistributions {
	v := make([]ShowcaseShowcaseDistributions, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcaseDistributionsesFromDict(data []ShowcaseShowcaseDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcase struct {
	ShowcaseId    *string                        `json:"showcaseId"`
	ShowcaseName  *string                        `json:"showcaseName"`
	Statistics    *ShowcaseShowcaseStatistics    `json:"statistics"`
	Distributions *ShowcaseShowcaseDistributions `json:"distributions"`
	DisplayItems  []ShowcaseDisplayItem          `json:"displayItems"`
}

func (p *ShowcaseShowcase) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcase{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcase{}
	} else {
		*p = ShowcaseShowcase{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["showcaseId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ShowcaseId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ShowcaseId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ShowcaseId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ShowcaseId)
				}
			}
		}
		if v, ok := d["showcaseName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ShowcaseName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ShowcaseName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ShowcaseName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ShowcaseName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["displayItems"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DisplayItems)
		}
	}
	return nil
}

func NewShowcaseShowcaseFromJson(data string) ShowcaseShowcase {
	req := ShowcaseShowcase{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseFromDict(data map[string]interface{}) ShowcaseShowcase {
	return ShowcaseShowcase{
		ShowcaseId:    core.CastString(data["showcaseId"]),
		ShowcaseName:  core.CastString(data["showcaseName"]),
		Statistics:    NewShowcaseShowcaseStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewShowcaseShowcaseDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		DisplayItems:  CastShowcaseDisplayItems(core.CastArray(data["displayItems"])),
	}
}

func (p ShowcaseShowcase) ToDict() map[string]interface{} {

	var showcaseId *string
	if p.ShowcaseId != nil {
		showcaseId = p.ShowcaseId
	}
	var showcaseName *string
	if p.ShowcaseName != nil {
		showcaseName = p.ShowcaseName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var displayItems []interface{}
	if p.DisplayItems != nil {
		displayItems = CastShowcaseDisplayItemsFromDict(
			p.DisplayItems,
		)
	}
	return map[string]interface{}{
		"showcaseId":    showcaseId,
		"showcaseName":  showcaseName,
		"statistics":    statistics,
		"distributions": distributions,
		"displayItems":  displayItems,
	}
}

func (p ShowcaseShowcase) Pointer() *ShowcaseShowcase {
	return &p
}

func CastShowcaseShowcases(data []interface{}) []ShowcaseShowcase {
	v := make([]ShowcaseShowcase, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcasesFromDict(data []ShowcaseShowcase) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespaceStatistics struct {
	Buy *int64 `json:"buy"`
}

func (p *ShowcaseNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespaceStatistics{}
	} else {
		*p = ShowcaseNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["buy"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Buy)
		}
	}
	return nil
}

func NewShowcaseNamespaceStatisticsFromJson(data string) ShowcaseNamespaceStatistics {
	req := ShowcaseNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceStatisticsFromDict(data map[string]interface{}) ShowcaseNamespaceStatistics {
	return ShowcaseNamespaceStatistics{
		Buy: core.CastInt64(data["buy"]),
	}
}

func (p ShowcaseNamespaceStatistics) ToDict() map[string]interface{} {

	var buy *int64
	if p.Buy != nil {
		buy = p.Buy
	}
	return map[string]interface{}{
		"buy": buy,
	}
}

func (p ShowcaseNamespaceStatistics) Pointer() *ShowcaseNamespaceStatistics {
	return &p
}

func CastShowcaseNamespaceStatisticses(data []interface{}) []ShowcaseNamespaceStatistics {
	v := make([]ShowcaseNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespaceStatisticsesFromDict(data []ShowcaseNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespaceBuyDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ShowcaseNamespaceBuyDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespaceBuyDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespaceBuyDistributionStatistics{}
	} else {
		*p = ShowcaseNamespaceBuyDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewShowcaseNamespaceBuyDistributionStatisticsFromJson(data string) ShowcaseNamespaceBuyDistributionStatistics {
	req := ShowcaseNamespaceBuyDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceBuyDistributionStatisticsFromDict(data map[string]interface{}) ShowcaseNamespaceBuyDistributionStatistics {
	return ShowcaseNamespaceBuyDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p ShowcaseNamespaceBuyDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p ShowcaseNamespaceBuyDistributionStatistics) Pointer() *ShowcaseNamespaceBuyDistributionStatistics {
	return &p
}

func CastShowcaseNamespaceBuyDistributionStatisticses(data []interface{}) []ShowcaseNamespaceBuyDistributionStatistics {
	v := make([]ShowcaseNamespaceBuyDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceBuyDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespaceBuyDistributionStatisticsesFromDict(data []ShowcaseNamespaceBuyDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespaceBuyDistributionSegment struct {
	ShowcaseName *string `json:"showcaseName"`
	Count        *int64  `json:"count"`
}

func (p *ShowcaseNamespaceBuyDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespaceBuyDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespaceBuyDistributionSegment{}
	} else {
		*p = ShowcaseNamespaceBuyDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["showcaseName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ShowcaseName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ShowcaseName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ShowcaseName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ShowcaseName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewShowcaseNamespaceBuyDistributionSegmentFromJson(data string) ShowcaseNamespaceBuyDistributionSegment {
	req := ShowcaseNamespaceBuyDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceBuyDistributionSegmentFromDict(data map[string]interface{}) ShowcaseNamespaceBuyDistributionSegment {
	return ShowcaseNamespaceBuyDistributionSegment{
		ShowcaseName: core.CastString(data["showcaseName"]),
		Count:        core.CastInt64(data["count"]),
	}
}

func (p ShowcaseNamespaceBuyDistributionSegment) ToDict() map[string]interface{} {

	var showcaseName *string
	if p.ShowcaseName != nil {
		showcaseName = p.ShowcaseName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"showcaseName": showcaseName,
		"count":        count,
	}
}

func (p ShowcaseNamespaceBuyDistributionSegment) Pointer() *ShowcaseNamespaceBuyDistributionSegment {
	return &p
}

func CastShowcaseNamespaceBuyDistributionSegments(data []interface{}) []ShowcaseNamespaceBuyDistributionSegment {
	v := make([]ShowcaseNamespaceBuyDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceBuyDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespaceBuyDistributionSegmentsFromDict(data []ShowcaseNamespaceBuyDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespaceBuyDistribution struct {
	Statistics   *ShowcaseNamespaceBuyDistributionStatistics `json:"statistics"`
	Distribution []ShowcaseNamespaceBuyDistributionSegment   `json:"distribution"`
}

func (p *ShowcaseNamespaceBuyDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespaceBuyDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespaceBuyDistribution{}
	} else {
		*p = ShowcaseNamespaceBuyDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewShowcaseNamespaceBuyDistributionFromJson(data string) ShowcaseNamespaceBuyDistribution {
	req := ShowcaseNamespaceBuyDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceBuyDistributionFromDict(data map[string]interface{}) ShowcaseNamespaceBuyDistribution {
	return ShowcaseNamespaceBuyDistribution{
		Statistics:   NewShowcaseNamespaceBuyDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastShowcaseNamespaceBuyDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p ShowcaseNamespaceBuyDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastShowcaseNamespaceBuyDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p ShowcaseNamespaceBuyDistribution) Pointer() *ShowcaseNamespaceBuyDistribution {
	return &p
}

func CastShowcaseNamespaceBuyDistributions(data []interface{}) []ShowcaseNamespaceBuyDistribution {
	v := make([]ShowcaseNamespaceBuyDistribution, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceBuyDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespaceBuyDistributionsFromDict(data []ShowcaseNamespaceBuyDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespaceDistributions struct {
	Buy *ShowcaseNamespaceBuyDistribution `json:"buy"`
}

func (p *ShowcaseNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespaceDistributions{}
	} else {
		*p = ShowcaseNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["buy"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Buy)
		}
	}
	return nil
}

func NewShowcaseNamespaceDistributionsFromJson(data string) ShowcaseNamespaceDistributions {
	req := ShowcaseNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceDistributionsFromDict(data map[string]interface{}) ShowcaseNamespaceDistributions {
	return ShowcaseNamespaceDistributions{
		Buy: NewShowcaseNamespaceBuyDistributionFromDict(core.CastMap(data["buy"])).Pointer(),
	}
}

func (p ShowcaseNamespaceDistributions) ToDict() map[string]interface{} {

	var buy map[string]interface{}
	if p.Buy != nil {
		buy = p.Buy.ToDict()
	}
	return map[string]interface{}{
		"buy": buy,
	}
}

func (p ShowcaseNamespaceDistributions) Pointer() *ShowcaseNamespaceDistributions {
	return &p
}

func CastShowcaseNamespaceDistributionses(data []interface{}) []ShowcaseNamespaceDistributions {
	v := make([]ShowcaseNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespaceDistributionsesFromDict(data []ShowcaseNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespace struct {
	NamespaceId   *string                         `json:"namespaceId"`
	Year          *int32                          `json:"year"`
	Month         *int32                          `json:"month"`
	Day           *int32                          `json:"day"`
	NamespaceName *string                         `json:"namespaceName"`
	Statistics    *ShowcaseNamespaceStatistics    `json:"statistics"`
	Distributions *ShowcaseNamespaceDistributions `json:"distributions"`
	Showcases     []ShowcaseShowcase              `json:"showcases"`
}

func (p *ShowcaseNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespace{}
	} else {
		*p = ShowcaseNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["showcases"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Showcases)
		}
	}
	return nil
}

func NewShowcaseNamespaceFromJson(data string) ShowcaseNamespace {
	req := ShowcaseNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceFromDict(data map[string]interface{}) ShowcaseNamespace {
	return ShowcaseNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewShowcaseNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewShowcaseNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		Showcases:     CastShowcaseShowcases(core.CastArray(data["showcases"])),
	}
}

func (p ShowcaseNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var showcases []interface{}
	if p.Showcases != nil {
		showcases = CastShowcaseShowcasesFromDict(
			p.Showcases,
		)
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
		"showcases":     showcases,
	}
}

func (p ShowcaseNamespace) Pointer() *ShowcaseNamespace {
	return &p
}

func CastShowcaseNamespaces(data []interface{}) []ShowcaseNamespace {
	v := make([]ShowcaseNamespace, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespacesFromDict(data []ShowcaseNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelStatistics struct {
	Consume       *int64 `json:"consume"`
	ConsumeAmount *int64 `json:"consumeAmount"`
	Recover       *int64 `json:"recover"`
	RecoverAmount *int64 `json:"recoverAmount"`
}

func (p *StaminaStaminaModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelStatistics{}
	} else {
		*p = StaminaStaminaModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["consumeAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ConsumeAmount)
		}
		if v, ok := d["recover"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Recover)
		}
		if v, ok := d["recoverAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RecoverAmount)
		}
	}
	return nil
}

func NewStaminaStaminaModelStatisticsFromJson(data string) StaminaStaminaModelStatistics {
	req := StaminaStaminaModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelStatisticsFromDict(data map[string]interface{}) StaminaStaminaModelStatistics {
	return StaminaStaminaModelStatistics{
		Consume:       core.CastInt64(data["consume"]),
		ConsumeAmount: core.CastInt64(data["consumeAmount"]),
		Recover:       core.CastInt64(data["recover"]),
		RecoverAmount: core.CastInt64(data["recoverAmount"]),
	}
}

func (p StaminaStaminaModelStatistics) ToDict() map[string]interface{} {

	var consume *int64
	if p.Consume != nil {
		consume = p.Consume
	}
	var consumeAmount *int64
	if p.ConsumeAmount != nil {
		consumeAmount = p.ConsumeAmount
	}
	var recover *int64
	if p.Recover != nil {
		recover = p.Recover
	}
	var recoverAmount *int64
	if p.RecoverAmount != nil {
		recoverAmount = p.RecoverAmount
	}
	return map[string]interface{}{
		"consume":       consume,
		"consumeAmount": consumeAmount,
		"recover":       recover,
		"recoverAmount": recoverAmount,
	}
}

func (p StaminaStaminaModelStatistics) Pointer() *StaminaStaminaModelStatistics {
	return &p
}

func CastStaminaStaminaModelStatisticses(data []interface{}) []StaminaStaminaModelStatistics {
	v := make([]StaminaStaminaModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelStatisticsesFromDict(data []StaminaStaminaModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelConsumeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *StaminaStaminaModelConsumeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelConsumeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelConsumeDistributionStatistics{}
	} else {
		*p = StaminaStaminaModelConsumeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewStaminaStaminaModelConsumeDistributionStatisticsFromJson(data string) StaminaStaminaModelConsumeDistributionStatistics {
	req := StaminaStaminaModelConsumeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelConsumeDistributionStatisticsFromDict(data map[string]interface{}) StaminaStaminaModelConsumeDistributionStatistics {
	return StaminaStaminaModelConsumeDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p StaminaStaminaModelConsumeDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p StaminaStaminaModelConsumeDistributionStatistics) Pointer() *StaminaStaminaModelConsumeDistributionStatistics {
	return &p
}

func CastStaminaStaminaModelConsumeDistributionStatisticses(data []interface{}) []StaminaStaminaModelConsumeDistributionStatistics {
	v := make([]StaminaStaminaModelConsumeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelConsumeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelConsumeDistributionStatisticsesFromDict(data []StaminaStaminaModelConsumeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelConsumeDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *StaminaStaminaModelConsumeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelConsumeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelConsumeDistributionSegment{}
	} else {
		*p = StaminaStaminaModelConsumeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewStaminaStaminaModelConsumeDistributionSegmentFromJson(data string) StaminaStaminaModelConsumeDistributionSegment {
	req := StaminaStaminaModelConsumeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelConsumeDistributionSegmentFromDict(data map[string]interface{}) StaminaStaminaModelConsumeDistributionSegment {
	return StaminaStaminaModelConsumeDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p StaminaStaminaModelConsumeDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p StaminaStaminaModelConsumeDistributionSegment) Pointer() *StaminaStaminaModelConsumeDistributionSegment {
	return &p
}

func CastStaminaStaminaModelConsumeDistributionSegments(data []interface{}) []StaminaStaminaModelConsumeDistributionSegment {
	v := make([]StaminaStaminaModelConsumeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelConsumeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelConsumeDistributionSegmentsFromDict(data []StaminaStaminaModelConsumeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelConsumeDistribution struct {
	Statistics   *StaminaStaminaModelConsumeDistributionStatistics `json:"statistics"`
	Distribution []StaminaStaminaModelConsumeDistributionSegment   `json:"distribution"`
}

func (p *StaminaStaminaModelConsumeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelConsumeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelConsumeDistribution{}
	} else {
		*p = StaminaStaminaModelConsumeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewStaminaStaminaModelConsumeDistributionFromJson(data string) StaminaStaminaModelConsumeDistribution {
	req := StaminaStaminaModelConsumeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelConsumeDistributionFromDict(data map[string]interface{}) StaminaStaminaModelConsumeDistribution {
	return StaminaStaminaModelConsumeDistribution{
		Statistics:   NewStaminaStaminaModelConsumeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastStaminaStaminaModelConsumeDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p StaminaStaminaModelConsumeDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastStaminaStaminaModelConsumeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p StaminaStaminaModelConsumeDistribution) Pointer() *StaminaStaminaModelConsumeDistribution {
	return &p
}

func CastStaminaStaminaModelConsumeDistributions(data []interface{}) []StaminaStaminaModelConsumeDistribution {
	v := make([]StaminaStaminaModelConsumeDistribution, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelConsumeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelConsumeDistributionsFromDict(data []StaminaStaminaModelConsumeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelRecoverDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *StaminaStaminaModelRecoverDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelRecoverDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelRecoverDistributionStatistics{}
	} else {
		*p = StaminaStaminaModelRecoverDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewStaminaStaminaModelRecoverDistributionStatisticsFromJson(data string) StaminaStaminaModelRecoverDistributionStatistics {
	req := StaminaStaminaModelRecoverDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelRecoverDistributionStatisticsFromDict(data map[string]interface{}) StaminaStaminaModelRecoverDistributionStatistics {
	return StaminaStaminaModelRecoverDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p StaminaStaminaModelRecoverDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p StaminaStaminaModelRecoverDistributionStatistics) Pointer() *StaminaStaminaModelRecoverDistributionStatistics {
	return &p
}

func CastStaminaStaminaModelRecoverDistributionStatisticses(data []interface{}) []StaminaStaminaModelRecoverDistributionStatistics {
	v := make([]StaminaStaminaModelRecoverDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelRecoverDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelRecoverDistributionStatisticsesFromDict(data []StaminaStaminaModelRecoverDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelRecoverDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *StaminaStaminaModelRecoverDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelRecoverDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelRecoverDistributionSegment{}
	} else {
		*p = StaminaStaminaModelRecoverDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewStaminaStaminaModelRecoverDistributionSegmentFromJson(data string) StaminaStaminaModelRecoverDistributionSegment {
	req := StaminaStaminaModelRecoverDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelRecoverDistributionSegmentFromDict(data map[string]interface{}) StaminaStaminaModelRecoverDistributionSegment {
	return StaminaStaminaModelRecoverDistributionSegment{
		Min:   core.CastInt64(data["min"]),
		Max:   core.CastInt64(data["max"]),
		Count: core.CastInt64(data["count"]),
	}
}

func (p StaminaStaminaModelRecoverDistributionSegment) ToDict() map[string]interface{} {

	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"min":   min,
		"max":   max,
		"count": count,
	}
}

func (p StaminaStaminaModelRecoverDistributionSegment) Pointer() *StaminaStaminaModelRecoverDistributionSegment {
	return &p
}

func CastStaminaStaminaModelRecoverDistributionSegments(data []interface{}) []StaminaStaminaModelRecoverDistributionSegment {
	v := make([]StaminaStaminaModelRecoverDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelRecoverDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelRecoverDistributionSegmentsFromDict(data []StaminaStaminaModelRecoverDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelRecoverDistribution struct {
	Statistics   *StaminaStaminaModelRecoverDistributionStatistics `json:"statistics"`
	Distribution []StaminaStaminaModelRecoverDistributionSegment   `json:"distribution"`
}

func (p *StaminaStaminaModelRecoverDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelRecoverDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelRecoverDistribution{}
	} else {
		*p = StaminaStaminaModelRecoverDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewStaminaStaminaModelRecoverDistributionFromJson(data string) StaminaStaminaModelRecoverDistribution {
	req := StaminaStaminaModelRecoverDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelRecoverDistributionFromDict(data map[string]interface{}) StaminaStaminaModelRecoverDistribution {
	return StaminaStaminaModelRecoverDistribution{
		Statistics:   NewStaminaStaminaModelRecoverDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastStaminaStaminaModelRecoverDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p StaminaStaminaModelRecoverDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastStaminaStaminaModelRecoverDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p StaminaStaminaModelRecoverDistribution) Pointer() *StaminaStaminaModelRecoverDistribution {
	return &p
}

func CastStaminaStaminaModelRecoverDistributions(data []interface{}) []StaminaStaminaModelRecoverDistribution {
	v := make([]StaminaStaminaModelRecoverDistribution, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelRecoverDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelRecoverDistributionsFromDict(data []StaminaStaminaModelRecoverDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelDistributions struct {
	Consume *StaminaStaminaModelConsumeDistribution `json:"consume"`
	Recover *StaminaStaminaModelRecoverDistribution `json:"recover"`
}

func (p *StaminaStaminaModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelDistributions{}
	} else {
		*p = StaminaStaminaModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["recover"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Recover)
		}
	}
	return nil
}

func NewStaminaStaminaModelDistributionsFromJson(data string) StaminaStaminaModelDistributions {
	req := StaminaStaminaModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelDistributionsFromDict(data map[string]interface{}) StaminaStaminaModelDistributions {
	return StaminaStaminaModelDistributions{
		Consume: NewStaminaStaminaModelConsumeDistributionFromDict(core.CastMap(data["consume"])).Pointer(),
		Recover: NewStaminaStaminaModelRecoverDistributionFromDict(core.CastMap(data["recover"])).Pointer(),
	}
}

func (p StaminaStaminaModelDistributions) ToDict() map[string]interface{} {

	var consume map[string]interface{}
	if p.Consume != nil {
		consume = p.Consume.ToDict()
	}
	var recover map[string]interface{}
	if p.Recover != nil {
		recover = p.Recover.ToDict()
	}
	return map[string]interface{}{
		"consume": consume,
		"recover": recover,
	}
}

func (p StaminaStaminaModelDistributions) Pointer() *StaminaStaminaModelDistributions {
	return &p
}

func CastStaminaStaminaModelDistributionses(data []interface{}) []StaminaStaminaModelDistributions {
	v := make([]StaminaStaminaModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelDistributionsesFromDict(data []StaminaStaminaModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModel struct {
	StaminaModelId *string                           `json:"staminaModelId"`
	StaminaName    *string                           `json:"staminaName"`
	Statistics     *StaminaStaminaModelStatistics    `json:"statistics"`
	Distributions  *StaminaStaminaModelDistributions `json:"distributions"`
}

func (p *StaminaStaminaModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModel{}
	} else {
		*p = StaminaStaminaModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["staminaModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.StaminaModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.StaminaModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.StaminaModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.StaminaModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.StaminaModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.StaminaModelId)
				}
			}
		}
		if v, ok := d["staminaName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.StaminaName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.StaminaName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.StaminaName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.StaminaName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewStaminaStaminaModelFromJson(data string) StaminaStaminaModel {
	req := StaminaStaminaModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelFromDict(data map[string]interface{}) StaminaStaminaModel {
	return StaminaStaminaModel{
		StaminaModelId: core.CastString(data["staminaModelId"]),
		StaminaName:    core.CastString(data["staminaName"]),
		Statistics:     NewStaminaStaminaModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions:  NewStaminaStaminaModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
	}
}

func (p StaminaStaminaModel) ToDict() map[string]interface{} {

	var staminaModelId *string
	if p.StaminaModelId != nil {
		staminaModelId = p.StaminaModelId
	}
	var staminaName *string
	if p.StaminaName != nil {
		staminaName = p.StaminaName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	return map[string]interface{}{
		"staminaModelId": staminaModelId,
		"staminaName":    staminaName,
		"statistics":     statistics,
		"distributions":  distributions,
	}
}

func (p StaminaStaminaModel) Pointer() *StaminaStaminaModel {
	return &p
}

func CastStaminaStaminaModels(data []interface{}) []StaminaStaminaModel {
	v := make([]StaminaStaminaModel, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelsFromDict(data []StaminaStaminaModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceStatistics struct {
	Consume *int64 `json:"consume"`
	Recover *int64 `json:"recover"`
}

func (p *StaminaNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceStatistics{}
	} else {
		*p = StaminaNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["recover"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Recover)
		}
	}
	return nil
}

func NewStaminaNamespaceStatisticsFromJson(data string) StaminaNamespaceStatistics {
	req := StaminaNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceStatisticsFromDict(data map[string]interface{}) StaminaNamespaceStatistics {
	return StaminaNamespaceStatistics{
		Consume: core.CastInt64(data["consume"]),
		Recover: core.CastInt64(data["recover"]),
	}
}

func (p StaminaNamespaceStatistics) ToDict() map[string]interface{} {

	var consume *int64
	if p.Consume != nil {
		consume = p.Consume
	}
	var recover *int64
	if p.Recover != nil {
		recover = p.Recover
	}
	return map[string]interface{}{
		"consume": consume,
		"recover": recover,
	}
}

func (p StaminaNamespaceStatistics) Pointer() *StaminaNamespaceStatistics {
	return &p
}

func CastStaminaNamespaceStatisticses(data []interface{}) []StaminaNamespaceStatistics {
	v := make([]StaminaNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceStatisticsesFromDict(data []StaminaNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceConsumeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *StaminaNamespaceConsumeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceConsumeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceConsumeDistributionStatistics{}
	} else {
		*p = StaminaNamespaceConsumeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewStaminaNamespaceConsumeDistributionStatisticsFromJson(data string) StaminaNamespaceConsumeDistributionStatistics {
	req := StaminaNamespaceConsumeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceConsumeDistributionStatisticsFromDict(data map[string]interface{}) StaminaNamespaceConsumeDistributionStatistics {
	return StaminaNamespaceConsumeDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p StaminaNamespaceConsumeDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p StaminaNamespaceConsumeDistributionStatistics) Pointer() *StaminaNamespaceConsumeDistributionStatistics {
	return &p
}

func CastStaminaNamespaceConsumeDistributionStatisticses(data []interface{}) []StaminaNamespaceConsumeDistributionStatistics {
	v := make([]StaminaNamespaceConsumeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceConsumeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceConsumeDistributionStatisticsesFromDict(data []StaminaNamespaceConsumeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceConsumeDistributionSegment struct {
	StaminaName *string `json:"staminaName"`
	Count       *int64  `json:"count"`
}

func (p *StaminaNamespaceConsumeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceConsumeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceConsumeDistributionSegment{}
	} else {
		*p = StaminaNamespaceConsumeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["staminaName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.StaminaName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.StaminaName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.StaminaName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.StaminaName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewStaminaNamespaceConsumeDistributionSegmentFromJson(data string) StaminaNamespaceConsumeDistributionSegment {
	req := StaminaNamespaceConsumeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceConsumeDistributionSegmentFromDict(data map[string]interface{}) StaminaNamespaceConsumeDistributionSegment {
	return StaminaNamespaceConsumeDistributionSegment{
		StaminaName: core.CastString(data["staminaName"]),
		Count:       core.CastInt64(data["count"]),
	}
}

func (p StaminaNamespaceConsumeDistributionSegment) ToDict() map[string]interface{} {

	var staminaName *string
	if p.StaminaName != nil {
		staminaName = p.StaminaName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"staminaName": staminaName,
		"count":       count,
	}
}

func (p StaminaNamespaceConsumeDistributionSegment) Pointer() *StaminaNamespaceConsumeDistributionSegment {
	return &p
}

func CastStaminaNamespaceConsumeDistributionSegments(data []interface{}) []StaminaNamespaceConsumeDistributionSegment {
	v := make([]StaminaNamespaceConsumeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceConsumeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceConsumeDistributionSegmentsFromDict(data []StaminaNamespaceConsumeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceConsumeDistribution struct {
	Statistics   *StaminaNamespaceConsumeDistributionStatistics `json:"statistics"`
	Distribution []StaminaNamespaceConsumeDistributionSegment   `json:"distribution"`
}

func (p *StaminaNamespaceConsumeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceConsumeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceConsumeDistribution{}
	} else {
		*p = StaminaNamespaceConsumeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewStaminaNamespaceConsumeDistributionFromJson(data string) StaminaNamespaceConsumeDistribution {
	req := StaminaNamespaceConsumeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceConsumeDistributionFromDict(data map[string]interface{}) StaminaNamespaceConsumeDistribution {
	return StaminaNamespaceConsumeDistribution{
		Statistics:   NewStaminaNamespaceConsumeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastStaminaNamespaceConsumeDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p StaminaNamespaceConsumeDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastStaminaNamespaceConsumeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p StaminaNamespaceConsumeDistribution) Pointer() *StaminaNamespaceConsumeDistribution {
	return &p
}

func CastStaminaNamespaceConsumeDistributions(data []interface{}) []StaminaNamespaceConsumeDistribution {
	v := make([]StaminaNamespaceConsumeDistribution, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceConsumeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceConsumeDistributionsFromDict(data []StaminaNamespaceConsumeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceRecoverDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *StaminaNamespaceRecoverDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceRecoverDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceRecoverDistributionStatistics{}
	} else {
		*p = StaminaNamespaceRecoverDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewStaminaNamespaceRecoverDistributionStatisticsFromJson(data string) StaminaNamespaceRecoverDistributionStatistics {
	req := StaminaNamespaceRecoverDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceRecoverDistributionStatisticsFromDict(data map[string]interface{}) StaminaNamespaceRecoverDistributionStatistics {
	return StaminaNamespaceRecoverDistributionStatistics{
		Count:  core.CastInt64(data["count"]),
		Min:    core.CastInt64(data["min"]),
		Max:    core.CastInt64(data["max"]),
		Avg:    core.CastFloat32(data["avg"]),
		Median: core.CastInt64(data["median"]),
		Stddev: core.CastFloat32(data["stddev"]),
	}
}

func (p StaminaNamespaceRecoverDistributionStatistics) ToDict() map[string]interface{} {

	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	var min *int64
	if p.Min != nil {
		min = p.Min
	}
	var max *int64
	if p.Max != nil {
		max = p.Max
	}
	var avg *float32
	if p.Avg != nil {
		avg = p.Avg
	}
	var median *int64
	if p.Median != nil {
		median = p.Median
	}
	var stddev *float32
	if p.Stddev != nil {
		stddev = p.Stddev
	}
	return map[string]interface{}{
		"count":  count,
		"min":    min,
		"max":    max,
		"avg":    avg,
		"median": median,
		"stddev": stddev,
	}
}

func (p StaminaNamespaceRecoverDistributionStatistics) Pointer() *StaminaNamespaceRecoverDistributionStatistics {
	return &p
}

func CastStaminaNamespaceRecoverDistributionStatisticses(data []interface{}) []StaminaNamespaceRecoverDistributionStatistics {
	v := make([]StaminaNamespaceRecoverDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceRecoverDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceRecoverDistributionStatisticsesFromDict(data []StaminaNamespaceRecoverDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceRecoverDistributionSegment struct {
	StaminaName *string `json:"staminaName"`
	Count       *int64  `json:"count"`
}

func (p *StaminaNamespaceRecoverDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceRecoverDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceRecoverDistributionSegment{}
	} else {
		*p = StaminaNamespaceRecoverDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["staminaName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.StaminaName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.StaminaName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.StaminaName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.StaminaName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewStaminaNamespaceRecoverDistributionSegmentFromJson(data string) StaminaNamespaceRecoverDistributionSegment {
	req := StaminaNamespaceRecoverDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceRecoverDistributionSegmentFromDict(data map[string]interface{}) StaminaNamespaceRecoverDistributionSegment {
	return StaminaNamespaceRecoverDistributionSegment{
		StaminaName: core.CastString(data["staminaName"]),
		Count:       core.CastInt64(data["count"]),
	}
}

func (p StaminaNamespaceRecoverDistributionSegment) ToDict() map[string]interface{} {

	var staminaName *string
	if p.StaminaName != nil {
		staminaName = p.StaminaName
	}
	var count *int64
	if p.Count != nil {
		count = p.Count
	}
	return map[string]interface{}{
		"staminaName": staminaName,
		"count":       count,
	}
}

func (p StaminaNamespaceRecoverDistributionSegment) Pointer() *StaminaNamespaceRecoverDistributionSegment {
	return &p
}

func CastStaminaNamespaceRecoverDistributionSegments(data []interface{}) []StaminaNamespaceRecoverDistributionSegment {
	v := make([]StaminaNamespaceRecoverDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceRecoverDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceRecoverDistributionSegmentsFromDict(data []StaminaNamespaceRecoverDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceRecoverDistribution struct {
	Statistics   *StaminaNamespaceRecoverDistributionStatistics `json:"statistics"`
	Distribution []StaminaNamespaceRecoverDistributionSegment   `json:"distribution"`
}

func (p *StaminaNamespaceRecoverDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceRecoverDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceRecoverDistribution{}
	} else {
		*p = StaminaNamespaceRecoverDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewStaminaNamespaceRecoverDistributionFromJson(data string) StaminaNamespaceRecoverDistribution {
	req := StaminaNamespaceRecoverDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceRecoverDistributionFromDict(data map[string]interface{}) StaminaNamespaceRecoverDistribution {
	return StaminaNamespaceRecoverDistribution{
		Statistics:   NewStaminaNamespaceRecoverDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distribution: CastStaminaNamespaceRecoverDistributionSegments(core.CastArray(data["distribution"])),
	}
}

func (p StaminaNamespaceRecoverDistribution) ToDict() map[string]interface{} {

	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distribution []interface{}
	if p.Distribution != nil {
		distribution = CastStaminaNamespaceRecoverDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return map[string]interface{}{
		"statistics":   statistics,
		"distribution": distribution,
	}
}

func (p StaminaNamespaceRecoverDistribution) Pointer() *StaminaNamespaceRecoverDistribution {
	return &p
}

func CastStaminaNamespaceRecoverDistributions(data []interface{}) []StaminaNamespaceRecoverDistribution {
	v := make([]StaminaNamespaceRecoverDistribution, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceRecoverDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceRecoverDistributionsFromDict(data []StaminaNamespaceRecoverDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceDistributions struct {
	Consume *StaminaNamespaceConsumeDistribution `json:"consume"`
	Recover *StaminaNamespaceRecoverDistribution `json:"recover"`
}

func (p *StaminaNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceDistributions{}
	} else {
		*p = StaminaNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["recover"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Recover)
		}
	}
	return nil
}

func NewStaminaNamespaceDistributionsFromJson(data string) StaminaNamespaceDistributions {
	req := StaminaNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceDistributionsFromDict(data map[string]interface{}) StaminaNamespaceDistributions {
	return StaminaNamespaceDistributions{
		Consume: NewStaminaNamespaceConsumeDistributionFromDict(core.CastMap(data["consume"])).Pointer(),
		Recover: NewStaminaNamespaceRecoverDistributionFromDict(core.CastMap(data["recover"])).Pointer(),
	}
}

func (p StaminaNamespaceDistributions) ToDict() map[string]interface{} {

	var consume map[string]interface{}
	if p.Consume != nil {
		consume = p.Consume.ToDict()
	}
	var recover map[string]interface{}
	if p.Recover != nil {
		recover = p.Recover.ToDict()
	}
	return map[string]interface{}{
		"consume": consume,
		"recover": recover,
	}
}

func (p StaminaNamespaceDistributions) Pointer() *StaminaNamespaceDistributions {
	return &p
}

func CastStaminaNamespaceDistributionses(data []interface{}) []StaminaNamespaceDistributions {
	v := make([]StaminaNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceDistributionsesFromDict(data []StaminaNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespace struct {
	NamespaceId   *string                        `json:"namespaceId"`
	Year          *int32                         `json:"year"`
	Month         *int32                         `json:"month"`
	Day           *int32                         `json:"day"`
	NamespaceName *string                        `json:"namespaceName"`
	Statistics    *StaminaNamespaceStatistics    `json:"statistics"`
	Distributions *StaminaNamespaceDistributions `json:"distributions"`
	StaminaModels []StaminaStaminaModel          `json:"staminaModels"`
}

func (p *StaminaNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespace{}
	} else {
		*p = StaminaNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["staminaModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.StaminaModels)
		}
	}
	return nil
}

func NewStaminaNamespaceFromJson(data string) StaminaNamespace {
	req := StaminaNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceFromDict(data map[string]interface{}) StaminaNamespace {
	return StaminaNamespace{
		NamespaceId:   core.CastString(data["namespaceId"]),
		Year:          core.CastInt32(data["year"]),
		Month:         core.CastInt32(data["month"]),
		Day:           core.CastInt32(data["day"]),
		NamespaceName: core.CastString(data["namespaceName"]),
		Statistics:    NewStaminaNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer(),
		Distributions: NewStaminaNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer(),
		StaminaModels: CastStaminaStaminaModels(core.CastArray(data["staminaModels"])),
	}
}

func (p StaminaNamespace) ToDict() map[string]interface{} {

	var namespaceId *string
	if p.NamespaceId != nil {
		namespaceId = p.NamespaceId
	}
	var year *int32
	if p.Year != nil {
		year = p.Year
	}
	var month *int32
	if p.Month != nil {
		month = p.Month
	}
	var day *int32
	if p.Day != nil {
		day = p.Day
	}
	var namespaceName *string
	if p.NamespaceName != nil {
		namespaceName = p.NamespaceName
	}
	var statistics map[string]interface{}
	if p.Statistics != nil {
		statistics = p.Statistics.ToDict()
	}
	var distributions map[string]interface{}
	if p.Distributions != nil {
		distributions = p.Distributions.ToDict()
	}
	var staminaModels []interface{}
	if p.StaminaModels != nil {
		staminaModels = CastStaminaStaminaModelsFromDict(
			p.StaminaModels,
		)
	}
	return map[string]interface{}{
		"namespaceId":   namespaceId,
		"year":          year,
		"month":         month,
		"day":           day,
		"namespaceName": namespaceName,
		"statistics":    statistics,
		"distributions": distributions,
		"staminaModels": staminaModels,
	}
}

func (p StaminaNamespace) Pointer() *StaminaNamespace {
	return &p
}

func CastStaminaNamespaces(data []interface{}) []StaminaNamespace {
	v := make([]StaminaNamespace, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespacesFromDict(data []StaminaNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}
