/*
Copyright 2016 Game Server Services, Inc. or its affiliates. All Rights
Reserved.

Licensed under the Apache License, Version 2.0 (the "License").
You may not use this file except in compliance with the License.
A copy of the License is located at

 http://www.apache.org/licenses/LICENSE-2.0

or in the "license" file accompanying this file. This file is distributed
on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
express or implied. See the License for the specific language governing
permissions and limitations under the License.
*/

package watch

import (
	"encoding/json"
	"strconv"

	"github.com/gs2io/gs2-golang-sdk/core"
)

type Chart struct {
	Timestamp *int64    `json:"timestamp"`
	Value     *int64    `json:"value"`
	GroupBys  []*string `json:"groupBys"`
}

func (p *Chart) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = Chart{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = Chart{}
	} else {
		*p = Chart{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["timestamp"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Timestamp)
		}
		if v, ok := d["value"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Value)
		}
		if v, ok := d["groupBys"]; ok && v != nil {
			var v2 []interface{}
			if err := json.Unmarshal(*v, &v2); err == nil {
				l := make([]*string, len(v2))
				for i, v3 := range v2 {
					switch v4 := v3.(type) {
					case string:
						l[i] = &v4
					case float64:
						strValue := strconv.FormatFloat(v4, 'f', -1, 64)
						l[i] = &strValue
					case int:
						strValue := strconv.Itoa(v4)
						l[i] = &strValue
					case int32:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					case int64:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					default:
					}
				}
				p.GroupBys = l
			}
		}
	}
	return nil
}

func NewChartFromJson(data string) Chart {
	req := Chart{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChartFromDict(data map[string]interface{}) Chart {
	return Chart{
		Timestamp: func() *int64 {
			v, ok := data["timestamp"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["timestamp"])
		}(),
		Value: func() *int64 {
			v, ok := data["value"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["value"])
		}(),
		GroupBys: func() []*string {
			v, ok := data["groupBys"]
			if !ok || v == nil {
				return nil
			}
			return core.CastStrings(core.CastArray(v))
		}(),
	}
}

func (p Chart) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Timestamp != nil {
		m["timestamp"] = p.Timestamp
	}
	if p.Value != nil {
		m["value"] = p.Value
	}
	if p.GroupBys != nil {
		m["groupBys"] = core.CastStringsFromDict(
			p.GroupBys,
		)
	}
	return m
}

func (p Chart) Pointer() *Chart {
	return &p
}

func CastCharts(data []interface{}) []Chart {
	v := make([]Chart, 0)
	for _, d := range data {
		v = append(v, NewChartFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChartsFromDict(data []Chart) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type Distribution struct {
	Value    *int64    `json:"value"`
	Count    *int64    `json:"count"`
	GroupBys []*string `json:"groupBys"`
}

func (p *Distribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = Distribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = Distribution{}
	} else {
		*p = Distribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["value"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Value)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["groupBys"]; ok && v != nil {
			var v2 []interface{}
			if err := json.Unmarshal(*v, &v2); err == nil {
				l := make([]*string, len(v2))
				for i, v3 := range v2 {
					switch v4 := v3.(type) {
					case string:
						l[i] = &v4
					case float64:
						strValue := strconv.FormatFloat(v4, 'f', -1, 64)
						l[i] = &strValue
					case int:
						strValue := strconv.Itoa(v4)
						l[i] = &strValue
					case int32:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					case int64:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					default:
					}
				}
				p.GroupBys = l
			}
		}
	}
	return nil
}

func NewDistributionFromJson(data string) Distribution {
	req := Distribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDistributionFromDict(data map[string]interface{}) Distribution {
	return Distribution{
		Value: func() *int64 {
			v, ok := data["value"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["value"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		GroupBys: func() []*string {
			v, ok := data["groupBys"]
			if !ok || v == nil {
				return nil
			}
			return core.CastStrings(core.CastArray(v))
		}(),
	}
}

func (p Distribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Value != nil {
		m["value"] = p.Value
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.GroupBys != nil {
		m["groupBys"] = core.CastStringsFromDict(
			p.GroupBys,
		)
	}
	return m
}

func (p Distribution) Pointer() *Distribution {
	return &p
}

func CastDistributions(data []interface{}) []Distribution {
	v := make([]Distribution, 0)
	for _, d := range data {
		v = append(v, NewDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDistributionsFromDict(data []Distribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type Cumulative struct {
	CumulativeId *string `json:"cumulativeId"`
	ResourceGrn  *string `json:"resourceGrn"`
	Name         *string `json:"name"`
	Value        *int64  `json:"value"`
	UpdatedAt    *int64  `json:"updatedAt"`
	Revision     *int64  `json:"revision"`
}

func (p *Cumulative) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = Cumulative{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = Cumulative{}
	} else {
		*p = Cumulative{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["cumulativeId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CumulativeId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CumulativeId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CumulativeId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CumulativeId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CumulativeId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CumulativeId)
				}
			}
		}
		if v, ok := d["resourceGrn"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ResourceGrn = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ResourceGrn = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ResourceGrn = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ResourceGrn = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ResourceGrn = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ResourceGrn)
				}
			}
		}
		if v, ok := d["name"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Name = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Name = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Name = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Name = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Name = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Name)
				}
			}
		}
		if v, ok := d["value"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Value)
		}
		if v, ok := d["updatedAt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.UpdatedAt)
		}
		if v, ok := d["revision"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Revision)
		}
	}
	return nil
}

func NewCumulativeFromJson(data string) Cumulative {
	req := Cumulative{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewCumulativeFromDict(data map[string]interface{}) Cumulative {
	return Cumulative{
		CumulativeId: func() *string {
			v, ok := data["cumulativeId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["cumulativeId"])
		}(),
		ResourceGrn: func() *string {
			v, ok := data["resourceGrn"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["resourceGrn"])
		}(),
		Name: func() *string {
			v, ok := data["name"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["name"])
		}(),
		Value: func() *int64 {
			v, ok := data["value"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["value"])
		}(),
		UpdatedAt: func() *int64 {
			v, ok := data["updatedAt"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["updatedAt"])
		}(),
		Revision: func() *int64 {
			v, ok := data["revision"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["revision"])
		}(),
	}
}

func (p Cumulative) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.CumulativeId != nil {
		m["cumulativeId"] = p.CumulativeId
	}
	if p.ResourceGrn != nil {
		m["resourceGrn"] = p.ResourceGrn
	}
	if p.Name != nil {
		m["name"] = p.Name
	}
	if p.Value != nil {
		m["value"] = p.Value
	}
	if p.UpdatedAt != nil {
		m["updatedAt"] = p.UpdatedAt
	}
	if p.Revision != nil {
		m["revision"] = p.Revision
	}
	return m
}

func (p Cumulative) Pointer() *Cumulative {
	return &p
}

func CastCumulatives(data []interface{}) []Cumulative {
	v := make([]Cumulative, 0)
	for _, d := range data {
		v = append(v, NewCumulativeFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastCumulativesFromDict(data []Cumulative) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type BillingActivity struct {
	BillingActivityId *string `json:"billingActivityId"`
	Year              *int32  `json:"year"`
	Month             *int32  `json:"month"`
	Service           *string `json:"service"`
	ActivityType      *string `json:"activityType"`
	Value             *int64  `json:"value"`
	Revision          *int64  `json:"revision"`
}

func (p *BillingActivity) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = BillingActivity{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = BillingActivity{}
	} else {
		*p = BillingActivity{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["billingActivityId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.BillingActivityId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.BillingActivityId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.BillingActivityId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.BillingActivityId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.BillingActivityId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.BillingActivityId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["service"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Service = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Service = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Service = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Service = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Service = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Service)
				}
			}
		}
		if v, ok := d["activityType"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ActivityType = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ActivityType = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ActivityType = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ActivityType = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ActivityType = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ActivityType)
				}
			}
		}
		if v, ok := d["value"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Value)
		}
		if v, ok := d["revision"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Revision)
		}
	}
	return nil
}

func NewBillingActivityFromJson(data string) BillingActivity {
	req := BillingActivity{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewBillingActivityFromDict(data map[string]interface{}) BillingActivity {
	return BillingActivity{
		BillingActivityId: func() *string {
			v, ok := data["billingActivityId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["billingActivityId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Service: func() *string {
			v, ok := data["service"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["service"])
		}(),
		ActivityType: func() *string {
			v, ok := data["activityType"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["activityType"])
		}(),
		Value: func() *int64 {
			v, ok := data["value"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["value"])
		}(),
		Revision: func() *int64 {
			v, ok := data["revision"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["revision"])
		}(),
	}
}

func (p BillingActivity) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.BillingActivityId != nil {
		m["billingActivityId"] = p.BillingActivityId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Service != nil {
		m["service"] = p.Service
	}
	if p.ActivityType != nil {
		m["activityType"] = p.ActivityType
	}
	if p.Value != nil {
		m["value"] = p.Value
	}
	if p.Revision != nil {
		m["revision"] = p.Revision
	}
	return m
}

func (p BillingActivity) Pointer() *BillingActivity {
	return &p
}

func CastBillingActivities(data []interface{}) []BillingActivity {
	v := make([]BillingActivity, 0)
	for _, d := range data {
		v = append(v, NewBillingActivityFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastBillingActivitiesFromDict(data []BillingActivity) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StatsEvent struct {
	Grn        *string   `json:"grn"`
	Service    *string   `json:"service"`
	Method     *string   `json:"method"`
	Metric     *string   `json:"metric"`
	Cumulative *bool     `json:"cumulative"`
	Value      *float64  `json:"value"`
	Tags       []*string `json:"tags"`
	CallAt     *int64    `json:"callAt"`
}

func (p *StatsEvent) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StatsEvent{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StatsEvent{}
	} else {
		*p = StatsEvent{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["grn"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Grn = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Grn = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Grn = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Grn = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Grn = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Grn)
				}
			}
		}
		if v, ok := d["service"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Service = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Service = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Service = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Service = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Service = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Service)
				}
			}
		}
		if v, ok := d["method"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Method = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Method = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Method = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Method = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Method = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Method)
				}
			}
		}
		if v, ok := d["metric"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Metric = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Metric = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Metric = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Metric = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Metric = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Metric)
				}
			}
		}
		if v, ok := d["cumulative"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Cumulative)
		}
		if v, ok := d["value"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Value)
		}
		if v, ok := d["tags"]; ok && v != nil {
			var v2 []interface{}
			if err := json.Unmarshal(*v, &v2); err == nil {
				l := make([]*string, len(v2))
				for i, v3 := range v2 {
					switch v4 := v3.(type) {
					case string:
						l[i] = &v4
					case float64:
						strValue := strconv.FormatFloat(v4, 'f', -1, 64)
						l[i] = &strValue
					case int:
						strValue := strconv.Itoa(v4)
						l[i] = &strValue
					case int32:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					case int64:
						strValue := strconv.Itoa(int(v4))
						l[i] = &strValue
					default:
					}
				}
				p.Tags = l
			}
		}
		if v, ok := d["callAt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CallAt)
		}
	}
	return nil
}

func NewStatsEventFromJson(data string) StatsEvent {
	req := StatsEvent{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStatsEventFromDict(data map[string]interface{}) StatsEvent {
	return StatsEvent{
		Grn: func() *string {
			v, ok := data["grn"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["grn"])
		}(),
		Service: func() *string {
			v, ok := data["service"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["service"])
		}(),
		Method: func() *string {
			v, ok := data["method"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["method"])
		}(),
		Metric: func() *string {
			v, ok := data["metric"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["metric"])
		}(),
		Cumulative: func() *bool {
			v, ok := data["cumulative"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["cumulative"])
		}(),
		Value: func() *float64 {
			v, ok := data["value"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat64(data["value"])
		}(),
		Tags: func() []*string {
			v, ok := data["tags"]
			if !ok || v == nil {
				return nil
			}
			return core.CastStrings(core.CastArray(v))
		}(),
		CallAt: func() *int64 {
			v, ok := data["callAt"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["callAt"])
		}(),
	}
}

func (p StatsEvent) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Grn != nil {
		m["grn"] = p.Grn
	}
	if p.Service != nil {
		m["service"] = p.Service
	}
	if p.Method != nil {
		m["method"] = p.Method
	}
	if p.Metric != nil {
		m["metric"] = p.Metric
	}
	if p.Cumulative != nil {
		m["cumulative"] = p.Cumulative
	}
	if p.Value != nil {
		m["value"] = p.Value
	}
	if p.Tags != nil {
		m["tags"] = core.CastStringsFromDict(
			p.Tags,
		)
	}
	if p.CallAt != nil {
		m["callAt"] = p.CallAt
	}
	return m
}

func (p StatsEvent) Pointer() *StatsEvent {
	return &p
}

func CastStatsEvents(data []interface{}) []StatsEvent {
	v := make([]StatsEvent, 0)
	for _, d := range data {
		v = append(v, NewStatsEventFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStatsEventsFromDict(data []StatsEvent) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type Filter struct {
	Key   *string `json:"key"`
	Value *string `json:"value"`
}

func (p *Filter) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = Filter{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = Filter{}
	} else {
		*p = Filter{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["key"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Key = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Key = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Key = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Key = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Key = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Key)
				}
			}
		}
		if v, ok := d["value"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Value = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Value = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Value = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Value = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Value = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Value)
				}
			}
		}
	}
	return nil
}

func NewFilterFromJson(data string) Filter {
	req := Filter{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFilterFromDict(data map[string]interface{}) Filter {
	return Filter{
		Key: func() *string {
			v, ok := data["key"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["key"])
		}(),
		Value: func() *string {
			v, ok := data["value"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["value"])
		}(),
	}
}

func (p Filter) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Key != nil {
		m["key"] = p.Key
	}
	if p.Value != nil {
		m["value"] = p.Value
	}
	return m
}

func (p Filter) Pointer() *Filter {
	return &p
}

func CastFilters(data []interface{}) []Filter {
	v := make([]Filter, 0)
	for _, d := range data {
		v = append(v, NewFilterFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFiltersFromDict(data []Filter) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type GeneralDauWauMauHistory struct {
	Date                *string `json:"date"`
	Dau                 *int64  `json:"dau"`
	WauLast7Days        *int64  `json:"wauLast7Days"`
	WauTargetWeekSunday *int64  `json:"wauTargetWeekSunday"`
	WauTargetWeekMonday *int64  `json:"wauTargetWeekMonday"`
	MauLast30Days       *int64  `json:"mauLast30Days"`
	MauTargetMonth      *int64  `json:"mauTargetMonth"`
}

func (p *GeneralDauWauMauHistory) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = GeneralDauWauMauHistory{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = GeneralDauWauMauHistory{}
	} else {
		*p = GeneralDauWauMauHistory{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["date"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Date = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Date = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Date = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Date)
				}
			}
		}
		if v, ok := d["dau"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Dau)
		}
		if v, ok := d["wauLast7Days"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.WauLast7Days)
		}
		if v, ok := d["wauTargetWeekSunday"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.WauTargetWeekSunday)
		}
		if v, ok := d["wauTargetWeekMonday"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.WauTargetWeekMonday)
		}
		if v, ok := d["mauLast30Days"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.MauLast30Days)
		}
		if v, ok := d["mauTargetMonth"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.MauTargetMonth)
		}
	}
	return nil
}

func NewGeneralDauWauMauHistoryFromJson(data string) GeneralDauWauMauHistory {
	req := GeneralDauWauMauHistory{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewGeneralDauWauMauHistoryFromDict(data map[string]interface{}) GeneralDauWauMauHistory {
	return GeneralDauWauMauHistory{
		Date: func() *string {
			v, ok := data["date"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["date"])
		}(),
		Dau: func() *int64 {
			v, ok := data["dau"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["dau"])
		}(),
		WauLast7Days: func() *int64 {
			v, ok := data["wauLast7Days"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["wauLast7Days"])
		}(),
		WauTargetWeekSunday: func() *int64 {
			v, ok := data["wauTargetWeekSunday"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["wauTargetWeekSunday"])
		}(),
		WauTargetWeekMonday: func() *int64 {
			v, ok := data["wauTargetWeekMonday"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["wauTargetWeekMonday"])
		}(),
		MauLast30Days: func() *int64 {
			v, ok := data["mauLast30Days"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["mauLast30Days"])
		}(),
		MauTargetMonth: func() *int64 {
			v, ok := data["mauTargetMonth"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["mauTargetMonth"])
		}(),
	}
}

func (p GeneralDauWauMauHistory) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Date != nil {
		m["date"] = p.Date
	}
	if p.Dau != nil {
		m["dau"] = p.Dau
	}
	if p.WauLast7Days != nil {
		m["wauLast7Days"] = p.WauLast7Days
	}
	if p.WauTargetWeekSunday != nil {
		m["wauTargetWeekSunday"] = p.WauTargetWeekSunday
	}
	if p.WauTargetWeekMonday != nil {
		m["wauTargetWeekMonday"] = p.WauTargetWeekMonday
	}
	if p.MauLast30Days != nil {
		m["mauLast30Days"] = p.MauLast30Days
	}
	if p.MauTargetMonth != nil {
		m["mauTargetMonth"] = p.MauTargetMonth
	}
	return m
}

func (p GeneralDauWauMauHistory) Pointer() *GeneralDauWauMauHistory {
	return &p
}

func CastGeneralDauWauMauHistories(data []interface{}) []GeneralDauWauMauHistory {
	v := make([]GeneralDauWauMauHistory, 0)
	for _, d := range data {
		v = append(v, NewGeneralDauWauMauHistoryFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastGeneralDauWauMauHistoriesFromDict(data []GeneralDauWauMauHistory) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type GeneralDauWauMauAverage struct {
	Dau *float32 `json:"dau"`
	Wau *float32 `json:"wau"`
	Mau *float32 `json:"mau"`
}

func (p *GeneralDauWauMauAverage) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = GeneralDauWauMauAverage{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = GeneralDauWauMauAverage{}
	} else {
		*p = GeneralDauWauMauAverage{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["dau"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Dau)
		}
		if v, ok := d["wau"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Wau)
		}
		if v, ok := d["mau"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Mau)
		}
	}
	return nil
}

func NewGeneralDauWauMauAverageFromJson(data string) GeneralDauWauMauAverage {
	req := GeneralDauWauMauAverage{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewGeneralDauWauMauAverageFromDict(data map[string]interface{}) GeneralDauWauMauAverage {
	return GeneralDauWauMauAverage{
		Dau: func() *float32 {
			v, ok := data["dau"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["dau"])
		}(),
		Wau: func() *float32 {
			v, ok := data["wau"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["wau"])
		}(),
		Mau: func() *float32 {
			v, ok := data["mau"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["mau"])
		}(),
	}
}

func (p GeneralDauWauMauAverage) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Dau != nil {
		m["dau"] = p.Dau
	}
	if p.Wau != nil {
		m["wau"] = p.Wau
	}
	if p.Mau != nil {
		m["mau"] = p.Mau
	}
	return m
}

func (p GeneralDauWauMauAverage) Pointer() *GeneralDauWauMauAverage {
	return &p
}

func CastGeneralDauWauMauAverages(data []interface{}) []GeneralDauWauMauAverage {
	v := make([]GeneralDauWauMauAverage, 0)
	for _, d := range data {
		v = append(v, NewGeneralDauWauMauAverageFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastGeneralDauWauMauAveragesFromDict(data []GeneralDauWauMauAverage) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type GeneralDauWauMau struct {
	History []GeneralDauWauMauHistory `json:"history"`
	Avg     *GeneralDauWauMauAverage  `json:"avg"`
}

func (p *GeneralDauWauMau) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = GeneralDauWauMau{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = GeneralDauWauMau{}
	} else {
		*p = GeneralDauWauMau{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["history"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.History)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
	}
	return nil
}

func NewGeneralDauWauMauFromJson(data string) GeneralDauWauMau {
	req := GeneralDauWauMau{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewGeneralDauWauMauFromDict(data map[string]interface{}) GeneralDauWauMau {
	return GeneralDauWauMau{
		History: func() []GeneralDauWauMauHistory {
			if data["history"] == nil {
				return nil
			}
			return CastGeneralDauWauMauHistories(core.CastArray(data["history"]))
		}(),
		Avg: func() *GeneralDauWauMauAverage {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return NewGeneralDauWauMauAverageFromDict(core.CastMap(data["avg"])).Pointer()
		}(),
	}
}

func (p GeneralDauWauMau) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.History != nil {
		m["history"] = CastGeneralDauWauMauHistoriesFromDict(
			p.History,
		)
	}
	if p.Avg != nil {
		m["avg"] = func() map[string]interface{} {
			if p.Avg == nil {
				return nil
			}
			return p.Avg.ToDict()
		}()
	}
	return m
}

func (p GeneralDauWauMau) Pointer() *GeneralDauWauMau {
	return &p
}

func CastGeneralDauWauMaus(data []interface{}) []GeneralDauWauMau {
	v := make([]GeneralDauWauMau, 0)
	for _, d := range data {
		v = append(v, NewGeneralDauWauMauFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastGeneralDauWauMausFromDict(data []GeneralDauWauMau) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FirstEngagementStatisticsLoginDays struct {
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FirstEngagementStatisticsLoginDays) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FirstEngagementStatisticsLoginDays{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FirstEngagementStatisticsLoginDays{}
	} else {
		*p = FirstEngagementStatisticsLoginDays{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFirstEngagementStatisticsLoginDaysFromJson(data string) FirstEngagementStatisticsLoginDays {
	req := FirstEngagementStatisticsLoginDays{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFirstEngagementStatisticsLoginDaysFromDict(data map[string]interface{}) FirstEngagementStatisticsLoginDays {
	return FirstEngagementStatisticsLoginDays{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FirstEngagementStatisticsLoginDays) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FirstEngagementStatisticsLoginDays) Pointer() *FirstEngagementStatisticsLoginDays {
	return &p
}

func CastFirstEngagementStatisticsLoginDayses(data []interface{}) []FirstEngagementStatisticsLoginDays {
	v := make([]FirstEngagementStatisticsLoginDays, 0)
	for _, d := range data {
		v = append(v, NewFirstEngagementStatisticsLoginDaysFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFirstEngagementStatisticsLoginDaysesFromDict(data []FirstEngagementStatisticsLoginDays) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FirstEngagementStatistics struct {
	LoginDays *FirstEngagementStatisticsLoginDays `json:"loginDays"`
}

func (p *FirstEngagementStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FirstEngagementStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FirstEngagementStatistics{}
	} else {
		*p = FirstEngagementStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["loginDays"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.LoginDays)
		}
	}
	return nil
}

func NewFirstEngagementStatisticsFromJson(data string) FirstEngagementStatistics {
	req := FirstEngagementStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFirstEngagementStatisticsFromDict(data map[string]interface{}) FirstEngagementStatistics {
	return FirstEngagementStatistics{
		LoginDays: func() *FirstEngagementStatisticsLoginDays {
			v, ok := data["loginDays"]
			if !ok || v == nil {
				return nil
			}
			return NewFirstEngagementStatisticsLoginDaysFromDict(core.CastMap(data["loginDays"])).Pointer()
		}(),
	}
}

func (p FirstEngagementStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.LoginDays != nil {
		m["loginDays"] = func() map[string]interface{} {
			if p.LoginDays == nil {
				return nil
			}
			return p.LoginDays.ToDict()
		}()
	}
	return m
}

func (p FirstEngagementStatistics) Pointer() *FirstEngagementStatistics {
	return &p
}

func CastFirstEngagementStatisticses(data []interface{}) []FirstEngagementStatistics {
	v := make([]FirstEngagementStatistics, 0)
	for _, d := range data {
		v = append(v, NewFirstEngagementStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFirstEngagementStatisticsesFromDict(data []FirstEngagementStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FirstEngagementDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FirstEngagementDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FirstEngagementDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FirstEngagementDistributionSegment{}
	} else {
		*p = FirstEngagementDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFirstEngagementDistributionSegmentFromJson(data string) FirstEngagementDistributionSegment {
	req := FirstEngagementDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFirstEngagementDistributionSegmentFromDict(data map[string]interface{}) FirstEngagementDistributionSegment {
	return FirstEngagementDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FirstEngagementDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FirstEngagementDistributionSegment) Pointer() *FirstEngagementDistributionSegment {
	return &p
}

func CastFirstEngagementDistributionSegments(data []interface{}) []FirstEngagementDistributionSegment {
	v := make([]FirstEngagementDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFirstEngagementDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFirstEngagementDistributionSegmentsFromDict(data []FirstEngagementDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FirstEngagement struct {
	Statistics   *FirstEngagementStatistics           `json:"statistics"`
	Distribution []FirstEngagementDistributionSegment `json:"distribution"`
}

func (p *FirstEngagement) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FirstEngagement{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FirstEngagement{}
	} else {
		*p = FirstEngagement{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFirstEngagementFromJson(data string) FirstEngagement {
	req := FirstEngagement{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFirstEngagementFromDict(data map[string]interface{}) FirstEngagement {
	return FirstEngagement{
		Statistics: func() *FirstEngagementStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFirstEngagementStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FirstEngagementDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFirstEngagementDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FirstEngagement) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFirstEngagementDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FirstEngagement) Pointer() *FirstEngagement {
	return &p
}

func CastFirstEngagements(data []interface{}) []FirstEngagement {
	v := make([]FirstEngagement, 0)
	for _, d := range data {
		v = append(v, NewFirstEngagementFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFirstEngagementsFromDict(data []FirstEngagement) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type SessionDurationStatistics struct {
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *SessionDurationStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = SessionDurationStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = SessionDurationStatistics{}
	} else {
		*p = SessionDurationStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewSessionDurationStatisticsFromJson(data string) SessionDurationStatistics {
	req := SessionDurationStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewSessionDurationStatisticsFromDict(data map[string]interface{}) SessionDurationStatistics {
	return SessionDurationStatistics{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p SessionDurationStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p SessionDurationStatistics) Pointer() *SessionDurationStatistics {
	return &p
}

func CastSessionDurationStatisticses(data []interface{}) []SessionDurationStatistics {
	v := make([]SessionDurationStatistics, 0)
	for _, d := range data {
		v = append(v, NewSessionDurationStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastSessionDurationStatisticsesFromDict(data []SessionDurationStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type SessionDurationDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *SessionDurationDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = SessionDurationDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = SessionDurationDistributionSegment{}
	} else {
		*p = SessionDurationDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewSessionDurationDistributionSegmentFromJson(data string) SessionDurationDistributionSegment {
	req := SessionDurationDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewSessionDurationDistributionSegmentFromDict(data map[string]interface{}) SessionDurationDistributionSegment {
	return SessionDurationDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p SessionDurationDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p SessionDurationDistributionSegment) Pointer() *SessionDurationDistributionSegment {
	return &p
}

func CastSessionDurationDistributionSegments(data []interface{}) []SessionDurationDistributionSegment {
	v := make([]SessionDurationDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewSessionDurationDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastSessionDurationDistributionSegmentsFromDict(data []SessionDurationDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type SessionDurationDistribution struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *SessionDurationDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = SessionDurationDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = SessionDurationDistribution{}
	} else {
		*p = SessionDurationDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewSessionDurationDistributionFromJson(data string) SessionDurationDistribution {
	req := SessionDurationDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewSessionDurationDistributionFromDict(data map[string]interface{}) SessionDurationDistribution {
	return SessionDurationDistribution{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p SessionDurationDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p SessionDurationDistribution) Pointer() *SessionDurationDistribution {
	return &p
}

func CastSessionDurationDistributions(data []interface{}) []SessionDurationDistribution {
	v := make([]SessionDurationDistribution, 0)
	for _, d := range data {
		v = append(v, NewSessionDurationDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastSessionDurationDistributionsFromDict(data []SessionDurationDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type EngagementHistory struct {
	Date            *string  `json:"date"`
	NewUserRate     *float32 `json:"newUserRate"`
	ReturnUserRate  *float32 `json:"returnUserRate"`
	EngagedUserRate *float32 `json:"engagedUserRate"`
}

func (p *EngagementHistory) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = EngagementHistory{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = EngagementHistory{}
	} else {
		*p = EngagementHistory{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["date"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Date = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Date = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Date = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Date)
				}
			}
		}
		if v, ok := d["newUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.NewUserRate)
		}
		if v, ok := d["returnUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ReturnUserRate)
		}
		if v, ok := d["engagedUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EngagedUserRate)
		}
	}
	return nil
}

func NewEngagementHistoryFromJson(data string) EngagementHistory {
	req := EngagementHistory{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewEngagementHistoryFromDict(data map[string]interface{}) EngagementHistory {
	return EngagementHistory{
		Date: func() *string {
			v, ok := data["date"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["date"])
		}(),
		NewUserRate: func() *float32 {
			v, ok := data["newUserRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["newUserRate"])
		}(),
		ReturnUserRate: func() *float32 {
			v, ok := data["returnUserRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["returnUserRate"])
		}(),
		EngagedUserRate: func() *float32 {
			v, ok := data["engagedUserRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["engagedUserRate"])
		}(),
	}
}

func (p EngagementHistory) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Date != nil {
		m["date"] = p.Date
	}
	if p.NewUserRate != nil {
		m["newUserRate"] = p.NewUserRate
	}
	if p.ReturnUserRate != nil {
		m["returnUserRate"] = p.ReturnUserRate
	}
	if p.EngagedUserRate != nil {
		m["engagedUserRate"] = p.EngagedUserRate
	}
	return m
}

func (p EngagementHistory) Pointer() *EngagementHistory {
	return &p
}

func CastEngagementHistories(data []interface{}) []EngagementHistory {
	v := make([]EngagementHistory, 0)
	for _, d := range data {
		v = append(v, NewEngagementHistoryFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastEngagementHistoriesFromDict(data []EngagementHistory) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type EngagementAverage struct {
	NewUserRate     *float32 `json:"newUserRate"`
	ReturnUserRate  *float32 `json:"returnUserRate"`
	EngagedUserRate *float32 `json:"engagedUserRate"`
}

func (p *EngagementAverage) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = EngagementAverage{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = EngagementAverage{}
	} else {
		*p = EngagementAverage{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["newUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.NewUserRate)
		}
		if v, ok := d["returnUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ReturnUserRate)
		}
		if v, ok := d["engagedUserRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EngagedUserRate)
		}
	}
	return nil
}

func NewEngagementAverageFromJson(data string) EngagementAverage {
	req := EngagementAverage{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewEngagementAverageFromDict(data map[string]interface{}) EngagementAverage {
	return EngagementAverage{
		NewUserRate: func() *float32 {
			v, ok := data["newUserRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["newUserRate"])
		}(),
		ReturnUserRate: func() *float32 {
			v, ok := data["returnUserRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["returnUserRate"])
		}(),
		EngagedUserRate: func() *float32 {
			v, ok := data["engagedUserRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["engagedUserRate"])
		}(),
	}
}

func (p EngagementAverage) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NewUserRate != nil {
		m["newUserRate"] = p.NewUserRate
	}
	if p.ReturnUserRate != nil {
		m["returnUserRate"] = p.ReturnUserRate
	}
	if p.EngagedUserRate != nil {
		m["engagedUserRate"] = p.EngagedUserRate
	}
	return m
}

func (p EngagementAverage) Pointer() *EngagementAverage {
	return &p
}

func CastEngagementAverages(data []interface{}) []EngagementAverage {
	v := make([]EngagementAverage, 0)
	for _, d := range data {
		v = append(v, NewEngagementAverageFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastEngagementAveragesFromDict(data []EngagementAverage) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type Engagements struct {
	History []EngagementHistory `json:"history"`
	Avg     *EngagementAverage  `json:"avg"`
}

func (p *Engagements) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = Engagements{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = Engagements{}
	} else {
		*p = Engagements{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["history"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.History)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
	}
	return nil
}

func NewEngagementsFromJson(data string) Engagements {
	req := Engagements{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewEngagementsFromDict(data map[string]interface{}) Engagements {
	return Engagements{
		History: func() []EngagementHistory {
			if data["history"] == nil {
				return nil
			}
			return CastEngagementHistories(core.CastArray(data["history"]))
		}(),
		Avg: func() *EngagementAverage {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return NewEngagementAverageFromDict(core.CastMap(data["avg"])).Pointer()
		}(),
	}
}

func (p Engagements) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.History != nil {
		m["history"] = CastEngagementHistoriesFromDict(
			p.History,
		)
	}
	if p.Avg != nil {
		m["avg"] = func() map[string]interface{} {
			if p.Avg == nil {
				return nil
			}
			return p.Avg.ToDict()
		}()
	}
	return m
}

func (p Engagements) Pointer() *Engagements {
	return &p
}

func CastEngagementses(data []interface{}) []Engagements {
	v := make([]Engagements, 0)
	for _, d := range data {
		v = append(v, NewEngagementsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastEngagementsesFromDict(data []Engagements) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChurnRateHistory struct {
	Date      *string  `json:"date"`
	ChurnRate *float32 `json:"churnRate"`
}

func (p *ChurnRateHistory) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChurnRateHistory{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChurnRateHistory{}
	} else {
		*p = ChurnRateHistory{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["date"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Date = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Date = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Date = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Date = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Date)
				}
			}
		}
		if v, ok := d["churnRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ChurnRate)
		}
	}
	return nil
}

func NewChurnRateHistoryFromJson(data string) ChurnRateHistory {
	req := ChurnRateHistory{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChurnRateHistoryFromDict(data map[string]interface{}) ChurnRateHistory {
	return ChurnRateHistory{
		Date: func() *string {
			v, ok := data["date"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["date"])
		}(),
		ChurnRate: func() *float32 {
			v, ok := data["churnRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["churnRate"])
		}(),
	}
}

func (p ChurnRateHistory) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Date != nil {
		m["date"] = p.Date
	}
	if p.ChurnRate != nil {
		m["churnRate"] = p.ChurnRate
	}
	return m
}

func (p ChurnRateHistory) Pointer() *ChurnRateHistory {
	return &p
}

func CastChurnRateHistories(data []interface{}) []ChurnRateHistory {
	v := make([]ChurnRateHistory, 0)
	for _, d := range data {
		v = append(v, NewChurnRateHistoryFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChurnRateHistoriesFromDict(data []ChurnRateHistory) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChurnRateAverage struct {
	ChurnRate *float32 `json:"churnRate"`
}

func (p *ChurnRateAverage) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChurnRateAverage{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChurnRateAverage{}
	} else {
		*p = ChurnRateAverage{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["churnRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ChurnRate)
		}
	}
	return nil
}

func NewChurnRateAverageFromJson(data string) ChurnRateAverage {
	req := ChurnRateAverage{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChurnRateAverageFromDict(data map[string]interface{}) ChurnRateAverage {
	return ChurnRateAverage{
		ChurnRate: func() *float32 {
			v, ok := data["churnRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["churnRate"])
		}(),
	}
}

func (p ChurnRateAverage) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ChurnRate != nil {
		m["churnRate"] = p.ChurnRate
	}
	return m
}

func (p ChurnRateAverage) Pointer() *ChurnRateAverage {
	return &p
}

func CastChurnRateAverages(data []interface{}) []ChurnRateAverage {
	v := make([]ChurnRateAverage, 0)
	for _, d := range data {
		v = append(v, NewChurnRateAverageFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChurnRateAveragesFromDict(data []ChurnRateAverage) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChurnRateAggregate struct {
	History []ChurnRateHistory `json:"history"`
	Avg     *ChurnRateAverage  `json:"avg"`
}

func (p *ChurnRateAggregate) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChurnRateAggregate{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChurnRateAggregate{}
	} else {
		*p = ChurnRateAggregate{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["history"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.History)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
	}
	return nil
}

func NewChurnRateAggregateFromJson(data string) ChurnRateAggregate {
	req := ChurnRateAggregate{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChurnRateAggregateFromDict(data map[string]interface{}) ChurnRateAggregate {
	return ChurnRateAggregate{
		History: func() []ChurnRateHistory {
			if data["history"] == nil {
				return nil
			}
			return CastChurnRateHistories(core.CastArray(data["history"]))
		}(),
		Avg: func() *ChurnRateAverage {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return NewChurnRateAverageFromDict(core.CastMap(data["avg"])).Pointer()
		}(),
	}
}

func (p ChurnRateAggregate) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.History != nil {
		m["history"] = CastChurnRateHistoriesFromDict(
			p.History,
		)
	}
	if p.Avg != nil {
		m["avg"] = func() map[string]interface{} {
			if p.Avg == nil {
				return nil
			}
			return p.Avg.ToDict()
		}()
	}
	return m
}

func (p ChurnRateAggregate) Pointer() *ChurnRateAggregate {
	return &p
}

func CastChurnRateAggregates(data []interface{}) []ChurnRateAggregate {
	v := make([]ChurnRateAggregate, 0)
	for _, d := range data {
		v = append(v, NewChurnRateAggregateFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChurnRateAggregatesFromDict(data []ChurnRateAggregate) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type SessionDuration struct {
	Statistics   *SessionDurationStatistics    `json:"statistics"`
	Distribution []SessionDurationDistribution `json:"distribution"`
}

func (p *SessionDuration) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = SessionDuration{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = SessionDuration{}
	} else {
		*p = SessionDuration{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewSessionDurationFromJson(data string) SessionDuration {
	req := SessionDuration{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewSessionDurationFromDict(data map[string]interface{}) SessionDuration {
	return SessionDuration{
		Statistics: func() *SessionDurationStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewSessionDurationStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []SessionDurationDistribution {
			if data["distribution"] == nil {
				return nil
			}
			return CastSessionDurationDistributions(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p SessionDuration) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastSessionDurationDistributionsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p SessionDuration) Pointer() *SessionDuration {
	return &p
}

func CastSessionDurations(data []interface{}) []SessionDuration {
	v := make([]SessionDuration, 0)
	for _, d := range data {
		v = append(v, NewSessionDurationFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastSessionDurationsFromDict(data []SessionDuration) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type UseServices struct {
	Account     *bool `json:"account"`
	Chat        *bool `json:"chat"`
	Datastore   *bool `json:"datastore"`
	Dictionary  *bool `json:"dictionary"`
	Exchange    *bool `json:"exchange"`
	Experience  *bool `json:"experience"`
	Formation   *bool `json:"formation"`
	Friend      *bool `json:"friend"`
	Inbox       *bool `json:"inbox"`
	Inventory   *bool `json:"inventory"`
	Key         *bool `json:"key"`
	Limit       *bool `json:"limit"`
	Lottery     *bool `json:"lottery"`
	Matchmaking *bool `json:"matchmaking"`
	Mission     *bool `json:"mission"`
	Money       *bool `json:"money"`
	Quest       *bool `json:"quest"`
	Ranking     *bool `json:"ranking"`
	Showcase    *bool `json:"showcase"`
	Stamina     *bool `json:"stamina"`
}

func (p *UseServices) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = UseServices{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = UseServices{}
	} else {
		*p = UseServices{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["account"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Account)
		}
		if v, ok := d["chat"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Chat)
		}
		if v, ok := d["datastore"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Datastore)
		}
		if v, ok := d["dictionary"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Dictionary)
		}
		if v, ok := d["exchange"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Exchange)
		}
		if v, ok := d["experience"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Experience)
		}
		if v, ok := d["formation"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Formation)
		}
		if v, ok := d["friend"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Friend)
		}
		if v, ok := d["inbox"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Inbox)
		}
		if v, ok := d["inventory"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Inventory)
		}
		if v, ok := d["key"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Key)
		}
		if v, ok := d["limit"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Limit)
		}
		if v, ok := d["lottery"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Lottery)
		}
		if v, ok := d["matchmaking"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Matchmaking)
		}
		if v, ok := d["mission"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Mission)
		}
		if v, ok := d["money"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Money)
		}
		if v, ok := d["quest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Quest)
		}
		if v, ok := d["ranking"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Ranking)
		}
		if v, ok := d["showcase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Showcase)
		}
		if v, ok := d["stamina"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stamina)
		}
	}
	return nil
}

func NewUseServicesFromJson(data string) UseServices {
	req := UseServices{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewUseServicesFromDict(data map[string]interface{}) UseServices {
	return UseServices{
		Account: func() *bool {
			v, ok := data["account"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["account"])
		}(),
		Chat: func() *bool {
			v, ok := data["chat"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["chat"])
		}(),
		Datastore: func() *bool {
			v, ok := data["datastore"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["datastore"])
		}(),
		Dictionary: func() *bool {
			v, ok := data["dictionary"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["dictionary"])
		}(),
		Exchange: func() *bool {
			v, ok := data["exchange"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["exchange"])
		}(),
		Experience: func() *bool {
			v, ok := data["experience"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["experience"])
		}(),
		Formation: func() *bool {
			v, ok := data["formation"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["formation"])
		}(),
		Friend: func() *bool {
			v, ok := data["friend"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["friend"])
		}(),
		Inbox: func() *bool {
			v, ok := data["inbox"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["inbox"])
		}(),
		Inventory: func() *bool {
			v, ok := data["inventory"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["inventory"])
		}(),
		Key: func() *bool {
			v, ok := data["key"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["key"])
		}(),
		Limit: func() *bool {
			v, ok := data["limit"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["limit"])
		}(),
		Lottery: func() *bool {
			v, ok := data["lottery"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["lottery"])
		}(),
		Matchmaking: func() *bool {
			v, ok := data["matchmaking"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["matchmaking"])
		}(),
		Mission: func() *bool {
			v, ok := data["mission"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["mission"])
		}(),
		Money: func() *bool {
			v, ok := data["money"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["money"])
		}(),
		Quest: func() *bool {
			v, ok := data["quest"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["quest"])
		}(),
		Ranking: func() *bool {
			v, ok := data["ranking"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["ranking"])
		}(),
		Showcase: func() *bool {
			v, ok := data["showcase"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["showcase"])
		}(),
		Stamina: func() *bool {
			v, ok := data["stamina"]
			if !ok || v == nil {
				return nil
			}
			return core.CastBool(data["stamina"])
		}(),
	}
}

func (p UseServices) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Account != nil {
		m["account"] = p.Account
	}
	if p.Chat != nil {
		m["chat"] = p.Chat
	}
	if p.Datastore != nil {
		m["datastore"] = p.Datastore
	}
	if p.Dictionary != nil {
		m["dictionary"] = p.Dictionary
	}
	if p.Exchange != nil {
		m["exchange"] = p.Exchange
	}
	if p.Experience != nil {
		m["experience"] = p.Experience
	}
	if p.Formation != nil {
		m["formation"] = p.Formation
	}
	if p.Friend != nil {
		m["friend"] = p.Friend
	}
	if p.Inbox != nil {
		m["inbox"] = p.Inbox
	}
	if p.Inventory != nil {
		m["inventory"] = p.Inventory
	}
	if p.Key != nil {
		m["key"] = p.Key
	}
	if p.Limit != nil {
		m["limit"] = p.Limit
	}
	if p.Lottery != nil {
		m["lottery"] = p.Lottery
	}
	if p.Matchmaking != nil {
		m["matchmaking"] = p.Matchmaking
	}
	if p.Mission != nil {
		m["mission"] = p.Mission
	}
	if p.Money != nil {
		m["money"] = p.Money
	}
	if p.Quest != nil {
		m["quest"] = p.Quest
	}
	if p.Ranking != nil {
		m["ranking"] = p.Ranking
	}
	if p.Showcase != nil {
		m["showcase"] = p.Showcase
	}
	if p.Stamina != nil {
		m["stamina"] = p.Stamina
	}
	return m
}

func (p UseServices) Pointer() *UseServices {
	return &p
}

func CastUseServiceses(data []interface{}) []UseServices {
	v := make([]UseServices, 0)
	for _, d := range data {
		v = append(v, NewUseServicesFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastUseServicesesFromDict(data []UseServices) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type GeneralMetrics struct {
	DauWauMau       *GeneralDauWauMau   `json:"dauWauMau"`
	SessionDuration *SessionDuration    `json:"sessionDuration"`
	FirstEngagement *FirstEngagement    `json:"firstEngagement"`
	Engagements     *Engagements        `json:"engagements"`
	ChurnRates      *ChurnRateAggregate `json:"churnRates"`
	UseServices     *UseServices        `json:"useServices"`
}

func (p *GeneralMetrics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = GeneralMetrics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = GeneralMetrics{}
	} else {
		*p = GeneralMetrics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["dauWauMau"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DauWauMau)
		}
		if v, ok := d["sessionDuration"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SessionDuration)
		}
		if v, ok := d["firstEngagement"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.FirstEngagement)
		}
		if v, ok := d["engagements"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Engagements)
		}
		if v, ok := d["churnRates"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ChurnRates)
		}
		if v, ok := d["useServices"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.UseServices)
		}
	}
	return nil
}

func NewGeneralMetricsFromJson(data string) GeneralMetrics {
	req := GeneralMetrics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewGeneralMetricsFromDict(data map[string]interface{}) GeneralMetrics {
	return GeneralMetrics{
		DauWauMau: func() *GeneralDauWauMau {
			v, ok := data["dauWauMau"]
			if !ok || v == nil {
				return nil
			}
			return NewGeneralDauWauMauFromDict(core.CastMap(data["dauWauMau"])).Pointer()
		}(),
		SessionDuration: func() *SessionDuration {
			v, ok := data["sessionDuration"]
			if !ok || v == nil {
				return nil
			}
			return NewSessionDurationFromDict(core.CastMap(data["sessionDuration"])).Pointer()
		}(),
		FirstEngagement: func() *FirstEngagement {
			v, ok := data["firstEngagement"]
			if !ok || v == nil {
				return nil
			}
			return NewFirstEngagementFromDict(core.CastMap(data["firstEngagement"])).Pointer()
		}(),
		Engagements: func() *Engagements {
			v, ok := data["engagements"]
			if !ok || v == nil {
				return nil
			}
			return NewEngagementsFromDict(core.CastMap(data["engagements"])).Pointer()
		}(),
		ChurnRates: func() *ChurnRateAggregate {
			v, ok := data["churnRates"]
			if !ok || v == nil {
				return nil
			}
			return NewChurnRateAggregateFromDict(core.CastMap(data["churnRates"])).Pointer()
		}(),
		UseServices: func() *UseServices {
			v, ok := data["useServices"]
			if !ok || v == nil {
				return nil
			}
			return NewUseServicesFromDict(core.CastMap(data["useServices"])).Pointer()
		}(),
	}
}

func (p GeneralMetrics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.DauWauMau != nil {
		m["dauWauMau"] = func() map[string]interface{} {
			if p.DauWauMau == nil {
				return nil
			}
			return p.DauWauMau.ToDict()
		}()
	}
	if p.SessionDuration != nil {
		m["sessionDuration"] = func() map[string]interface{} {
			if p.SessionDuration == nil {
				return nil
			}
			return p.SessionDuration.ToDict()
		}()
	}
	if p.FirstEngagement != nil {
		m["firstEngagement"] = func() map[string]interface{} {
			if p.FirstEngagement == nil {
				return nil
			}
			return p.FirstEngagement.ToDict()
		}()
	}
	if p.Engagements != nil {
		m["engagements"] = func() map[string]interface{} {
			if p.Engagements == nil {
				return nil
			}
			return p.Engagements.ToDict()
		}()
	}
	if p.ChurnRates != nil {
		m["churnRates"] = func() map[string]interface{} {
			if p.ChurnRates == nil {
				return nil
			}
			return p.ChurnRates.ToDict()
		}()
	}
	if p.UseServices != nil {
		m["useServices"] = func() map[string]interface{} {
			if p.UseServices == nil {
				return nil
			}
			return p.UseServices.ToDict()
		}()
	}
	return m
}

func (p GeneralMetrics) Pointer() *GeneralMetrics {
	return &p
}

func CastGeneralMetricses(data []interface{}) []GeneralMetrics {
	v := make([]GeneralMetrics, 0)
	for _, d := range data {
		v = append(v, NewGeneralMetricsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastGeneralMetricsesFromDict(data []GeneralMetrics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespaceStatistics struct {
	Signup             *int64 `json:"signup"`
	Authentication     *int64 `json:"authentication"`
	RegisteredTakeOver *int64 `json:"registeredTakeOver"`
	RemoveTakeOver     *int64 `json:"removeTakeOver"`
	ExecuteTakeOver    *int64 `json:"executeTakeOver"`
}

func (p *AccountNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespaceStatistics{}
	} else {
		*p = AccountNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["signup"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Signup)
		}
		if v, ok := d["authentication"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Authentication)
		}
		if v, ok := d["registeredTakeOver"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RegisteredTakeOver)
		}
		if v, ok := d["removeTakeOver"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RemoveTakeOver)
		}
		if v, ok := d["executeTakeOver"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExecuteTakeOver)
		}
	}
	return nil
}

func NewAccountNamespaceStatisticsFromJson(data string) AccountNamespaceStatistics {
	req := AccountNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceStatisticsFromDict(data map[string]interface{}) AccountNamespaceStatistics {
	return AccountNamespaceStatistics{
		Signup: func() *int64 {
			v, ok := data["signup"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["signup"])
		}(),
		Authentication: func() *int64 {
			v, ok := data["authentication"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["authentication"])
		}(),
		RegisteredTakeOver: func() *int64 {
			v, ok := data["registeredTakeOver"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["registeredTakeOver"])
		}(),
		RemoveTakeOver: func() *int64 {
			v, ok := data["removeTakeOver"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["removeTakeOver"])
		}(),
		ExecuteTakeOver: func() *int64 {
			v, ok := data["executeTakeOver"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["executeTakeOver"])
		}(),
	}
}

func (p AccountNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Signup != nil {
		m["signup"] = p.Signup
	}
	if p.Authentication != nil {
		m["authentication"] = p.Authentication
	}
	if p.RegisteredTakeOver != nil {
		m["registeredTakeOver"] = p.RegisteredTakeOver
	}
	if p.RemoveTakeOver != nil {
		m["removeTakeOver"] = p.RemoveTakeOver
	}
	if p.ExecuteTakeOver != nil {
		m["executeTakeOver"] = p.ExecuteTakeOver
	}
	return m
}

func (p AccountNamespaceStatistics) Pointer() *AccountNamespaceStatistics {
	return &p
}

func CastAccountNamespaceStatisticses(data []interface{}) []AccountNamespaceStatistics {
	v := make([]AccountNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespaceStatisticsesFromDict(data []AccountNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespaceTypeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *AccountNamespaceTypeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespaceTypeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespaceTypeDistributionStatistics{}
	} else {
		*p = AccountNamespaceTypeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewAccountNamespaceTypeDistributionStatisticsFromJson(data string) AccountNamespaceTypeDistributionStatistics {
	req := AccountNamespaceTypeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceTypeDistributionStatisticsFromDict(data map[string]interface{}) AccountNamespaceTypeDistributionStatistics {
	return AccountNamespaceTypeDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p AccountNamespaceTypeDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p AccountNamespaceTypeDistributionStatistics) Pointer() *AccountNamespaceTypeDistributionStatistics {
	return &p
}

func CastAccountNamespaceTypeDistributionStatisticses(data []interface{}) []AccountNamespaceTypeDistributionStatistics {
	v := make([]AccountNamespaceTypeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceTypeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespaceTypeDistributionStatisticsesFromDict(data []AccountNamespaceTypeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespaceTypeDistributionSegment struct {
	Type  *int64 `json:"type"`
	Count *int64 `json:"count"`
}

func (p *AccountNamespaceTypeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespaceTypeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespaceTypeDistributionSegment{}
	} else {
		*p = AccountNamespaceTypeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["type"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Type)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewAccountNamespaceTypeDistributionSegmentFromJson(data string) AccountNamespaceTypeDistributionSegment {
	req := AccountNamespaceTypeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceTypeDistributionSegmentFromDict(data map[string]interface{}) AccountNamespaceTypeDistributionSegment {
	return AccountNamespaceTypeDistributionSegment{
		Type: func() *int64 {
			v, ok := data["type"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["type"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p AccountNamespaceTypeDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Type != nil {
		m["type"] = p.Type
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p AccountNamespaceTypeDistributionSegment) Pointer() *AccountNamespaceTypeDistributionSegment {
	return &p
}

func CastAccountNamespaceTypeDistributionSegments(data []interface{}) []AccountNamespaceTypeDistributionSegment {
	v := make([]AccountNamespaceTypeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceTypeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespaceTypeDistributionSegmentsFromDict(data []AccountNamespaceTypeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespaceTypeDistribution struct {
	Statistics   *AccountNamespaceTypeDistributionStatistics `json:"statistics"`
	Distribution []AccountNamespaceTypeDistributionSegment   `json:"distribution"`
}

func (p *AccountNamespaceTypeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespaceTypeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespaceTypeDistribution{}
	} else {
		*p = AccountNamespaceTypeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewAccountNamespaceTypeDistributionFromJson(data string) AccountNamespaceTypeDistribution {
	req := AccountNamespaceTypeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceTypeDistributionFromDict(data map[string]interface{}) AccountNamespaceTypeDistribution {
	return AccountNamespaceTypeDistribution{
		Statistics: func() *AccountNamespaceTypeDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewAccountNamespaceTypeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []AccountNamespaceTypeDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastAccountNamespaceTypeDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p AccountNamespaceTypeDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastAccountNamespaceTypeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p AccountNamespaceTypeDistribution) Pointer() *AccountNamespaceTypeDistribution {
	return &p
}

func CastAccountNamespaceTypeDistributions(data []interface{}) []AccountNamespaceTypeDistribution {
	v := make([]AccountNamespaceTypeDistribution, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceTypeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespaceTypeDistributionsFromDict(data []AccountNamespaceTypeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespaceDistributions struct {
	Type *AccountNamespaceTypeDistribution `json:"type"`
}

func (p *AccountNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespaceDistributions{}
	} else {
		*p = AccountNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["type"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Type)
		}
	}
	return nil
}

func NewAccountNamespaceDistributionsFromJson(data string) AccountNamespaceDistributions {
	req := AccountNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceDistributionsFromDict(data map[string]interface{}) AccountNamespaceDistributions {
	return AccountNamespaceDistributions{
		Type: func() *AccountNamespaceTypeDistribution {
			v, ok := data["type"]
			if !ok || v == nil {
				return nil
			}
			return NewAccountNamespaceTypeDistributionFromDict(core.CastMap(data["type"])).Pointer()
		}(),
	}
}

func (p AccountNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Type != nil {
		m["type"] = func() map[string]interface{} {
			if p.Type == nil {
				return nil
			}
			return p.Type.ToDict()
		}()
	}
	return m
}

func (p AccountNamespaceDistributions) Pointer() *AccountNamespaceDistributions {
	return &p
}

func CastAccountNamespaceDistributionses(data []interface{}) []AccountNamespaceDistributions {
	v := make([]AccountNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespaceDistributionsesFromDict(data []AccountNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type AccountNamespace struct {
	NamespaceId   *string                        `json:"namespaceId"`
	Year          *int32                         `json:"year"`
	Month         *int32                         `json:"month"`
	Day           *int32                         `json:"day"`
	NamespaceName *string                        `json:"namespaceName"`
	Statistics    *AccountNamespaceStatistics    `json:"statistics"`
	Distributions *AccountNamespaceDistributions `json:"distributions"`
}

func (p *AccountNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = AccountNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = AccountNamespace{}
	} else {
		*p = AccountNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewAccountNamespaceFromJson(data string) AccountNamespace {
	req := AccountNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewAccountNamespaceFromDict(data map[string]interface{}) AccountNamespace {
	return AccountNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *AccountNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewAccountNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *AccountNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewAccountNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p AccountNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p AccountNamespace) Pointer() *AccountNamespace {
	return &p
}

func CastAccountNamespaces(data []interface{}) []AccountNamespace {
	v := make([]AccountNamespace, 0)
	for _, d := range data {
		v = append(v, NewAccountNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastAccountNamespacesFromDict(data []AccountNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespaceStatistics struct {
	Post            *int64 `json:"post"`
	CreateRoom      *int64 `json:"createRoom"`
	DeleteRoom      *int64 `json:"deleteRoom"`
	CreateSubscribe *int64 `json:"createSubscribe"`
	DeleteSubscribe *int64 `json:"deleteSubscribe"`
}

func (p *ChatNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespaceStatistics{}
	} else {
		*p = ChatNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["post"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Post)
		}
		if v, ok := d["createRoom"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CreateRoom)
		}
		if v, ok := d["deleteRoom"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DeleteRoom)
		}
		if v, ok := d["createSubscribe"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CreateSubscribe)
		}
		if v, ok := d["deleteSubscribe"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DeleteSubscribe)
		}
	}
	return nil
}

func NewChatNamespaceStatisticsFromJson(data string) ChatNamespaceStatistics {
	req := ChatNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespaceStatisticsFromDict(data map[string]interface{}) ChatNamespaceStatistics {
	return ChatNamespaceStatistics{
		Post: func() *int64 {
			v, ok := data["post"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["post"])
		}(),
		CreateRoom: func() *int64 {
			v, ok := data["createRoom"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["createRoom"])
		}(),
		DeleteRoom: func() *int64 {
			v, ok := data["deleteRoom"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["deleteRoom"])
		}(),
		CreateSubscribe: func() *int64 {
			v, ok := data["createSubscribe"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["createSubscribe"])
		}(),
		DeleteSubscribe: func() *int64 {
			v, ok := data["deleteSubscribe"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["deleteSubscribe"])
		}(),
	}
}

func (p ChatNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Post != nil {
		m["post"] = p.Post
	}
	if p.CreateRoom != nil {
		m["createRoom"] = p.CreateRoom
	}
	if p.DeleteRoom != nil {
		m["deleteRoom"] = p.DeleteRoom
	}
	if p.CreateSubscribe != nil {
		m["createSubscribe"] = p.CreateSubscribe
	}
	if p.DeleteSubscribe != nil {
		m["deleteSubscribe"] = p.DeleteSubscribe
	}
	return m
}

func (p ChatNamespaceStatistics) Pointer() *ChatNamespaceStatistics {
	return &p
}

func CastChatNamespaceStatisticses(data []interface{}) []ChatNamespaceStatistics {
	v := make([]ChatNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewChatNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespaceStatisticsesFromDict(data []ChatNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByRoomDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ChatNamespacePostByRoomDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByRoomDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByRoomDistributionStatistics{}
	} else {
		*p = ChatNamespacePostByRoomDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewChatNamespacePostByRoomDistributionStatisticsFromJson(data string) ChatNamespacePostByRoomDistributionStatistics {
	req := ChatNamespacePostByRoomDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByRoomDistributionStatisticsFromDict(data map[string]interface{}) ChatNamespacePostByRoomDistributionStatistics {
	return ChatNamespacePostByRoomDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ChatNamespacePostByRoomDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ChatNamespacePostByRoomDistributionStatistics) Pointer() *ChatNamespacePostByRoomDistributionStatistics {
	return &p
}

func CastChatNamespacePostByRoomDistributionStatisticses(data []interface{}) []ChatNamespacePostByRoomDistributionStatistics {
	v := make([]ChatNamespacePostByRoomDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByRoomDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByRoomDistributionStatisticsesFromDict(data []ChatNamespacePostByRoomDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByRoomDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ChatNamespacePostByRoomDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByRoomDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByRoomDistributionSegment{}
	} else {
		*p = ChatNamespacePostByRoomDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewChatNamespacePostByRoomDistributionSegmentFromJson(data string) ChatNamespacePostByRoomDistributionSegment {
	req := ChatNamespacePostByRoomDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByRoomDistributionSegmentFromDict(data map[string]interface{}) ChatNamespacePostByRoomDistributionSegment {
	return ChatNamespacePostByRoomDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ChatNamespacePostByRoomDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ChatNamespacePostByRoomDistributionSegment) Pointer() *ChatNamespacePostByRoomDistributionSegment {
	return &p
}

func CastChatNamespacePostByRoomDistributionSegments(data []interface{}) []ChatNamespacePostByRoomDistributionSegment {
	v := make([]ChatNamespacePostByRoomDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByRoomDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByRoomDistributionSegmentsFromDict(data []ChatNamespacePostByRoomDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByRoomDistribution struct {
	Statistics   *ChatNamespacePostByRoomDistributionStatistics `json:"statistics"`
	Distribution []ChatNamespacePostByRoomDistributionSegment   `json:"distribution"`
}

func (p *ChatNamespacePostByRoomDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByRoomDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByRoomDistribution{}
	} else {
		*p = ChatNamespacePostByRoomDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewChatNamespacePostByRoomDistributionFromJson(data string) ChatNamespacePostByRoomDistribution {
	req := ChatNamespacePostByRoomDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByRoomDistributionFromDict(data map[string]interface{}) ChatNamespacePostByRoomDistribution {
	return ChatNamespacePostByRoomDistribution{
		Statistics: func() *ChatNamespacePostByRoomDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewChatNamespacePostByRoomDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ChatNamespacePostByRoomDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastChatNamespacePostByRoomDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ChatNamespacePostByRoomDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastChatNamespacePostByRoomDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ChatNamespacePostByRoomDistribution) Pointer() *ChatNamespacePostByRoomDistribution {
	return &p
}

func CastChatNamespacePostByRoomDistributions(data []interface{}) []ChatNamespacePostByRoomDistribution {
	v := make([]ChatNamespacePostByRoomDistribution, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByRoomDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByRoomDistributionsFromDict(data []ChatNamespacePostByRoomDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ChatNamespacePostByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByUserDistributionStatistics{}
	} else {
		*p = ChatNamespacePostByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewChatNamespacePostByUserDistributionStatisticsFromJson(data string) ChatNamespacePostByUserDistributionStatistics {
	req := ChatNamespacePostByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByUserDistributionStatisticsFromDict(data map[string]interface{}) ChatNamespacePostByUserDistributionStatistics {
	return ChatNamespacePostByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ChatNamespacePostByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ChatNamespacePostByUserDistributionStatistics) Pointer() *ChatNamespacePostByUserDistributionStatistics {
	return &p
}

func CastChatNamespacePostByUserDistributionStatisticses(data []interface{}) []ChatNamespacePostByUserDistributionStatistics {
	v := make([]ChatNamespacePostByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByUserDistributionStatisticsesFromDict(data []ChatNamespacePostByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ChatNamespacePostByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByUserDistributionSegment{}
	} else {
		*p = ChatNamespacePostByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewChatNamespacePostByUserDistributionSegmentFromJson(data string) ChatNamespacePostByUserDistributionSegment {
	req := ChatNamespacePostByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByUserDistributionSegmentFromDict(data map[string]interface{}) ChatNamespacePostByUserDistributionSegment {
	return ChatNamespacePostByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ChatNamespacePostByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ChatNamespacePostByUserDistributionSegment) Pointer() *ChatNamespacePostByUserDistributionSegment {
	return &p
}

func CastChatNamespacePostByUserDistributionSegments(data []interface{}) []ChatNamespacePostByUserDistributionSegment {
	v := make([]ChatNamespacePostByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByUserDistributionSegmentsFromDict(data []ChatNamespacePostByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByUserDistribution struct {
	Statistics   *ChatNamespacePostByUserDistributionStatistics `json:"statistics"`
	Distribution []ChatNamespacePostByUserDistributionSegment   `json:"distribution"`
}

func (p *ChatNamespacePostByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByUserDistribution{}
	} else {
		*p = ChatNamespacePostByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewChatNamespacePostByUserDistributionFromJson(data string) ChatNamespacePostByUserDistribution {
	req := ChatNamespacePostByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByUserDistributionFromDict(data map[string]interface{}) ChatNamespacePostByUserDistribution {
	return ChatNamespacePostByUserDistribution{
		Statistics: func() *ChatNamespacePostByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewChatNamespacePostByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ChatNamespacePostByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastChatNamespacePostByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ChatNamespacePostByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastChatNamespacePostByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ChatNamespacePostByUserDistribution) Pointer() *ChatNamespacePostByUserDistribution {
	return &p
}

func CastChatNamespacePostByUserDistributions(data []interface{}) []ChatNamespacePostByUserDistribution {
	v := make([]ChatNamespacePostByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByUserDistributionsFromDict(data []ChatNamespacePostByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByCategoryDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ChatNamespacePostByCategoryDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByCategoryDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByCategoryDistributionStatistics{}
	} else {
		*p = ChatNamespacePostByCategoryDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewChatNamespacePostByCategoryDistributionStatisticsFromJson(data string) ChatNamespacePostByCategoryDistributionStatistics {
	req := ChatNamespacePostByCategoryDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByCategoryDistributionStatisticsFromDict(data map[string]interface{}) ChatNamespacePostByCategoryDistributionStatistics {
	return ChatNamespacePostByCategoryDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ChatNamespacePostByCategoryDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ChatNamespacePostByCategoryDistributionStatistics) Pointer() *ChatNamespacePostByCategoryDistributionStatistics {
	return &p
}

func CastChatNamespacePostByCategoryDistributionStatisticses(data []interface{}) []ChatNamespacePostByCategoryDistributionStatistics {
	v := make([]ChatNamespacePostByCategoryDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByCategoryDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByCategoryDistributionStatisticsesFromDict(data []ChatNamespacePostByCategoryDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByCategoryDistributionSegment struct {
	Category *int64 `json:"category"`
	Count    *int64 `json:"count"`
}

func (p *ChatNamespacePostByCategoryDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByCategoryDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByCategoryDistributionSegment{}
	} else {
		*p = ChatNamespacePostByCategoryDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["category"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Category)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewChatNamespacePostByCategoryDistributionSegmentFromJson(data string) ChatNamespacePostByCategoryDistributionSegment {
	req := ChatNamespacePostByCategoryDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByCategoryDistributionSegmentFromDict(data map[string]interface{}) ChatNamespacePostByCategoryDistributionSegment {
	return ChatNamespacePostByCategoryDistributionSegment{
		Category: func() *int64 {
			v, ok := data["category"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["category"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ChatNamespacePostByCategoryDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Category != nil {
		m["category"] = p.Category
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ChatNamespacePostByCategoryDistributionSegment) Pointer() *ChatNamespacePostByCategoryDistributionSegment {
	return &p
}

func CastChatNamespacePostByCategoryDistributionSegments(data []interface{}) []ChatNamespacePostByCategoryDistributionSegment {
	v := make([]ChatNamespacePostByCategoryDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByCategoryDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByCategoryDistributionSegmentsFromDict(data []ChatNamespacePostByCategoryDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespacePostByCategoryDistribution struct {
	Statistics   *ChatNamespacePostByCategoryDistributionStatistics `json:"statistics"`
	Distribution []ChatNamespacePostByCategoryDistributionSegment   `json:"distribution"`
}

func (p *ChatNamespacePostByCategoryDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespacePostByCategoryDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespacePostByCategoryDistribution{}
	} else {
		*p = ChatNamespacePostByCategoryDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewChatNamespacePostByCategoryDistributionFromJson(data string) ChatNamespacePostByCategoryDistribution {
	req := ChatNamespacePostByCategoryDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespacePostByCategoryDistributionFromDict(data map[string]interface{}) ChatNamespacePostByCategoryDistribution {
	return ChatNamespacePostByCategoryDistribution{
		Statistics: func() *ChatNamespacePostByCategoryDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewChatNamespacePostByCategoryDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ChatNamespacePostByCategoryDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastChatNamespacePostByCategoryDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ChatNamespacePostByCategoryDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastChatNamespacePostByCategoryDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ChatNamespacePostByCategoryDistribution) Pointer() *ChatNamespacePostByCategoryDistribution {
	return &p
}

func CastChatNamespacePostByCategoryDistributions(data []interface{}) []ChatNamespacePostByCategoryDistribution {
	v := make([]ChatNamespacePostByCategoryDistribution, 0)
	for _, d := range data {
		v = append(v, NewChatNamespacePostByCategoryDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacePostByCategoryDistributionsFromDict(data []ChatNamespacePostByCategoryDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespaceDistributions struct {
	PostByRoom     *ChatNamespacePostByRoomDistribution     `json:"postByRoom"`
	PostByUser     *ChatNamespacePostByUserDistribution     `json:"postByUser"`
	PostByCategory *ChatNamespacePostByCategoryDistribution `json:"postByCategory"`
}

func (p *ChatNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespaceDistributions{}
	} else {
		*p = ChatNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["postByRoom"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.PostByRoom)
		}
		if v, ok := d["postByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.PostByUser)
		}
		if v, ok := d["postByCategory"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.PostByCategory)
		}
	}
	return nil
}

func NewChatNamespaceDistributionsFromJson(data string) ChatNamespaceDistributions {
	req := ChatNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespaceDistributionsFromDict(data map[string]interface{}) ChatNamespaceDistributions {
	return ChatNamespaceDistributions{
		PostByRoom: func() *ChatNamespacePostByRoomDistribution {
			v, ok := data["postByRoom"]
			if !ok || v == nil {
				return nil
			}
			return NewChatNamespacePostByRoomDistributionFromDict(core.CastMap(data["postByRoom"])).Pointer()
		}(),
		PostByUser: func() *ChatNamespacePostByUserDistribution {
			v, ok := data["postByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewChatNamespacePostByUserDistributionFromDict(core.CastMap(data["postByUser"])).Pointer()
		}(),
		PostByCategory: func() *ChatNamespacePostByCategoryDistribution {
			v, ok := data["postByCategory"]
			if !ok || v == nil {
				return nil
			}
			return NewChatNamespacePostByCategoryDistributionFromDict(core.CastMap(data["postByCategory"])).Pointer()
		}(),
	}
}

func (p ChatNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.PostByRoom != nil {
		m["postByRoom"] = func() map[string]interface{} {
			if p.PostByRoom == nil {
				return nil
			}
			return p.PostByRoom.ToDict()
		}()
	}
	if p.PostByUser != nil {
		m["postByUser"] = func() map[string]interface{} {
			if p.PostByUser == nil {
				return nil
			}
			return p.PostByUser.ToDict()
		}()
	}
	if p.PostByCategory != nil {
		m["postByCategory"] = func() map[string]interface{} {
			if p.PostByCategory == nil {
				return nil
			}
			return p.PostByCategory.ToDict()
		}()
	}
	return m
}

func (p ChatNamespaceDistributions) Pointer() *ChatNamespaceDistributions {
	return &p
}

func CastChatNamespaceDistributionses(data []interface{}) []ChatNamespaceDistributions {
	v := make([]ChatNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewChatNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespaceDistributionsesFromDict(data []ChatNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ChatNamespace struct {
	NamespaceId   *string                     `json:"namespaceId"`
	Year          *int32                      `json:"year"`
	Month         *int32                      `json:"month"`
	Day           *int32                      `json:"day"`
	NamespaceName *string                     `json:"namespaceName"`
	Statistics    *ChatNamespaceStatistics    `json:"statistics"`
	Distributions *ChatNamespaceDistributions `json:"distributions"`
}

func (p *ChatNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ChatNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ChatNamespace{}
	} else {
		*p = ChatNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewChatNamespaceFromJson(data string) ChatNamespace {
	req := ChatNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewChatNamespaceFromDict(data map[string]interface{}) ChatNamespace {
	return ChatNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *ChatNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewChatNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *ChatNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewChatNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p ChatNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p ChatNamespace) Pointer() *ChatNamespace {
	return &p
}

func CastChatNamespaces(data []interface{}) []ChatNamespace {
	v := make([]ChatNamespace, 0)
	for _, d := range data {
		v = append(v, NewChatNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastChatNamespacesFromDict(data []ChatNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceStatistics struct {
	Upload   *int64 `json:"upload"`
	Download *int64 `json:"download"`
}

func (p *DatastoreNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceStatistics{}
	} else {
		*p = DatastoreNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["upload"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Upload)
		}
		if v, ok := d["download"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Download)
		}
	}
	return nil
}

func NewDatastoreNamespaceStatisticsFromJson(data string) DatastoreNamespaceStatistics {
	req := DatastoreNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceStatisticsFromDict(data map[string]interface{}) DatastoreNamespaceStatistics {
	return DatastoreNamespaceStatistics{
		Upload: func() *int64 {
			v, ok := data["upload"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["upload"])
		}(),
		Download: func() *int64 {
			v, ok := data["download"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["download"])
		}(),
	}
}

func (p DatastoreNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Upload != nil {
		m["upload"] = p.Upload
	}
	if p.Download != nil {
		m["download"] = p.Download
	}
	return m
}

func (p DatastoreNamespaceStatistics) Pointer() *DatastoreNamespaceStatistics {
	return &p
}

func CastDatastoreNamespaceStatisticses(data []interface{}) []DatastoreNamespaceStatistics {
	v := make([]DatastoreNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceStatisticsesFromDict(data []DatastoreNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDownloadByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *DatastoreNamespaceDownloadByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDownloadByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDownloadByUserDistributionStatistics{}
	} else {
		*p = DatastoreNamespaceDownloadByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewDatastoreNamespaceDownloadByUserDistributionStatisticsFromJson(data string) DatastoreNamespaceDownloadByUserDistributionStatistics {
	req := DatastoreNamespaceDownloadByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDownloadByUserDistributionStatisticsFromDict(data map[string]interface{}) DatastoreNamespaceDownloadByUserDistributionStatistics {
	return DatastoreNamespaceDownloadByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p DatastoreNamespaceDownloadByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p DatastoreNamespaceDownloadByUserDistributionStatistics) Pointer() *DatastoreNamespaceDownloadByUserDistributionStatistics {
	return &p
}

func CastDatastoreNamespaceDownloadByUserDistributionStatisticses(data []interface{}) []DatastoreNamespaceDownloadByUserDistributionStatistics {
	v := make([]DatastoreNamespaceDownloadByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDownloadByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDownloadByUserDistributionStatisticsesFromDict(data []DatastoreNamespaceDownloadByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDownloadByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *DatastoreNamespaceDownloadByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDownloadByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDownloadByUserDistributionSegment{}
	} else {
		*p = DatastoreNamespaceDownloadByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewDatastoreNamespaceDownloadByUserDistributionSegmentFromJson(data string) DatastoreNamespaceDownloadByUserDistributionSegment {
	req := DatastoreNamespaceDownloadByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDownloadByUserDistributionSegmentFromDict(data map[string]interface{}) DatastoreNamespaceDownloadByUserDistributionSegment {
	return DatastoreNamespaceDownloadByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p DatastoreNamespaceDownloadByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p DatastoreNamespaceDownloadByUserDistributionSegment) Pointer() *DatastoreNamespaceDownloadByUserDistributionSegment {
	return &p
}

func CastDatastoreNamespaceDownloadByUserDistributionSegments(data []interface{}) []DatastoreNamespaceDownloadByUserDistributionSegment {
	v := make([]DatastoreNamespaceDownloadByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDownloadByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDownloadByUserDistributionSegmentsFromDict(data []DatastoreNamespaceDownloadByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDownloadByUserDistribution struct {
	Statistics   *DatastoreNamespaceDownloadByUserDistributionStatistics `json:"statistics"`
	Distribution []DatastoreNamespaceDownloadByUserDistributionSegment   `json:"distribution"`
}

func (p *DatastoreNamespaceDownloadByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDownloadByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDownloadByUserDistribution{}
	} else {
		*p = DatastoreNamespaceDownloadByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewDatastoreNamespaceDownloadByUserDistributionFromJson(data string) DatastoreNamespaceDownloadByUserDistribution {
	req := DatastoreNamespaceDownloadByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDownloadByUserDistributionFromDict(data map[string]interface{}) DatastoreNamespaceDownloadByUserDistribution {
	return DatastoreNamespaceDownloadByUserDistribution{
		Statistics: func() *DatastoreNamespaceDownloadByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewDatastoreNamespaceDownloadByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []DatastoreNamespaceDownloadByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastDatastoreNamespaceDownloadByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p DatastoreNamespaceDownloadByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastDatastoreNamespaceDownloadByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p DatastoreNamespaceDownloadByUserDistribution) Pointer() *DatastoreNamespaceDownloadByUserDistribution {
	return &p
}

func CastDatastoreNamespaceDownloadByUserDistributions(data []interface{}) []DatastoreNamespaceDownloadByUserDistribution {
	v := make([]DatastoreNamespaceDownloadByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDownloadByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDownloadByUserDistributionsFromDict(data []DatastoreNamespaceDownloadByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceUploadByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *DatastoreNamespaceUploadByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceUploadByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceUploadByUserDistributionStatistics{}
	} else {
		*p = DatastoreNamespaceUploadByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewDatastoreNamespaceUploadByUserDistributionStatisticsFromJson(data string) DatastoreNamespaceUploadByUserDistributionStatistics {
	req := DatastoreNamespaceUploadByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceUploadByUserDistributionStatisticsFromDict(data map[string]interface{}) DatastoreNamespaceUploadByUserDistributionStatistics {
	return DatastoreNamespaceUploadByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p DatastoreNamespaceUploadByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p DatastoreNamespaceUploadByUserDistributionStatistics) Pointer() *DatastoreNamespaceUploadByUserDistributionStatistics {
	return &p
}

func CastDatastoreNamespaceUploadByUserDistributionStatisticses(data []interface{}) []DatastoreNamespaceUploadByUserDistributionStatistics {
	v := make([]DatastoreNamespaceUploadByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceUploadByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceUploadByUserDistributionStatisticsesFromDict(data []DatastoreNamespaceUploadByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceUploadByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *DatastoreNamespaceUploadByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceUploadByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceUploadByUserDistributionSegment{}
	} else {
		*p = DatastoreNamespaceUploadByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewDatastoreNamespaceUploadByUserDistributionSegmentFromJson(data string) DatastoreNamespaceUploadByUserDistributionSegment {
	req := DatastoreNamespaceUploadByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceUploadByUserDistributionSegmentFromDict(data map[string]interface{}) DatastoreNamespaceUploadByUserDistributionSegment {
	return DatastoreNamespaceUploadByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p DatastoreNamespaceUploadByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p DatastoreNamespaceUploadByUserDistributionSegment) Pointer() *DatastoreNamespaceUploadByUserDistributionSegment {
	return &p
}

func CastDatastoreNamespaceUploadByUserDistributionSegments(data []interface{}) []DatastoreNamespaceUploadByUserDistributionSegment {
	v := make([]DatastoreNamespaceUploadByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceUploadByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceUploadByUserDistributionSegmentsFromDict(data []DatastoreNamespaceUploadByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceUploadByUserDistribution struct {
	Statistics   *DatastoreNamespaceUploadByUserDistributionStatistics `json:"statistics"`
	Distribution []DatastoreNamespaceUploadByUserDistributionSegment   `json:"distribution"`
}

func (p *DatastoreNamespaceUploadByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceUploadByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceUploadByUserDistribution{}
	} else {
		*p = DatastoreNamespaceUploadByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewDatastoreNamespaceUploadByUserDistributionFromJson(data string) DatastoreNamespaceUploadByUserDistribution {
	req := DatastoreNamespaceUploadByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceUploadByUserDistributionFromDict(data map[string]interface{}) DatastoreNamespaceUploadByUserDistribution {
	return DatastoreNamespaceUploadByUserDistribution{
		Statistics: func() *DatastoreNamespaceUploadByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewDatastoreNamespaceUploadByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []DatastoreNamespaceUploadByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastDatastoreNamespaceUploadByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p DatastoreNamespaceUploadByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastDatastoreNamespaceUploadByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p DatastoreNamespaceUploadByUserDistribution) Pointer() *DatastoreNamespaceUploadByUserDistribution {
	return &p
}

func CastDatastoreNamespaceUploadByUserDistributions(data []interface{}) []DatastoreNamespaceUploadByUserDistribution {
	v := make([]DatastoreNamespaceUploadByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceUploadByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceUploadByUserDistributionsFromDict(data []DatastoreNamespaceUploadByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDataSizeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *DatastoreNamespaceDataSizeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDataSizeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDataSizeDistributionStatistics{}
	} else {
		*p = DatastoreNamespaceDataSizeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewDatastoreNamespaceDataSizeDistributionStatisticsFromJson(data string) DatastoreNamespaceDataSizeDistributionStatistics {
	req := DatastoreNamespaceDataSizeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDataSizeDistributionStatisticsFromDict(data map[string]interface{}) DatastoreNamespaceDataSizeDistributionStatistics {
	return DatastoreNamespaceDataSizeDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p DatastoreNamespaceDataSizeDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p DatastoreNamespaceDataSizeDistributionStatistics) Pointer() *DatastoreNamespaceDataSizeDistributionStatistics {
	return &p
}

func CastDatastoreNamespaceDataSizeDistributionStatisticses(data []interface{}) []DatastoreNamespaceDataSizeDistributionStatistics {
	v := make([]DatastoreNamespaceDataSizeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDataSizeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDataSizeDistributionStatisticsesFromDict(data []DatastoreNamespaceDataSizeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDataSizeDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *DatastoreNamespaceDataSizeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDataSizeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDataSizeDistributionSegment{}
	} else {
		*p = DatastoreNamespaceDataSizeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewDatastoreNamespaceDataSizeDistributionSegmentFromJson(data string) DatastoreNamespaceDataSizeDistributionSegment {
	req := DatastoreNamespaceDataSizeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDataSizeDistributionSegmentFromDict(data map[string]interface{}) DatastoreNamespaceDataSizeDistributionSegment {
	return DatastoreNamespaceDataSizeDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p DatastoreNamespaceDataSizeDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p DatastoreNamespaceDataSizeDistributionSegment) Pointer() *DatastoreNamespaceDataSizeDistributionSegment {
	return &p
}

func CastDatastoreNamespaceDataSizeDistributionSegments(data []interface{}) []DatastoreNamespaceDataSizeDistributionSegment {
	v := make([]DatastoreNamespaceDataSizeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDataSizeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDataSizeDistributionSegmentsFromDict(data []DatastoreNamespaceDataSizeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDataSizeDistribution struct {
	Statistics   *DatastoreNamespaceDataSizeDistributionStatistics `json:"statistics"`
	Distribution []DatastoreNamespaceDataSizeDistributionSegment   `json:"distribution"`
}

func (p *DatastoreNamespaceDataSizeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDataSizeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDataSizeDistribution{}
	} else {
		*p = DatastoreNamespaceDataSizeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewDatastoreNamespaceDataSizeDistributionFromJson(data string) DatastoreNamespaceDataSizeDistribution {
	req := DatastoreNamespaceDataSizeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDataSizeDistributionFromDict(data map[string]interface{}) DatastoreNamespaceDataSizeDistribution {
	return DatastoreNamespaceDataSizeDistribution{
		Statistics: func() *DatastoreNamespaceDataSizeDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewDatastoreNamespaceDataSizeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []DatastoreNamespaceDataSizeDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastDatastoreNamespaceDataSizeDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p DatastoreNamespaceDataSizeDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastDatastoreNamespaceDataSizeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p DatastoreNamespaceDataSizeDistribution) Pointer() *DatastoreNamespaceDataSizeDistribution {
	return &p
}

func CastDatastoreNamespaceDataSizeDistributions(data []interface{}) []DatastoreNamespaceDataSizeDistribution {
	v := make([]DatastoreNamespaceDataSizeDistribution, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDataSizeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDataSizeDistributionsFromDict(data []DatastoreNamespaceDataSizeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespaceDistributions struct {
	DownloadByUser *DatastoreNamespaceDownloadByUserDistribution `json:"downloadByUser"`
	UploadByUser   *DatastoreNamespaceUploadByUserDistribution   `json:"uploadByUser"`
	DataSize       *DatastoreNamespaceDataSizeDistribution       `json:"dataSize"`
}

func (p *DatastoreNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespaceDistributions{}
	} else {
		*p = DatastoreNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["downloadByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DownloadByUser)
		}
		if v, ok := d["uploadByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.UploadByUser)
		}
		if v, ok := d["dataSize"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DataSize)
		}
	}
	return nil
}

func NewDatastoreNamespaceDistributionsFromJson(data string) DatastoreNamespaceDistributions {
	req := DatastoreNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceDistributionsFromDict(data map[string]interface{}) DatastoreNamespaceDistributions {
	return DatastoreNamespaceDistributions{
		DownloadByUser: func() *DatastoreNamespaceDownloadByUserDistribution {
			v, ok := data["downloadByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewDatastoreNamespaceDownloadByUserDistributionFromDict(core.CastMap(data["downloadByUser"])).Pointer()
		}(),
		UploadByUser: func() *DatastoreNamespaceUploadByUserDistribution {
			v, ok := data["uploadByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewDatastoreNamespaceUploadByUserDistributionFromDict(core.CastMap(data["uploadByUser"])).Pointer()
		}(),
		DataSize: func() *DatastoreNamespaceDataSizeDistribution {
			v, ok := data["dataSize"]
			if !ok || v == nil {
				return nil
			}
			return NewDatastoreNamespaceDataSizeDistributionFromDict(core.CastMap(data["dataSize"])).Pointer()
		}(),
	}
}

func (p DatastoreNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.DownloadByUser != nil {
		m["downloadByUser"] = func() map[string]interface{} {
			if p.DownloadByUser == nil {
				return nil
			}
			return p.DownloadByUser.ToDict()
		}()
	}
	if p.UploadByUser != nil {
		m["uploadByUser"] = func() map[string]interface{} {
			if p.UploadByUser == nil {
				return nil
			}
			return p.UploadByUser.ToDict()
		}()
	}
	if p.DataSize != nil {
		m["dataSize"] = func() map[string]interface{} {
			if p.DataSize == nil {
				return nil
			}
			return p.DataSize.ToDict()
		}()
	}
	return m
}

func (p DatastoreNamespaceDistributions) Pointer() *DatastoreNamespaceDistributions {
	return &p
}

func CastDatastoreNamespaceDistributionses(data []interface{}) []DatastoreNamespaceDistributions {
	v := make([]DatastoreNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespaceDistributionsesFromDict(data []DatastoreNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DatastoreNamespace struct {
	NamespaceId   *string                          `json:"namespaceId"`
	Year          *int32                           `json:"year"`
	Month         *int32                           `json:"month"`
	Day           *int32                           `json:"day"`
	NamespaceName *string                          `json:"namespaceName"`
	Statistics    *DatastoreNamespaceStatistics    `json:"statistics"`
	Distributions *DatastoreNamespaceDistributions `json:"distributions"`
}

func (p *DatastoreNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DatastoreNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DatastoreNamespace{}
	} else {
		*p = DatastoreNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewDatastoreNamespaceFromJson(data string) DatastoreNamespace {
	req := DatastoreNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDatastoreNamespaceFromDict(data map[string]interface{}) DatastoreNamespace {
	return DatastoreNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *DatastoreNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewDatastoreNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *DatastoreNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewDatastoreNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p DatastoreNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p DatastoreNamespace) Pointer() *DatastoreNamespace {
	return &p
}

func CastDatastoreNamespaces(data []interface{}) []DatastoreNamespace {
	v := make([]DatastoreNamespace, 0)
	for _, d := range data {
		v = append(v, NewDatastoreNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDatastoreNamespacesFromDict(data []DatastoreNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceStatistics struct {
	Register *int64 `json:"register"`
}

func (p *DictionaryNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceStatistics{}
	} else {
		*p = DictionaryNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["register"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Register)
		}
	}
	return nil
}

func NewDictionaryNamespaceStatisticsFromJson(data string) DictionaryNamespaceStatistics {
	req := DictionaryNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceStatisticsFromDict(data map[string]interface{}) DictionaryNamespaceStatistics {
	return DictionaryNamespaceStatistics{
		Register: func() *int64 {
			v, ok := data["register"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["register"])
		}(),
	}
}

func (p DictionaryNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Register != nil {
		m["register"] = p.Register
	}
	return m
}

func (p DictionaryNamespaceStatistics) Pointer() *DictionaryNamespaceStatistics {
	return &p
}

func CastDictionaryNamespaceStatisticses(data []interface{}) []DictionaryNamespaceStatistics {
	v := make([]DictionaryNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceStatisticsesFromDict(data []DictionaryNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByNameDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *DictionaryNamespaceEntryByNameDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByNameDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByNameDistributionStatistics{}
	} else {
		*p = DictionaryNamespaceEntryByNameDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByNameDistributionStatisticsFromJson(data string) DictionaryNamespaceEntryByNameDistributionStatistics {
	req := DictionaryNamespaceEntryByNameDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByNameDistributionStatisticsFromDict(data map[string]interface{}) DictionaryNamespaceEntryByNameDistributionStatistics {
	return DictionaryNamespaceEntryByNameDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p DictionaryNamespaceEntryByNameDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p DictionaryNamespaceEntryByNameDistributionStatistics) Pointer() *DictionaryNamespaceEntryByNameDistributionStatistics {
	return &p
}

func CastDictionaryNamespaceEntryByNameDistributionStatisticses(data []interface{}) []DictionaryNamespaceEntryByNameDistributionStatistics {
	v := make([]DictionaryNamespaceEntryByNameDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByNameDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByNameDistributionStatisticsesFromDict(data []DictionaryNamespaceEntryByNameDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByNameDistributionSegment struct {
	EntryModelName *string `json:"entryModelName"`
	Count          *int64  `json:"count"`
}

func (p *DictionaryNamespaceEntryByNameDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByNameDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByNameDistributionSegment{}
	} else {
		*p = DictionaryNamespaceEntryByNameDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["entryModelName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.EntryModelName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.EntryModelName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.EntryModelName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.EntryModelName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.EntryModelName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.EntryModelName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByNameDistributionSegmentFromJson(data string) DictionaryNamespaceEntryByNameDistributionSegment {
	req := DictionaryNamespaceEntryByNameDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByNameDistributionSegmentFromDict(data map[string]interface{}) DictionaryNamespaceEntryByNameDistributionSegment {
	return DictionaryNamespaceEntryByNameDistributionSegment{
		EntryModelName: func() *string {
			v, ok := data["entryModelName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["entryModelName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p DictionaryNamespaceEntryByNameDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.EntryModelName != nil {
		m["entryModelName"] = p.EntryModelName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p DictionaryNamespaceEntryByNameDistributionSegment) Pointer() *DictionaryNamespaceEntryByNameDistributionSegment {
	return &p
}

func CastDictionaryNamespaceEntryByNameDistributionSegments(data []interface{}) []DictionaryNamespaceEntryByNameDistributionSegment {
	v := make([]DictionaryNamespaceEntryByNameDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByNameDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByNameDistributionSegmentsFromDict(data []DictionaryNamespaceEntryByNameDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByNameDistribution struct {
	Statistics   *DictionaryNamespaceEntryByNameDistributionStatistics `json:"statistics"`
	Distribution []DictionaryNamespaceEntryByNameDistributionSegment   `json:"distribution"`
}

func (p *DictionaryNamespaceEntryByNameDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByNameDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByNameDistribution{}
	} else {
		*p = DictionaryNamespaceEntryByNameDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByNameDistributionFromJson(data string) DictionaryNamespaceEntryByNameDistribution {
	req := DictionaryNamespaceEntryByNameDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByNameDistributionFromDict(data map[string]interface{}) DictionaryNamespaceEntryByNameDistribution {
	return DictionaryNamespaceEntryByNameDistribution{
		Statistics: func() *DictionaryNamespaceEntryByNameDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewDictionaryNamespaceEntryByNameDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []DictionaryNamespaceEntryByNameDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastDictionaryNamespaceEntryByNameDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p DictionaryNamespaceEntryByNameDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastDictionaryNamespaceEntryByNameDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p DictionaryNamespaceEntryByNameDistribution) Pointer() *DictionaryNamespaceEntryByNameDistribution {
	return &p
}

func CastDictionaryNamespaceEntryByNameDistributions(data []interface{}) []DictionaryNamespaceEntryByNameDistribution {
	v := make([]DictionaryNamespaceEntryByNameDistribution, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByNameDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByNameDistributionsFromDict(data []DictionaryNamespaceEntryByNameDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *DictionaryNamespaceEntryByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByUserDistributionStatistics{}
	} else {
		*p = DictionaryNamespaceEntryByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByUserDistributionStatisticsFromJson(data string) DictionaryNamespaceEntryByUserDistributionStatistics {
	req := DictionaryNamespaceEntryByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByUserDistributionStatisticsFromDict(data map[string]interface{}) DictionaryNamespaceEntryByUserDistributionStatistics {
	return DictionaryNamespaceEntryByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p DictionaryNamespaceEntryByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p DictionaryNamespaceEntryByUserDistributionStatistics) Pointer() *DictionaryNamespaceEntryByUserDistributionStatistics {
	return &p
}

func CastDictionaryNamespaceEntryByUserDistributionStatisticses(data []interface{}) []DictionaryNamespaceEntryByUserDistributionStatistics {
	v := make([]DictionaryNamespaceEntryByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByUserDistributionStatisticsesFromDict(data []DictionaryNamespaceEntryByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *DictionaryNamespaceEntryByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByUserDistributionSegment{}
	} else {
		*p = DictionaryNamespaceEntryByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByUserDistributionSegmentFromJson(data string) DictionaryNamespaceEntryByUserDistributionSegment {
	req := DictionaryNamespaceEntryByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByUserDistributionSegmentFromDict(data map[string]interface{}) DictionaryNamespaceEntryByUserDistributionSegment {
	return DictionaryNamespaceEntryByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p DictionaryNamespaceEntryByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p DictionaryNamespaceEntryByUserDistributionSegment) Pointer() *DictionaryNamespaceEntryByUserDistributionSegment {
	return &p
}

func CastDictionaryNamespaceEntryByUserDistributionSegments(data []interface{}) []DictionaryNamespaceEntryByUserDistributionSegment {
	v := make([]DictionaryNamespaceEntryByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByUserDistributionSegmentsFromDict(data []DictionaryNamespaceEntryByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceEntryByUserDistribution struct {
	Statistics   *DictionaryNamespaceEntryByUserDistributionStatistics `json:"statistics"`
	Distribution []DictionaryNamespaceEntryByUserDistributionSegment   `json:"distribution"`
}

func (p *DictionaryNamespaceEntryByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceEntryByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceEntryByUserDistribution{}
	} else {
		*p = DictionaryNamespaceEntryByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewDictionaryNamespaceEntryByUserDistributionFromJson(data string) DictionaryNamespaceEntryByUserDistribution {
	req := DictionaryNamespaceEntryByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceEntryByUserDistributionFromDict(data map[string]interface{}) DictionaryNamespaceEntryByUserDistribution {
	return DictionaryNamespaceEntryByUserDistribution{
		Statistics: func() *DictionaryNamespaceEntryByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewDictionaryNamespaceEntryByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []DictionaryNamespaceEntryByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastDictionaryNamespaceEntryByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p DictionaryNamespaceEntryByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastDictionaryNamespaceEntryByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p DictionaryNamespaceEntryByUserDistribution) Pointer() *DictionaryNamespaceEntryByUserDistribution {
	return &p
}

func CastDictionaryNamespaceEntryByUserDistributions(data []interface{}) []DictionaryNamespaceEntryByUserDistribution {
	v := make([]DictionaryNamespaceEntryByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceEntryByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceEntryByUserDistributionsFromDict(data []DictionaryNamespaceEntryByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespaceDistributions struct {
	EntryByName *DictionaryNamespaceEntryByNameDistribution `json:"entryByName"`
	EntryByUser *DictionaryNamespaceEntryByUserDistribution `json:"entryByUser"`
}

func (p *DictionaryNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespaceDistributions{}
	} else {
		*p = DictionaryNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["entryByName"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EntryByName)
		}
		if v, ok := d["entryByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EntryByUser)
		}
	}
	return nil
}

func NewDictionaryNamespaceDistributionsFromJson(data string) DictionaryNamespaceDistributions {
	req := DictionaryNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceDistributionsFromDict(data map[string]interface{}) DictionaryNamespaceDistributions {
	return DictionaryNamespaceDistributions{
		EntryByName: func() *DictionaryNamespaceEntryByNameDistribution {
			v, ok := data["entryByName"]
			if !ok || v == nil {
				return nil
			}
			return NewDictionaryNamespaceEntryByNameDistributionFromDict(core.CastMap(data["entryByName"])).Pointer()
		}(),
		EntryByUser: func() *DictionaryNamespaceEntryByUserDistribution {
			v, ok := data["entryByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewDictionaryNamespaceEntryByUserDistributionFromDict(core.CastMap(data["entryByUser"])).Pointer()
		}(),
	}
}

func (p DictionaryNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.EntryByName != nil {
		m["entryByName"] = func() map[string]interface{} {
			if p.EntryByName == nil {
				return nil
			}
			return p.EntryByName.ToDict()
		}()
	}
	if p.EntryByUser != nil {
		m["entryByUser"] = func() map[string]interface{} {
			if p.EntryByUser == nil {
				return nil
			}
			return p.EntryByUser.ToDict()
		}()
	}
	return m
}

func (p DictionaryNamespaceDistributions) Pointer() *DictionaryNamespaceDistributions {
	return &p
}

func CastDictionaryNamespaceDistributionses(data []interface{}) []DictionaryNamespaceDistributions {
	v := make([]DictionaryNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespaceDistributionsesFromDict(data []DictionaryNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryNamespace struct {
	NamespaceId   *string                           `json:"namespaceId"`
	Year          *int32                            `json:"year"`
	Month         *int32                            `json:"month"`
	Day           *int32                            `json:"day"`
	NamespaceName *string                           `json:"namespaceName"`
	Statistics    *DictionaryNamespaceStatistics    `json:"statistics"`
	Distributions *DictionaryNamespaceDistributions `json:"distributions"`
}

func (p *DictionaryNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryNamespace{}
	} else {
		*p = DictionaryNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewDictionaryNamespaceFromJson(data string) DictionaryNamespace {
	req := DictionaryNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryNamespaceFromDict(data map[string]interface{}) DictionaryNamespace {
	return DictionaryNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *DictionaryNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewDictionaryNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *DictionaryNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewDictionaryNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p DictionaryNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p DictionaryNamespace) Pointer() *DictionaryNamespace {
	return &p
}

func CastDictionaryNamespaces(data []interface{}) []DictionaryNamespace {
	v := make([]DictionaryNamespace, 0)
	for _, d := range data {
		v = append(v, NewDictionaryNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryNamespacesFromDict(data []DictionaryNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type DictionaryEntryModel struct {
	EntryModelModelId *string `json:"entryModelModelId"`
	EntryName         *string `json:"entryName"`
}

func (p *DictionaryEntryModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = DictionaryEntryModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = DictionaryEntryModel{}
	} else {
		*p = DictionaryEntryModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["entryModelModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.EntryModelModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.EntryModelModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.EntryModelModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.EntryModelModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.EntryModelModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.EntryModelModelId)
				}
			}
		}
		if v, ok := d["entryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.EntryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.EntryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.EntryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.EntryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.EntryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.EntryName)
				}
			}
		}
	}
	return nil
}

func NewDictionaryEntryModelFromJson(data string) DictionaryEntryModel {
	req := DictionaryEntryModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewDictionaryEntryModelFromDict(data map[string]interface{}) DictionaryEntryModel {
	return DictionaryEntryModel{
		EntryModelModelId: func() *string {
			v, ok := data["entryModelModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["entryModelModelId"])
		}(),
		EntryName: func() *string {
			v, ok := data["entryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["entryName"])
		}(),
	}
}

func (p DictionaryEntryModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.EntryModelModelId != nil {
		m["entryModelModelId"] = p.EntryModelModelId
	}
	if p.EntryName != nil {
		m["entryName"] = p.EntryName
	}
	return m
}

func (p DictionaryEntryModel) Pointer() *DictionaryEntryModel {
	return &p
}

func CastDictionaryEntryModels(data []interface{}) []DictionaryEntryModel {
	v := make([]DictionaryEntryModel, 0)
	for _, d := range data {
		v = append(v, NewDictionaryEntryModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastDictionaryEntryModelsFromDict(data []DictionaryEntryModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModelStatistics struct {
	Exchange *int64 `json:"exchange"`
	Amount   *int64 `json:"amount"`
}

func (p *ExchangeRateModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModelStatistics{}
	} else {
		*p = ExchangeRateModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["exchange"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Exchange)
		}
		if v, ok := d["amount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Amount)
		}
	}
	return nil
}

func NewExchangeRateModelStatisticsFromJson(data string) ExchangeRateModelStatistics {
	req := ExchangeRateModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelStatisticsFromDict(data map[string]interface{}) ExchangeRateModelStatistics {
	return ExchangeRateModelStatistics{
		Exchange: func() *int64 {
			v, ok := data["exchange"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["exchange"])
		}(),
		Amount: func() *int64 {
			v, ok := data["amount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["amount"])
		}(),
	}
}

func (p ExchangeRateModelStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Exchange != nil {
		m["exchange"] = p.Exchange
	}
	if p.Amount != nil {
		m["amount"] = p.Amount
	}
	return m
}

func (p ExchangeRateModelStatistics) Pointer() *ExchangeRateModelStatistics {
	return &p
}

func CastExchangeRateModelStatisticses(data []interface{}) []ExchangeRateModelStatistics {
	v := make([]ExchangeRateModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelStatisticsesFromDict(data []ExchangeRateModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModelAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExchangeRateModelAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModelAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModelAmountDistributionStatistics{}
	} else {
		*p = ExchangeRateModelAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExchangeRateModelAmountDistributionStatisticsFromJson(data string) ExchangeRateModelAmountDistributionStatistics {
	req := ExchangeRateModelAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelAmountDistributionStatisticsFromDict(data map[string]interface{}) ExchangeRateModelAmountDistributionStatistics {
	return ExchangeRateModelAmountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExchangeRateModelAmountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExchangeRateModelAmountDistributionStatistics) Pointer() *ExchangeRateModelAmountDistributionStatistics {
	return &p
}

func CastExchangeRateModelAmountDistributionStatisticses(data []interface{}) []ExchangeRateModelAmountDistributionStatistics {
	v := make([]ExchangeRateModelAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelAmountDistributionStatisticsesFromDict(data []ExchangeRateModelAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModelAmountDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExchangeRateModelAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModelAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModelAmountDistributionSegment{}
	} else {
		*p = ExchangeRateModelAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExchangeRateModelAmountDistributionSegmentFromJson(data string) ExchangeRateModelAmountDistributionSegment {
	req := ExchangeRateModelAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelAmountDistributionSegmentFromDict(data map[string]interface{}) ExchangeRateModelAmountDistributionSegment {
	return ExchangeRateModelAmountDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExchangeRateModelAmountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExchangeRateModelAmountDistributionSegment) Pointer() *ExchangeRateModelAmountDistributionSegment {
	return &p
}

func CastExchangeRateModelAmountDistributionSegments(data []interface{}) []ExchangeRateModelAmountDistributionSegment {
	v := make([]ExchangeRateModelAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelAmountDistributionSegmentsFromDict(data []ExchangeRateModelAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModelAmountDistribution struct {
	Statistics   *ExchangeRateModelAmountDistributionStatistics `json:"statistics"`
	Distribution []ExchangeRateModelAmountDistributionSegment   `json:"distribution"`
}

func (p *ExchangeRateModelAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModelAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModelAmountDistribution{}
	} else {
		*p = ExchangeRateModelAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExchangeRateModelAmountDistributionFromJson(data string) ExchangeRateModelAmountDistribution {
	req := ExchangeRateModelAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelAmountDistributionFromDict(data map[string]interface{}) ExchangeRateModelAmountDistribution {
	return ExchangeRateModelAmountDistribution{
		Statistics: func() *ExchangeRateModelAmountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeRateModelAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExchangeRateModelAmountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExchangeRateModelAmountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExchangeRateModelAmountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExchangeRateModelAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExchangeRateModelAmountDistribution) Pointer() *ExchangeRateModelAmountDistribution {
	return &p
}

func CastExchangeRateModelAmountDistributions(data []interface{}) []ExchangeRateModelAmountDistribution {
	v := make([]ExchangeRateModelAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelAmountDistributionsFromDict(data []ExchangeRateModelAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModelDistributions struct {
	Amount *ExchangeRateModelAmountDistribution `json:"amount"`
}

func (p *ExchangeRateModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModelDistributions{}
	} else {
		*p = ExchangeRateModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["amount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Amount)
		}
	}
	return nil
}

func NewExchangeRateModelDistributionsFromJson(data string) ExchangeRateModelDistributions {
	req := ExchangeRateModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelDistributionsFromDict(data map[string]interface{}) ExchangeRateModelDistributions {
	return ExchangeRateModelDistributions{
		Amount: func() *ExchangeRateModelAmountDistribution {
			v, ok := data["amount"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeRateModelAmountDistributionFromDict(core.CastMap(data["amount"])).Pointer()
		}(),
	}
}

func (p ExchangeRateModelDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Amount != nil {
		m["amount"] = func() map[string]interface{} {
			if p.Amount == nil {
				return nil
			}
			return p.Amount.ToDict()
		}()
	}
	return m
}

func (p ExchangeRateModelDistributions) Pointer() *ExchangeRateModelDistributions {
	return &p
}

func CastExchangeRateModelDistributionses(data []interface{}) []ExchangeRateModelDistributions {
	v := make([]ExchangeRateModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelDistributionsesFromDict(data []ExchangeRateModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeRateModel struct {
	RateModelId   *string                         `json:"rateModelId"`
	RateName      *string                         `json:"rateName"`
	Statistics    *ExchangeRateModelStatistics    `json:"statistics"`
	Distributions *ExchangeRateModelDistributions `json:"distributions"`
}

func (p *ExchangeRateModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeRateModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeRateModel{}
	} else {
		*p = ExchangeRateModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["rateModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.RateModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.RateModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.RateModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.RateModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.RateModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.RateModelId)
				}
			}
		}
		if v, ok := d["rateName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.RateName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.RateName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.RateName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.RateName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewExchangeRateModelFromJson(data string) ExchangeRateModel {
	req := ExchangeRateModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeRateModelFromDict(data map[string]interface{}) ExchangeRateModel {
	return ExchangeRateModel{
		RateModelId: func() *string {
			v, ok := data["rateModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["rateModelId"])
		}(),
		RateName: func() *string {
			v, ok := data["rateName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["rateName"])
		}(),
		Statistics: func() *ExchangeRateModelStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeRateModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *ExchangeRateModelDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeRateModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p ExchangeRateModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.RateModelId != nil {
		m["rateModelId"] = p.RateModelId
	}
	if p.RateName != nil {
		m["rateName"] = p.RateName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p ExchangeRateModel) Pointer() *ExchangeRateModel {
	return &p
}

func CastExchangeRateModels(data []interface{}) []ExchangeRateModel {
	v := make([]ExchangeRateModel, 0)
	for _, d := range data {
		v = append(v, NewExchangeRateModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeRateModelsFromDict(data []ExchangeRateModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceStatistics struct {
	Exchange *int64 `json:"exchange"`
	Amount   *int64 `json:"amount"`
}

func (p *ExchangeNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceStatistics{}
	} else {
		*p = ExchangeNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["exchange"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Exchange)
		}
		if v, ok := d["amount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Amount)
		}
	}
	return nil
}

func NewExchangeNamespaceStatisticsFromJson(data string) ExchangeNamespaceStatistics {
	req := ExchangeNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceStatisticsFromDict(data map[string]interface{}) ExchangeNamespaceStatistics {
	return ExchangeNamespaceStatistics{
		Exchange: func() *int64 {
			v, ok := data["exchange"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["exchange"])
		}(),
		Amount: func() *int64 {
			v, ok := data["amount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["amount"])
		}(),
	}
}

func (p ExchangeNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Exchange != nil {
		m["exchange"] = p.Exchange
	}
	if p.Amount != nil {
		m["amount"] = p.Amount
	}
	return m
}

func (p ExchangeNamespaceStatistics) Pointer() *ExchangeNamespaceStatistics {
	return &p
}

func CastExchangeNamespaceStatisticses(data []interface{}) []ExchangeNamespaceStatistics {
	v := make([]ExchangeNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceStatisticsesFromDict(data []ExchangeNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExchangeNamespaceExchangeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeDistributionStatistics{}
	} else {
		*p = ExchangeNamespaceExchangeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeDistributionStatisticsFromJson(data string) ExchangeNamespaceExchangeDistributionStatistics {
	req := ExchangeNamespaceExchangeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeDistributionStatisticsFromDict(data map[string]interface{}) ExchangeNamespaceExchangeDistributionStatistics {
	return ExchangeNamespaceExchangeDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExchangeNamespaceExchangeDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExchangeNamespaceExchangeDistributionStatistics) Pointer() *ExchangeNamespaceExchangeDistributionStatistics {
	return &p
}

func CastExchangeNamespaceExchangeDistributionStatisticses(data []interface{}) []ExchangeNamespaceExchangeDistributionStatistics {
	v := make([]ExchangeNamespaceExchangeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeDistributionStatisticsesFromDict(data []ExchangeNamespaceExchangeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeDistributionSegment struct {
	RateName *string `json:"rateName"`
	Count    *int64  `json:"count"`
}

func (p *ExchangeNamespaceExchangeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeDistributionSegment{}
	} else {
		*p = ExchangeNamespaceExchangeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["rateName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.RateName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.RateName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.RateName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.RateName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeDistributionSegmentFromJson(data string) ExchangeNamespaceExchangeDistributionSegment {
	req := ExchangeNamespaceExchangeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeDistributionSegmentFromDict(data map[string]interface{}) ExchangeNamespaceExchangeDistributionSegment {
	return ExchangeNamespaceExchangeDistributionSegment{
		RateName: func() *string {
			v, ok := data["rateName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["rateName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExchangeNamespaceExchangeDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.RateName != nil {
		m["rateName"] = p.RateName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExchangeNamespaceExchangeDistributionSegment) Pointer() *ExchangeNamespaceExchangeDistributionSegment {
	return &p
}

func CastExchangeNamespaceExchangeDistributionSegments(data []interface{}) []ExchangeNamespaceExchangeDistributionSegment {
	v := make([]ExchangeNamespaceExchangeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeDistributionSegmentsFromDict(data []ExchangeNamespaceExchangeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeDistribution struct {
	Statistics   *ExchangeNamespaceExchangeDistributionStatistics `json:"statistics"`
	Distribution []ExchangeNamespaceExchangeDistributionSegment   `json:"distribution"`
}

func (p *ExchangeNamespaceExchangeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeDistribution{}
	} else {
		*p = ExchangeNamespaceExchangeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeDistributionFromJson(data string) ExchangeNamespaceExchangeDistribution {
	req := ExchangeNamespaceExchangeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeDistributionFromDict(data map[string]interface{}) ExchangeNamespaceExchangeDistribution {
	return ExchangeNamespaceExchangeDistribution{
		Statistics: func() *ExchangeNamespaceExchangeDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeNamespaceExchangeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExchangeNamespaceExchangeDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExchangeNamespaceExchangeDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExchangeNamespaceExchangeDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExchangeNamespaceExchangeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExchangeNamespaceExchangeDistribution) Pointer() *ExchangeNamespaceExchangeDistribution {
	return &p
}

func CastExchangeNamespaceExchangeDistributions(data []interface{}) []ExchangeNamespaceExchangeDistribution {
	v := make([]ExchangeNamespaceExchangeDistribution, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeDistributionsFromDict(data []ExchangeNamespaceExchangeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExchangeNamespaceExchangeAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountDistributionStatistics{}
	} else {
		*p = ExchangeNamespaceExchangeAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountDistributionStatisticsFromJson(data string) ExchangeNamespaceExchangeAmountDistributionStatistics {
	req := ExchangeNamespaceExchangeAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountDistributionStatisticsFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountDistributionStatistics {
	return ExchangeNamespaceExchangeAmountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExchangeNamespaceExchangeAmountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExchangeNamespaceExchangeAmountDistributionStatistics) Pointer() *ExchangeNamespaceExchangeAmountDistributionStatistics {
	return &p
}

func CastExchangeNamespaceExchangeAmountDistributionStatisticses(data []interface{}) []ExchangeNamespaceExchangeAmountDistributionStatistics {
	v := make([]ExchangeNamespaceExchangeAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountDistributionStatisticsesFromDict(data []ExchangeNamespaceExchangeAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountDistributionSegment struct {
	RateName *string `json:"rateName"`
	Sum      *int64  `json:"sum"`
}

func (p *ExchangeNamespaceExchangeAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountDistributionSegment{}
	} else {
		*p = ExchangeNamespaceExchangeAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["rateName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.RateName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.RateName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.RateName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.RateName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.RateName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountDistributionSegmentFromJson(data string) ExchangeNamespaceExchangeAmountDistributionSegment {
	req := ExchangeNamespaceExchangeAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountDistributionSegmentFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountDistributionSegment {
	return ExchangeNamespaceExchangeAmountDistributionSegment{
		RateName: func() *string {
			v, ok := data["rateName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["rateName"])
		}(),
		Sum: func() *int64 {
			v, ok := data["sum"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sum"])
		}(),
	}
}

func (p ExchangeNamespaceExchangeAmountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.RateName != nil {
		m["rateName"] = p.RateName
	}
	if p.Sum != nil {
		m["sum"] = p.Sum
	}
	return m
}

func (p ExchangeNamespaceExchangeAmountDistributionSegment) Pointer() *ExchangeNamespaceExchangeAmountDistributionSegment {
	return &p
}

func CastExchangeNamespaceExchangeAmountDistributionSegments(data []interface{}) []ExchangeNamespaceExchangeAmountDistributionSegment {
	v := make([]ExchangeNamespaceExchangeAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountDistributionSegmentsFromDict(data []ExchangeNamespaceExchangeAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountDistribution struct {
	Statistics   *ExchangeNamespaceExchangeAmountDistributionStatistics `json:"statistics"`
	Distribution []ExchangeNamespaceExchangeAmountDistributionSegment   `json:"distribution"`
}

func (p *ExchangeNamespaceExchangeAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountDistribution{}
	} else {
		*p = ExchangeNamespaceExchangeAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountDistributionFromJson(data string) ExchangeNamespaceExchangeAmountDistribution {
	req := ExchangeNamespaceExchangeAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountDistributionFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountDistribution {
	return ExchangeNamespaceExchangeAmountDistribution{
		Statistics: func() *ExchangeNamespaceExchangeAmountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeNamespaceExchangeAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExchangeNamespaceExchangeAmountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExchangeNamespaceExchangeAmountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExchangeNamespaceExchangeAmountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExchangeNamespaceExchangeAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExchangeNamespaceExchangeAmountDistribution) Pointer() *ExchangeNamespaceExchangeAmountDistribution {
	return &p
}

func CastExchangeNamespaceExchangeAmountDistributions(data []interface{}) []ExchangeNamespaceExchangeAmountDistribution {
	v := make([]ExchangeNamespaceExchangeAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountDistributionsFromDict(data []ExchangeNamespaceExchangeAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExchangeNamespaceExchangeByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeByUserDistributionStatistics{}
	} else {
		*p = ExchangeNamespaceExchangeByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeByUserDistributionStatisticsFromJson(data string) ExchangeNamespaceExchangeByUserDistributionStatistics {
	req := ExchangeNamespaceExchangeByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeByUserDistributionStatisticsFromDict(data map[string]interface{}) ExchangeNamespaceExchangeByUserDistributionStatistics {
	return ExchangeNamespaceExchangeByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExchangeNamespaceExchangeByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExchangeNamespaceExchangeByUserDistributionStatistics) Pointer() *ExchangeNamespaceExchangeByUserDistributionStatistics {
	return &p
}

func CastExchangeNamespaceExchangeByUserDistributionStatisticses(data []interface{}) []ExchangeNamespaceExchangeByUserDistributionStatistics {
	v := make([]ExchangeNamespaceExchangeByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeByUserDistributionStatisticsesFromDict(data []ExchangeNamespaceExchangeByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExchangeNamespaceExchangeByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeByUserDistributionSegment{}
	} else {
		*p = ExchangeNamespaceExchangeByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeByUserDistributionSegmentFromJson(data string) ExchangeNamespaceExchangeByUserDistributionSegment {
	req := ExchangeNamespaceExchangeByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeByUserDistributionSegmentFromDict(data map[string]interface{}) ExchangeNamespaceExchangeByUserDistributionSegment {
	return ExchangeNamespaceExchangeByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExchangeNamespaceExchangeByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExchangeNamespaceExchangeByUserDistributionSegment) Pointer() *ExchangeNamespaceExchangeByUserDistributionSegment {
	return &p
}

func CastExchangeNamespaceExchangeByUserDistributionSegments(data []interface{}) []ExchangeNamespaceExchangeByUserDistributionSegment {
	v := make([]ExchangeNamespaceExchangeByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeByUserDistributionSegmentsFromDict(data []ExchangeNamespaceExchangeByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeByUserDistribution struct {
	Statistics   *ExchangeNamespaceExchangeByUserDistributionStatistics `json:"statistics"`
	Distribution []ExchangeNamespaceExchangeByUserDistributionSegment   `json:"distribution"`
}

func (p *ExchangeNamespaceExchangeByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeByUserDistribution{}
	} else {
		*p = ExchangeNamespaceExchangeByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeByUserDistributionFromJson(data string) ExchangeNamespaceExchangeByUserDistribution {
	req := ExchangeNamespaceExchangeByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeByUserDistributionFromDict(data map[string]interface{}) ExchangeNamespaceExchangeByUserDistribution {
	return ExchangeNamespaceExchangeByUserDistribution{
		Statistics: func() *ExchangeNamespaceExchangeByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeNamespaceExchangeByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExchangeNamespaceExchangeByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExchangeNamespaceExchangeByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExchangeNamespaceExchangeByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExchangeNamespaceExchangeByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExchangeNamespaceExchangeByUserDistribution) Pointer() *ExchangeNamespaceExchangeByUserDistribution {
	return &p
}

func CastExchangeNamespaceExchangeByUserDistributions(data []interface{}) []ExchangeNamespaceExchangeByUserDistribution {
	v := make([]ExchangeNamespaceExchangeByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeByUserDistributionsFromDict(data []ExchangeNamespaceExchangeByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExchangeNamespaceExchangeAmountByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionStatistics{}
	} else {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountByUserDistributionStatisticsFromJson(data string) ExchangeNamespaceExchangeAmountByUserDistributionStatistics {
	req := ExchangeNamespaceExchangeAmountByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountByUserDistributionStatisticsFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountByUserDistributionStatistics {
	return ExchangeNamespaceExchangeAmountByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExchangeNamespaceExchangeAmountByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExchangeNamespaceExchangeAmountByUserDistributionStatistics) Pointer() *ExchangeNamespaceExchangeAmountByUserDistributionStatistics {
	return &p
}

func CastExchangeNamespaceExchangeAmountByUserDistributionStatisticses(data []interface{}) []ExchangeNamespaceExchangeAmountByUserDistributionStatistics {
	v := make([]ExchangeNamespaceExchangeAmountByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountByUserDistributionStatisticsesFromDict(data []ExchangeNamespaceExchangeAmountByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExchangeNamespaceExchangeAmountByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionSegment{}
	} else {
		*p = ExchangeNamespaceExchangeAmountByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountByUserDistributionSegmentFromJson(data string) ExchangeNamespaceExchangeAmountByUserDistributionSegment {
	req := ExchangeNamespaceExchangeAmountByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountByUserDistributionSegmentFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountByUserDistributionSegment {
	return ExchangeNamespaceExchangeAmountByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExchangeNamespaceExchangeAmountByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExchangeNamespaceExchangeAmountByUserDistributionSegment) Pointer() *ExchangeNamespaceExchangeAmountByUserDistributionSegment {
	return &p
}

func CastExchangeNamespaceExchangeAmountByUserDistributionSegments(data []interface{}) []ExchangeNamespaceExchangeAmountByUserDistributionSegment {
	v := make([]ExchangeNamespaceExchangeAmountByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountByUserDistributionSegmentsFromDict(data []ExchangeNamespaceExchangeAmountByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceExchangeAmountByUserDistribution struct {
	Statistics   *ExchangeNamespaceExchangeAmountByUserDistributionStatistics `json:"statistics"`
	Distribution []ExchangeNamespaceExchangeAmountByUserDistributionSegment   `json:"distribution"`
}

func (p *ExchangeNamespaceExchangeAmountByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceExchangeAmountByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceExchangeAmountByUserDistribution{}
	} else {
		*p = ExchangeNamespaceExchangeAmountByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExchangeNamespaceExchangeAmountByUserDistributionFromJson(data string) ExchangeNamespaceExchangeAmountByUserDistribution {
	req := ExchangeNamespaceExchangeAmountByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceExchangeAmountByUserDistributionFromDict(data map[string]interface{}) ExchangeNamespaceExchangeAmountByUserDistribution {
	return ExchangeNamespaceExchangeAmountByUserDistribution{
		Statistics: func() *ExchangeNamespaceExchangeAmountByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeNamespaceExchangeAmountByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExchangeNamespaceExchangeAmountByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExchangeNamespaceExchangeAmountByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExchangeNamespaceExchangeAmountByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExchangeNamespaceExchangeAmountByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExchangeNamespaceExchangeAmountByUserDistribution) Pointer() *ExchangeNamespaceExchangeAmountByUserDistribution {
	return &p
}

func CastExchangeNamespaceExchangeAmountByUserDistributions(data []interface{}) []ExchangeNamespaceExchangeAmountByUserDistribution {
	v := make([]ExchangeNamespaceExchangeAmountByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceExchangeAmountByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceExchangeAmountByUserDistributionsFromDict(data []ExchangeNamespaceExchangeAmountByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespaceDistributions struct {
	Exchange             *ExchangeNamespaceExchangeDistribution             `json:"exchange"`
	ExchangeAmount       *ExchangeNamespaceExchangeAmountDistribution       `json:"exchangeAmount"`
	ExchangeByUser       *ExchangeNamespaceExchangeByUserDistribution       `json:"exchangeByUser"`
	ExchangeAmountByUser *ExchangeNamespaceExchangeAmountByUserDistribution `json:"exchangeAmountByUser"`
}

func (p *ExchangeNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespaceDistributions{}
	} else {
		*p = ExchangeNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["exchange"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Exchange)
		}
		if v, ok := d["exchangeAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExchangeAmount)
		}
		if v, ok := d["exchangeByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExchangeByUser)
		}
		if v, ok := d["exchangeAmountByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExchangeAmountByUser)
		}
	}
	return nil
}

func NewExchangeNamespaceDistributionsFromJson(data string) ExchangeNamespaceDistributions {
	req := ExchangeNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceDistributionsFromDict(data map[string]interface{}) ExchangeNamespaceDistributions {
	return ExchangeNamespaceDistributions{
		Exchange: func() *ExchangeNamespaceExchangeDistribution {
			v, ok := data["exchange"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeNamespaceExchangeDistributionFromDict(core.CastMap(data["exchange"])).Pointer()
		}(),
		ExchangeAmount: func() *ExchangeNamespaceExchangeAmountDistribution {
			v, ok := data["exchangeAmount"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeNamespaceExchangeAmountDistributionFromDict(core.CastMap(data["exchangeAmount"])).Pointer()
		}(),
		ExchangeByUser: func() *ExchangeNamespaceExchangeByUserDistribution {
			v, ok := data["exchangeByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeNamespaceExchangeByUserDistributionFromDict(core.CastMap(data["exchangeByUser"])).Pointer()
		}(),
		ExchangeAmountByUser: func() *ExchangeNamespaceExchangeAmountByUserDistribution {
			v, ok := data["exchangeAmountByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeNamespaceExchangeAmountByUserDistributionFromDict(core.CastMap(data["exchangeAmountByUser"])).Pointer()
		}(),
	}
}

func (p ExchangeNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Exchange != nil {
		m["exchange"] = func() map[string]interface{} {
			if p.Exchange == nil {
				return nil
			}
			return p.Exchange.ToDict()
		}()
	}
	if p.ExchangeAmount != nil {
		m["exchangeAmount"] = func() map[string]interface{} {
			if p.ExchangeAmount == nil {
				return nil
			}
			return p.ExchangeAmount.ToDict()
		}()
	}
	if p.ExchangeByUser != nil {
		m["exchangeByUser"] = func() map[string]interface{} {
			if p.ExchangeByUser == nil {
				return nil
			}
			return p.ExchangeByUser.ToDict()
		}()
	}
	if p.ExchangeAmountByUser != nil {
		m["exchangeAmountByUser"] = func() map[string]interface{} {
			if p.ExchangeAmountByUser == nil {
				return nil
			}
			return p.ExchangeAmountByUser.ToDict()
		}()
	}
	return m
}

func (p ExchangeNamespaceDistributions) Pointer() *ExchangeNamespaceDistributions {
	return &p
}

func CastExchangeNamespaceDistributionses(data []interface{}) []ExchangeNamespaceDistributions {
	v := make([]ExchangeNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespaceDistributionsesFromDict(data []ExchangeNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExchangeNamespace struct {
	NamespaceId   *string                         `json:"namespaceId"`
	Year          *int32                          `json:"year"`
	Month         *int32                          `json:"month"`
	Day           *int32                          `json:"day"`
	NamespaceName *string                         `json:"namespaceName"`
	Statistics    *ExchangeNamespaceStatistics    `json:"statistics"`
	Distributions *ExchangeNamespaceDistributions `json:"distributions"`
	RateModels    []ExchangeRateModel             `json:"rateModels"`
}

func (p *ExchangeNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExchangeNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExchangeNamespace{}
	} else {
		*p = ExchangeNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["rateModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RateModels)
		}
	}
	return nil
}

func NewExchangeNamespaceFromJson(data string) ExchangeNamespace {
	req := ExchangeNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExchangeNamespaceFromDict(data map[string]interface{}) ExchangeNamespace {
	return ExchangeNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *ExchangeNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *ExchangeNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewExchangeNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		RateModels: func() []ExchangeRateModel {
			if data["rateModels"] == nil {
				return nil
			}
			return CastExchangeRateModels(core.CastArray(data["rateModels"]))
		}(),
	}
}

func (p ExchangeNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.RateModels != nil {
		m["rateModels"] = CastExchangeRateModelsFromDict(
			p.RateModels,
		)
	}
	return m
}

func (p ExchangeNamespace) Pointer() *ExchangeNamespace {
	return &p
}

func CastExchangeNamespaces(data []interface{}) []ExchangeNamespace {
	v := make([]ExchangeNamespace, 0)
	for _, d := range data {
		v = append(v, NewExchangeNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExchangeNamespacesFromDict(data []ExchangeNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceStatusRankDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankDistributionStatistics{}
	} else {
		*p = ExperienceStatusRankDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceStatusRankDistributionStatisticsFromJson(data string) ExperienceStatusRankDistributionStatistics {
	req := ExperienceStatusRankDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankDistributionStatisticsFromDict(data map[string]interface{}) ExperienceStatusRankDistributionStatistics {
	return ExperienceStatusRankDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExperienceStatusRankDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExperienceStatusRankDistributionStatistics) Pointer() *ExperienceStatusRankDistributionStatistics {
	return &p
}

func CastExperienceStatusRankDistributionStatisticses(data []interface{}) []ExperienceStatusRankDistributionStatistics {
	v := make([]ExperienceStatusRankDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankDistributionStatisticsesFromDict(data []ExperienceStatusRankDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceStatusRankDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankDistributionSegment{}
	} else {
		*p = ExperienceStatusRankDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceStatusRankDistributionSegmentFromJson(data string) ExperienceStatusRankDistributionSegment {
	req := ExperienceStatusRankDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankDistributionSegmentFromDict(data map[string]interface{}) ExperienceStatusRankDistributionSegment {
	return ExperienceStatusRankDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExperienceStatusRankDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExperienceStatusRankDistributionSegment) Pointer() *ExperienceStatusRankDistributionSegment {
	return &p
}

func CastExperienceStatusRankDistributionSegments(data []interface{}) []ExperienceStatusRankDistributionSegment {
	v := make([]ExperienceStatusRankDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankDistributionSegmentsFromDict(data []ExperienceStatusRankDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankDistribution struct {
	Statistics   *ExperienceStatusRankDistributionStatistics `json:"statistics"`
	Distribution []ExperienceStatusRankDistributionSegment   `json:"distribution"`
}

func (p *ExperienceStatusRankDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankDistribution{}
	} else {
		*p = ExperienceStatusRankDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceStatusRankDistributionFromJson(data string) ExperienceStatusRankDistribution {
	req := ExperienceStatusRankDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankDistributionFromDict(data map[string]interface{}) ExperienceStatusRankDistribution {
	return ExperienceStatusRankDistribution{
		Statistics: func() *ExperienceStatusRankDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceStatusRankDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExperienceStatusRankDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExperienceStatusRankDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExperienceStatusRankDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExperienceStatusRankDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExperienceStatusRankDistribution) Pointer() *ExperienceStatusRankDistribution {
	return &p
}

func CastExperienceStatusRankDistributions(data []interface{}) []ExperienceStatusRankDistribution {
	v := make([]ExperienceStatusRankDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankDistributionsFromDict(data []ExperienceStatusRankDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankCapDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceStatusRankCapDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankCapDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankCapDistributionStatistics{}
	} else {
		*p = ExperienceStatusRankCapDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceStatusRankCapDistributionStatisticsFromJson(data string) ExperienceStatusRankCapDistributionStatistics {
	req := ExperienceStatusRankCapDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankCapDistributionStatisticsFromDict(data map[string]interface{}) ExperienceStatusRankCapDistributionStatistics {
	return ExperienceStatusRankCapDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExperienceStatusRankCapDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExperienceStatusRankCapDistributionStatistics) Pointer() *ExperienceStatusRankCapDistributionStatistics {
	return &p
}

func CastExperienceStatusRankCapDistributionStatisticses(data []interface{}) []ExperienceStatusRankCapDistributionStatistics {
	v := make([]ExperienceStatusRankCapDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankCapDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankCapDistributionStatisticsesFromDict(data []ExperienceStatusRankCapDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankCapDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceStatusRankCapDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankCapDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankCapDistributionSegment{}
	} else {
		*p = ExperienceStatusRankCapDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceStatusRankCapDistributionSegmentFromJson(data string) ExperienceStatusRankCapDistributionSegment {
	req := ExperienceStatusRankCapDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankCapDistributionSegmentFromDict(data map[string]interface{}) ExperienceStatusRankCapDistributionSegment {
	return ExperienceStatusRankCapDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExperienceStatusRankCapDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExperienceStatusRankCapDistributionSegment) Pointer() *ExperienceStatusRankCapDistributionSegment {
	return &p
}

func CastExperienceStatusRankCapDistributionSegments(data []interface{}) []ExperienceStatusRankCapDistributionSegment {
	v := make([]ExperienceStatusRankCapDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankCapDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankCapDistributionSegmentsFromDict(data []ExperienceStatusRankCapDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusRankCapDistribution struct {
	Statistics   *ExperienceStatusRankCapDistributionStatistics `json:"statistics"`
	Distribution []ExperienceStatusRankCapDistributionSegment   `json:"distribution"`
}

func (p *ExperienceStatusRankCapDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusRankCapDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusRankCapDistribution{}
	} else {
		*p = ExperienceStatusRankCapDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceStatusRankCapDistributionFromJson(data string) ExperienceStatusRankCapDistribution {
	req := ExperienceStatusRankCapDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusRankCapDistributionFromDict(data map[string]interface{}) ExperienceStatusRankCapDistribution {
	return ExperienceStatusRankCapDistribution{
		Statistics: func() *ExperienceStatusRankCapDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceStatusRankCapDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExperienceStatusRankCapDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExperienceStatusRankCapDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExperienceStatusRankCapDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExperienceStatusRankCapDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExperienceStatusRankCapDistribution) Pointer() *ExperienceStatusRankCapDistribution {
	return &p
}

func CastExperienceStatusRankCapDistributions(data []interface{}) []ExperienceStatusRankCapDistribution {
	v := make([]ExperienceStatusRankCapDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusRankCapDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusRankCapDistributionsFromDict(data []ExperienceStatusRankCapDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatusDistributions struct {
	Rank    *ExperienceStatusRankDistribution    `json:"rank"`
	RankCap *ExperienceStatusRankCapDistribution `json:"rankCap"`
}

func (p *ExperienceStatusDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatusDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatusDistributions{}
	} else {
		*p = ExperienceStatusDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["rank"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Rank)
		}
		if v, ok := d["rankCap"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RankCap)
		}
	}
	return nil
}

func NewExperienceStatusDistributionsFromJson(data string) ExperienceStatusDistributions {
	req := ExperienceStatusDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusDistributionsFromDict(data map[string]interface{}) ExperienceStatusDistributions {
	return ExperienceStatusDistributions{
		Rank: func() *ExperienceStatusRankDistribution {
			v, ok := data["rank"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceStatusRankDistributionFromDict(core.CastMap(data["rank"])).Pointer()
		}(),
		RankCap: func() *ExperienceStatusRankCapDistribution {
			v, ok := data["rankCap"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceStatusRankCapDistributionFromDict(core.CastMap(data["rankCap"])).Pointer()
		}(),
	}
}

func (p ExperienceStatusDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Rank != nil {
		m["rank"] = func() map[string]interface{} {
			if p.Rank == nil {
				return nil
			}
			return p.Rank.ToDict()
		}()
	}
	if p.RankCap != nil {
		m["rankCap"] = func() map[string]interface{} {
			if p.RankCap == nil {
				return nil
			}
			return p.RankCap.ToDict()
		}()
	}
	return m
}

func (p ExperienceStatusDistributions) Pointer() *ExperienceStatusDistributions {
	return &p
}

func CastExperienceStatusDistributionses(data []interface{}) []ExperienceStatusDistributions {
	v := make([]ExperienceStatusDistributions, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusDistributionsesFromDict(data []ExperienceStatusDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceStatus struct {
	StatusId       *string                        `json:"statusId"`
	ExperienceName *string                        `json:"experienceName"`
	PropertyId     *string                        `json:"propertyId"`
	Distributions  *ExperienceStatusDistributions `json:"distributions"`
}

func (p *ExperienceStatus) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceStatus{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceStatus{}
	} else {
		*p = ExperienceStatus{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statusId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.StatusId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.StatusId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.StatusId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.StatusId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.StatusId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.StatusId)
				}
			}
		}
		if v, ok := d["experienceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ExperienceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ExperienceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ExperienceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ExperienceName)
				}
			}
		}
		if v, ok := d["propertyId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.PropertyId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.PropertyId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.PropertyId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.PropertyId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.PropertyId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.PropertyId)
				}
			}
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewExperienceStatusFromJson(data string) ExperienceStatus {
	req := ExperienceStatus{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceStatusFromDict(data map[string]interface{}) ExperienceStatus {
	return ExperienceStatus{
		StatusId: func() *string {
			v, ok := data["statusId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["statusId"])
		}(),
		ExperienceName: func() *string {
			v, ok := data["experienceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["experienceName"])
		}(),
		PropertyId: func() *string {
			v, ok := data["propertyId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["propertyId"])
		}(),
		Distributions: func() *ExperienceStatusDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceStatusDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p ExperienceStatus) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.StatusId != nil {
		m["statusId"] = p.StatusId
	}
	if p.ExperienceName != nil {
		m["experienceName"] = p.ExperienceName
	}
	if p.PropertyId != nil {
		m["propertyId"] = p.PropertyId
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p ExperienceStatus) Pointer() *ExperienceStatus {
	return &p
}

func CastExperienceStatuses(data []interface{}) []ExperienceStatus {
	v := make([]ExperienceStatus, 0)
	for _, d := range data {
		v = append(v, NewExperienceStatusFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceStatusesFromDict(data []ExperienceStatus) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelStatistics struct {
	Experience       *int64 `json:"experience"`
	ExperienceAmount *int64 `json:"experienceAmount"`
	RankCap          *int64 `json:"rankCap"`
	RankCapAmount    *int64 `json:"rankCapAmount"`
}

func (p *ExperienceExperienceModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelStatistics{}
	} else {
		*p = ExperienceExperienceModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["experience"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Experience)
		}
		if v, ok := d["experienceAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExperienceAmount)
		}
		if v, ok := d["rankCap"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RankCap)
		}
		if v, ok := d["rankCapAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RankCapAmount)
		}
	}
	return nil
}

func NewExperienceExperienceModelStatisticsFromJson(data string) ExperienceExperienceModelStatistics {
	req := ExperienceExperienceModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelStatisticsFromDict(data map[string]interface{}) ExperienceExperienceModelStatistics {
	return ExperienceExperienceModelStatistics{
		Experience: func() *int64 {
			v, ok := data["experience"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["experience"])
		}(),
		ExperienceAmount: func() *int64 {
			v, ok := data["experienceAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["experienceAmount"])
		}(),
		RankCap: func() *int64 {
			v, ok := data["rankCap"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["rankCap"])
		}(),
		RankCapAmount: func() *int64 {
			v, ok := data["rankCapAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["rankCapAmount"])
		}(),
	}
}

func (p ExperienceExperienceModelStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Experience != nil {
		m["experience"] = p.Experience
	}
	if p.ExperienceAmount != nil {
		m["experienceAmount"] = p.ExperienceAmount
	}
	if p.RankCap != nil {
		m["rankCap"] = p.RankCap
	}
	if p.RankCapAmount != nil {
		m["rankCapAmount"] = p.RankCapAmount
	}
	return m
}

func (p ExperienceExperienceModelStatistics) Pointer() *ExperienceExperienceModelStatistics {
	return &p
}

func CastExperienceExperienceModelStatisticses(data []interface{}) []ExperienceExperienceModelStatistics {
	v := make([]ExperienceExperienceModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelStatisticsesFromDict(data []ExperienceExperienceModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceExperienceModelAddExperienceByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionStatistics{}
	} else {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceByUserDistributionStatisticsFromJson(data string) ExperienceExperienceModelAddExperienceByUserDistributionStatistics {
	req := ExperienceExperienceModelAddExperienceByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceByUserDistributionStatisticsFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceByUserDistributionStatistics {
	return ExperienceExperienceModelAddExperienceByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExperienceExperienceModelAddExperienceByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExperienceExperienceModelAddExperienceByUserDistributionStatistics) Pointer() *ExperienceExperienceModelAddExperienceByUserDistributionStatistics {
	return &p
}

func CastExperienceExperienceModelAddExperienceByUserDistributionStatisticses(data []interface{}) []ExperienceExperienceModelAddExperienceByUserDistributionStatistics {
	v := make([]ExperienceExperienceModelAddExperienceByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceByUserDistributionStatisticsesFromDict(data []ExperienceExperienceModelAddExperienceByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceExperienceModelAddExperienceByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionSegment{}
	} else {
		*p = ExperienceExperienceModelAddExperienceByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceByUserDistributionSegmentFromJson(data string) ExperienceExperienceModelAddExperienceByUserDistributionSegment {
	req := ExperienceExperienceModelAddExperienceByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceByUserDistributionSegmentFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceByUserDistributionSegment {
	return ExperienceExperienceModelAddExperienceByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExperienceExperienceModelAddExperienceByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExperienceExperienceModelAddExperienceByUserDistributionSegment) Pointer() *ExperienceExperienceModelAddExperienceByUserDistributionSegment {
	return &p
}

func CastExperienceExperienceModelAddExperienceByUserDistributionSegments(data []interface{}) []ExperienceExperienceModelAddExperienceByUserDistributionSegment {
	v := make([]ExperienceExperienceModelAddExperienceByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceByUserDistributionSegmentsFromDict(data []ExperienceExperienceModelAddExperienceByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceByUserDistribution struct {
	Statistics   *ExperienceExperienceModelAddExperienceByUserDistributionStatistics `json:"statistics"`
	Distribution []ExperienceExperienceModelAddExperienceByUserDistributionSegment   `json:"distribution"`
}

func (p *ExperienceExperienceModelAddExperienceByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceByUserDistribution{}
	} else {
		*p = ExperienceExperienceModelAddExperienceByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceByUserDistributionFromJson(data string) ExperienceExperienceModelAddExperienceByUserDistribution {
	req := ExperienceExperienceModelAddExperienceByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceByUserDistributionFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceByUserDistribution {
	return ExperienceExperienceModelAddExperienceByUserDistribution{
		Statistics: func() *ExperienceExperienceModelAddExperienceByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceExperienceModelAddExperienceByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExperienceExperienceModelAddExperienceByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExperienceExperienceModelAddExperienceByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExperienceExperienceModelAddExperienceByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExperienceExperienceModelAddExperienceByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExperienceExperienceModelAddExperienceByUserDistribution) Pointer() *ExperienceExperienceModelAddExperienceByUserDistribution {
	return &p
}

func CastExperienceExperienceModelAddExperienceByUserDistributions(data []interface{}) []ExperienceExperienceModelAddExperienceByUserDistribution {
	v := make([]ExperienceExperienceModelAddExperienceByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceByUserDistributionsFromDict(data []ExperienceExperienceModelAddExperienceByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics{}
	} else {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticsFromJson(data string) ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics {
	req := ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticsFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics {
	return ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics) Pointer() *ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics {
	return &p
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticses(data []interface{}) []ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics {
	v := make([]ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticsesFromDict(data []ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment{}
	} else {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionSegmentFromJson(data string) ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment {
	req := ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionSegmentFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment {
	return ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment) Pointer() *ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment {
	return &p
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributionSegments(data []interface{}) []ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment {
	v := make([]ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceAmountByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributionSegmentsFromDict(data []ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddExperienceAmountByUserDistribution struct {
	Statistics   *ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics `json:"statistics"`
	Distribution []ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment   `json:"distribution"`
}

func (p *ExperienceExperienceModelAddExperienceAmountByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistribution{}
	} else {
		*p = ExperienceExperienceModelAddExperienceAmountByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionFromJson(data string) ExperienceExperienceModelAddExperienceAmountByUserDistribution {
	req := ExperienceExperienceModelAddExperienceAmountByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddExperienceAmountByUserDistributionFromDict(data map[string]interface{}) ExperienceExperienceModelAddExperienceAmountByUserDistribution {
	return ExperienceExperienceModelAddExperienceAmountByUserDistribution{
		Statistics: func() *ExperienceExperienceModelAddExperienceAmountByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceExperienceModelAddExperienceAmountByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExperienceExperienceModelAddExperienceAmountByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExperienceExperienceModelAddExperienceAmountByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExperienceExperienceModelAddExperienceAmountByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExperienceExperienceModelAddExperienceAmountByUserDistribution) Pointer() *ExperienceExperienceModelAddExperienceAmountByUserDistribution {
	return &p
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributions(data []interface{}) []ExperienceExperienceModelAddExperienceAmountByUserDistribution {
	v := make([]ExperienceExperienceModelAddExperienceAmountByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddExperienceAmountByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddExperienceAmountByUserDistributionsFromDict(data []ExperienceExperienceModelAddExperienceAmountByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceExperienceModelAddRankCapByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionStatistics{}
	} else {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapByUserDistributionStatisticsFromJson(data string) ExperienceExperienceModelAddRankCapByUserDistributionStatistics {
	req := ExperienceExperienceModelAddRankCapByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapByUserDistributionStatisticsFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapByUserDistributionStatistics {
	return ExperienceExperienceModelAddRankCapByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExperienceExperienceModelAddRankCapByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExperienceExperienceModelAddRankCapByUserDistributionStatistics) Pointer() *ExperienceExperienceModelAddRankCapByUserDistributionStatistics {
	return &p
}

func CastExperienceExperienceModelAddRankCapByUserDistributionStatisticses(data []interface{}) []ExperienceExperienceModelAddRankCapByUserDistributionStatistics {
	v := make([]ExperienceExperienceModelAddRankCapByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapByUserDistributionStatisticsesFromDict(data []ExperienceExperienceModelAddRankCapByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceExperienceModelAddRankCapByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionSegment{}
	} else {
		*p = ExperienceExperienceModelAddRankCapByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapByUserDistributionSegmentFromJson(data string) ExperienceExperienceModelAddRankCapByUserDistributionSegment {
	req := ExperienceExperienceModelAddRankCapByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapByUserDistributionSegmentFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapByUserDistributionSegment {
	return ExperienceExperienceModelAddRankCapByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExperienceExperienceModelAddRankCapByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExperienceExperienceModelAddRankCapByUserDistributionSegment) Pointer() *ExperienceExperienceModelAddRankCapByUserDistributionSegment {
	return &p
}

func CastExperienceExperienceModelAddRankCapByUserDistributionSegments(data []interface{}) []ExperienceExperienceModelAddRankCapByUserDistributionSegment {
	v := make([]ExperienceExperienceModelAddRankCapByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapByUserDistributionSegmentsFromDict(data []ExperienceExperienceModelAddRankCapByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapByUserDistribution struct {
	Statistics   *ExperienceExperienceModelAddRankCapByUserDistributionStatistics `json:"statistics"`
	Distribution []ExperienceExperienceModelAddRankCapByUserDistributionSegment   `json:"distribution"`
}

func (p *ExperienceExperienceModelAddRankCapByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapByUserDistribution{}
	} else {
		*p = ExperienceExperienceModelAddRankCapByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapByUserDistributionFromJson(data string) ExperienceExperienceModelAddRankCapByUserDistribution {
	req := ExperienceExperienceModelAddRankCapByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapByUserDistributionFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapByUserDistribution {
	return ExperienceExperienceModelAddRankCapByUserDistribution{
		Statistics: func() *ExperienceExperienceModelAddRankCapByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceExperienceModelAddRankCapByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExperienceExperienceModelAddRankCapByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExperienceExperienceModelAddRankCapByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExperienceExperienceModelAddRankCapByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExperienceExperienceModelAddRankCapByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExperienceExperienceModelAddRankCapByUserDistribution) Pointer() *ExperienceExperienceModelAddRankCapByUserDistribution {
	return &p
}

func CastExperienceExperienceModelAddRankCapByUserDistributions(data []interface{}) []ExperienceExperienceModelAddRankCapByUserDistribution {
	v := make([]ExperienceExperienceModelAddRankCapByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapByUserDistributionsFromDict(data []ExperienceExperienceModelAddRankCapByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics{}
	} else {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticsFromJson(data string) ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics {
	req := ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticsFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics {
	return ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics) Pointer() *ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics {
	return &p
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticses(data []interface{}) []ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics {
	v := make([]ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticsesFromDict(data []ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment{}
	} else {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionSegmentFromJson(data string) ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment {
	req := ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionSegmentFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment {
	return ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment) Pointer() *ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment {
	return &p
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributionSegments(data []interface{}) []ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment {
	v := make([]ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapAmountByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributionSegmentsFromDict(data []ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelAddRankCapAmountByUserDistribution struct {
	Statistics   *ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics `json:"statistics"`
	Distribution []ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment   `json:"distribution"`
}

func (p *ExperienceExperienceModelAddRankCapAmountByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistribution{}
	} else {
		*p = ExperienceExperienceModelAddRankCapAmountByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionFromJson(data string) ExperienceExperienceModelAddRankCapAmountByUserDistribution {
	req := ExperienceExperienceModelAddRankCapAmountByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelAddRankCapAmountByUserDistributionFromDict(data map[string]interface{}) ExperienceExperienceModelAddRankCapAmountByUserDistribution {
	return ExperienceExperienceModelAddRankCapAmountByUserDistribution{
		Statistics: func() *ExperienceExperienceModelAddRankCapAmountByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceExperienceModelAddRankCapAmountByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExperienceExperienceModelAddRankCapAmountByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExperienceExperienceModelAddRankCapAmountByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExperienceExperienceModelAddRankCapAmountByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExperienceExperienceModelAddRankCapAmountByUserDistribution) Pointer() *ExperienceExperienceModelAddRankCapAmountByUserDistribution {
	return &p
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributions(data []interface{}) []ExperienceExperienceModelAddRankCapAmountByUserDistribution {
	v := make([]ExperienceExperienceModelAddRankCapAmountByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelAddRankCapAmountByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelAddRankCapAmountByUserDistributionsFromDict(data []ExperienceExperienceModelAddRankCapAmountByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModelDistributions struct {
	AddExperienceByUser       *ExperienceExperienceModelAddExperienceByUserDistribution       `json:"addExperienceByUser"`
	AddExperienceAmountByUser *ExperienceExperienceModelAddExperienceAmountByUserDistribution `json:"addExperienceAmountByUser"`
	AddRankCapByUser          *ExperienceExperienceModelAddRankCapByUserDistribution          `json:"addRankCapByUser"`
	AddRankCapAmountByUser    *ExperienceExperienceModelAddRankCapAmountByUserDistribution    `json:"addRankCapAmountByUser"`
}

func (p *ExperienceExperienceModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModelDistributions{}
	} else {
		*p = ExperienceExperienceModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["addExperienceByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddExperienceByUser)
		}
		if v, ok := d["addExperienceAmountByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddExperienceAmountByUser)
		}
		if v, ok := d["addRankCapByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddRankCapByUser)
		}
		if v, ok := d["addRankCapAmountByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddRankCapAmountByUser)
		}
	}
	return nil
}

func NewExperienceExperienceModelDistributionsFromJson(data string) ExperienceExperienceModelDistributions {
	req := ExperienceExperienceModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelDistributionsFromDict(data map[string]interface{}) ExperienceExperienceModelDistributions {
	return ExperienceExperienceModelDistributions{
		AddExperienceByUser: func() *ExperienceExperienceModelAddExperienceByUserDistribution {
			v, ok := data["addExperienceByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceExperienceModelAddExperienceByUserDistributionFromDict(core.CastMap(data["addExperienceByUser"])).Pointer()
		}(),
		AddExperienceAmountByUser: func() *ExperienceExperienceModelAddExperienceAmountByUserDistribution {
			v, ok := data["addExperienceAmountByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceExperienceModelAddExperienceAmountByUserDistributionFromDict(core.CastMap(data["addExperienceAmountByUser"])).Pointer()
		}(),
		AddRankCapByUser: func() *ExperienceExperienceModelAddRankCapByUserDistribution {
			v, ok := data["addRankCapByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceExperienceModelAddRankCapByUserDistributionFromDict(core.CastMap(data["addRankCapByUser"])).Pointer()
		}(),
		AddRankCapAmountByUser: func() *ExperienceExperienceModelAddRankCapAmountByUserDistribution {
			v, ok := data["addRankCapAmountByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceExperienceModelAddRankCapAmountByUserDistributionFromDict(core.CastMap(data["addRankCapAmountByUser"])).Pointer()
		}(),
	}
}

func (p ExperienceExperienceModelDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.AddExperienceByUser != nil {
		m["addExperienceByUser"] = func() map[string]interface{} {
			if p.AddExperienceByUser == nil {
				return nil
			}
			return p.AddExperienceByUser.ToDict()
		}()
	}
	if p.AddExperienceAmountByUser != nil {
		m["addExperienceAmountByUser"] = func() map[string]interface{} {
			if p.AddExperienceAmountByUser == nil {
				return nil
			}
			return p.AddExperienceAmountByUser.ToDict()
		}()
	}
	if p.AddRankCapByUser != nil {
		m["addRankCapByUser"] = func() map[string]interface{} {
			if p.AddRankCapByUser == nil {
				return nil
			}
			return p.AddRankCapByUser.ToDict()
		}()
	}
	if p.AddRankCapAmountByUser != nil {
		m["addRankCapAmountByUser"] = func() map[string]interface{} {
			if p.AddRankCapAmountByUser == nil {
				return nil
			}
			return p.AddRankCapAmountByUser.ToDict()
		}()
	}
	return m
}

func (p ExperienceExperienceModelDistributions) Pointer() *ExperienceExperienceModelDistributions {
	return &p
}

func CastExperienceExperienceModelDistributionses(data []interface{}) []ExperienceExperienceModelDistributions {
	v := make([]ExperienceExperienceModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelDistributionsesFromDict(data []ExperienceExperienceModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceExperienceModel struct {
	ExperienceModelId *string                                 `json:"experienceModelId"`
	ExperienceName    *string                                 `json:"experienceName"`
	Statistics        *ExperienceExperienceModelStatistics    `json:"statistics"`
	Distributions     *ExperienceExperienceModelDistributions `json:"distributions"`
	Statuses          []ExperienceStatus                      `json:"statuses"`
}

func (p *ExperienceExperienceModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceExperienceModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceExperienceModel{}
	} else {
		*p = ExperienceExperienceModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["experienceModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ExperienceModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ExperienceModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ExperienceModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ExperienceModelId)
				}
			}
		}
		if v, ok := d["experienceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ExperienceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ExperienceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ExperienceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ExperienceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["statuses"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statuses)
		}
	}
	return nil
}

func NewExperienceExperienceModelFromJson(data string) ExperienceExperienceModel {
	req := ExperienceExperienceModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceExperienceModelFromDict(data map[string]interface{}) ExperienceExperienceModel {
	return ExperienceExperienceModel{
		ExperienceModelId: func() *string {
			v, ok := data["experienceModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["experienceModelId"])
		}(),
		ExperienceName: func() *string {
			v, ok := data["experienceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["experienceName"])
		}(),
		Statistics: func() *ExperienceExperienceModelStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceExperienceModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *ExperienceExperienceModelDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceExperienceModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		Statuses: func() []ExperienceStatus {
			if data["statuses"] == nil {
				return nil
			}
			return CastExperienceStatuses(core.CastArray(data["statuses"]))
		}(),
	}
}

func (p ExperienceExperienceModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ExperienceModelId != nil {
		m["experienceModelId"] = p.ExperienceModelId
	}
	if p.ExperienceName != nil {
		m["experienceName"] = p.ExperienceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.Statuses != nil {
		m["statuses"] = CastExperienceStatusesFromDict(
			p.Statuses,
		)
	}
	return m
}

func (p ExperienceExperienceModel) Pointer() *ExperienceExperienceModel {
	return &p
}

func CastExperienceExperienceModels(data []interface{}) []ExperienceExperienceModel {
	v := make([]ExperienceExperienceModel, 0)
	for _, d := range data {
		v = append(v, NewExperienceExperienceModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceExperienceModelsFromDict(data []ExperienceExperienceModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceStatistics struct {
	Experience *int64 `json:"experience"`
	RankCap    *int64 `json:"rankCap"`
}

func (p *ExperienceNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceStatistics{}
	} else {
		*p = ExperienceNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["experience"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Experience)
		}
		if v, ok := d["rankCap"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RankCap)
		}
	}
	return nil
}

func NewExperienceNamespaceStatisticsFromJson(data string) ExperienceNamespaceStatistics {
	req := ExperienceNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceStatisticsFromDict(data map[string]interface{}) ExperienceNamespaceStatistics {
	return ExperienceNamespaceStatistics{
		Experience: func() *int64 {
			v, ok := data["experience"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["experience"])
		}(),
		RankCap: func() *int64 {
			v, ok := data["rankCap"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["rankCap"])
		}(),
	}
}

func (p ExperienceNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Experience != nil {
		m["experience"] = p.Experience
	}
	if p.RankCap != nil {
		m["rankCap"] = p.RankCap
	}
	return m
}

func (p ExperienceNamespaceStatistics) Pointer() *ExperienceNamespaceStatistics {
	return &p
}

func CastExperienceNamespaceStatisticses(data []interface{}) []ExperienceNamespaceStatistics {
	v := make([]ExperienceNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceStatisticsesFromDict(data []ExperienceNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddExperienceByExperienceDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceNamespaceAddExperienceByExperienceDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionStatistics{}
	} else {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionStatisticsFromJson(data string) ExperienceNamespaceAddExperienceByExperienceDistributionStatistics {
	req := ExperienceNamespaceAddExperienceByExperienceDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionStatisticsFromDict(data map[string]interface{}) ExperienceNamespaceAddExperienceByExperienceDistributionStatistics {
	return ExperienceNamespaceAddExperienceByExperienceDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExperienceNamespaceAddExperienceByExperienceDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExperienceNamespaceAddExperienceByExperienceDistributionStatistics) Pointer() *ExperienceNamespaceAddExperienceByExperienceDistributionStatistics {
	return &p
}

func CastExperienceNamespaceAddExperienceByExperienceDistributionStatisticses(data []interface{}) []ExperienceNamespaceAddExperienceByExperienceDistributionStatistics {
	v := make([]ExperienceNamespaceAddExperienceByExperienceDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddExperienceByExperienceDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddExperienceByExperienceDistributionStatisticsesFromDict(data []ExperienceNamespaceAddExperienceByExperienceDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddExperienceByExperienceDistributionSegment struct {
	ExperienceName *string `json:"experienceName"`
	Count          *int64  `json:"count"`
}

func (p *ExperienceNamespaceAddExperienceByExperienceDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionSegment{}
	} else {
		*p = ExperienceNamespaceAddExperienceByExperienceDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["experienceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ExperienceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ExperienceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ExperienceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ExperienceName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionSegmentFromJson(data string) ExperienceNamespaceAddExperienceByExperienceDistributionSegment {
	req := ExperienceNamespaceAddExperienceByExperienceDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionSegmentFromDict(data map[string]interface{}) ExperienceNamespaceAddExperienceByExperienceDistributionSegment {
	return ExperienceNamespaceAddExperienceByExperienceDistributionSegment{
		ExperienceName: func() *string {
			v, ok := data["experienceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["experienceName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExperienceNamespaceAddExperienceByExperienceDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ExperienceName != nil {
		m["experienceName"] = p.ExperienceName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExperienceNamespaceAddExperienceByExperienceDistributionSegment) Pointer() *ExperienceNamespaceAddExperienceByExperienceDistributionSegment {
	return &p
}

func CastExperienceNamespaceAddExperienceByExperienceDistributionSegments(data []interface{}) []ExperienceNamespaceAddExperienceByExperienceDistributionSegment {
	v := make([]ExperienceNamespaceAddExperienceByExperienceDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddExperienceByExperienceDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddExperienceByExperienceDistributionSegmentsFromDict(data []ExperienceNamespaceAddExperienceByExperienceDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddExperienceByExperienceDistribution struct {
	Statistics   *ExperienceNamespaceAddExperienceByExperienceDistributionStatistics `json:"statistics"`
	Distribution []ExperienceNamespaceAddExperienceByExperienceDistributionSegment   `json:"distribution"`
}

func (p *ExperienceNamespaceAddExperienceByExperienceDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddExperienceByExperienceDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddExperienceByExperienceDistribution{}
	} else {
		*p = ExperienceNamespaceAddExperienceByExperienceDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionFromJson(data string) ExperienceNamespaceAddExperienceByExperienceDistribution {
	req := ExperienceNamespaceAddExperienceByExperienceDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddExperienceByExperienceDistributionFromDict(data map[string]interface{}) ExperienceNamespaceAddExperienceByExperienceDistribution {
	return ExperienceNamespaceAddExperienceByExperienceDistribution{
		Statistics: func() *ExperienceNamespaceAddExperienceByExperienceDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceNamespaceAddExperienceByExperienceDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExperienceNamespaceAddExperienceByExperienceDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExperienceNamespaceAddExperienceByExperienceDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExperienceNamespaceAddExperienceByExperienceDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExperienceNamespaceAddExperienceByExperienceDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExperienceNamespaceAddExperienceByExperienceDistribution) Pointer() *ExperienceNamespaceAddExperienceByExperienceDistribution {
	return &p
}

func CastExperienceNamespaceAddExperienceByExperienceDistributions(data []interface{}) []ExperienceNamespaceAddExperienceByExperienceDistribution {
	v := make([]ExperienceNamespaceAddExperienceByExperienceDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddExperienceByExperienceDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddExperienceByExperienceDistributionsFromDict(data []ExperienceNamespaceAddExperienceByExperienceDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddRankCapByExperienceDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ExperienceNamespaceAddRankCapByExperienceDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionStatistics{}
	} else {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionStatisticsFromJson(data string) ExperienceNamespaceAddRankCapByExperienceDistributionStatistics {
	req := ExperienceNamespaceAddRankCapByExperienceDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionStatisticsFromDict(data map[string]interface{}) ExperienceNamespaceAddRankCapByExperienceDistributionStatistics {
	return ExperienceNamespaceAddRankCapByExperienceDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ExperienceNamespaceAddRankCapByExperienceDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ExperienceNamespaceAddRankCapByExperienceDistributionStatistics) Pointer() *ExperienceNamespaceAddRankCapByExperienceDistributionStatistics {
	return &p
}

func CastExperienceNamespaceAddRankCapByExperienceDistributionStatisticses(data []interface{}) []ExperienceNamespaceAddRankCapByExperienceDistributionStatistics {
	v := make([]ExperienceNamespaceAddRankCapByExperienceDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddRankCapByExperienceDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddRankCapByExperienceDistributionStatisticsesFromDict(data []ExperienceNamespaceAddRankCapByExperienceDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddRankCapByExperienceDistributionSegment struct {
	ExperienceName *string `json:"experienceName"`
	Count          *int64  `json:"count"`
}

func (p *ExperienceNamespaceAddRankCapByExperienceDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionSegment{}
	} else {
		*p = ExperienceNamespaceAddRankCapByExperienceDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["experienceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ExperienceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ExperienceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ExperienceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ExperienceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ExperienceName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionSegmentFromJson(data string) ExperienceNamespaceAddRankCapByExperienceDistributionSegment {
	req := ExperienceNamespaceAddRankCapByExperienceDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionSegmentFromDict(data map[string]interface{}) ExperienceNamespaceAddRankCapByExperienceDistributionSegment {
	return ExperienceNamespaceAddRankCapByExperienceDistributionSegment{
		ExperienceName: func() *string {
			v, ok := data["experienceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["experienceName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ExperienceNamespaceAddRankCapByExperienceDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ExperienceName != nil {
		m["experienceName"] = p.ExperienceName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ExperienceNamespaceAddRankCapByExperienceDistributionSegment) Pointer() *ExperienceNamespaceAddRankCapByExperienceDistributionSegment {
	return &p
}

func CastExperienceNamespaceAddRankCapByExperienceDistributionSegments(data []interface{}) []ExperienceNamespaceAddRankCapByExperienceDistributionSegment {
	v := make([]ExperienceNamespaceAddRankCapByExperienceDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddRankCapByExperienceDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddRankCapByExperienceDistributionSegmentsFromDict(data []ExperienceNamespaceAddRankCapByExperienceDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceAddRankCapByExperienceDistribution struct {
	Statistics   *ExperienceNamespaceAddRankCapByExperienceDistributionStatistics `json:"statistics"`
	Distribution []ExperienceNamespaceAddRankCapByExperienceDistributionSegment   `json:"distribution"`
}

func (p *ExperienceNamespaceAddRankCapByExperienceDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceAddRankCapByExperienceDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceAddRankCapByExperienceDistribution{}
	} else {
		*p = ExperienceNamespaceAddRankCapByExperienceDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionFromJson(data string) ExperienceNamespaceAddRankCapByExperienceDistribution {
	req := ExperienceNamespaceAddRankCapByExperienceDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceAddRankCapByExperienceDistributionFromDict(data map[string]interface{}) ExperienceNamespaceAddRankCapByExperienceDistribution {
	return ExperienceNamespaceAddRankCapByExperienceDistribution{
		Statistics: func() *ExperienceNamespaceAddRankCapByExperienceDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceNamespaceAddRankCapByExperienceDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ExperienceNamespaceAddRankCapByExperienceDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastExperienceNamespaceAddRankCapByExperienceDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ExperienceNamespaceAddRankCapByExperienceDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastExperienceNamespaceAddRankCapByExperienceDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ExperienceNamespaceAddRankCapByExperienceDistribution) Pointer() *ExperienceNamespaceAddRankCapByExperienceDistribution {
	return &p
}

func CastExperienceNamespaceAddRankCapByExperienceDistributions(data []interface{}) []ExperienceNamespaceAddRankCapByExperienceDistribution {
	v := make([]ExperienceNamespaceAddRankCapByExperienceDistribution, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceAddRankCapByExperienceDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceAddRankCapByExperienceDistributionsFromDict(data []ExperienceNamespaceAddRankCapByExperienceDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespaceDistributions struct {
	AddExperienceByExperience *ExperienceNamespaceAddExperienceByExperienceDistribution `json:"addExperienceByExperience"`
	AddRankCapByExperience    *ExperienceNamespaceAddRankCapByExperienceDistribution    `json:"addRankCapByExperience"`
}

func (p *ExperienceNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespaceDistributions{}
	} else {
		*p = ExperienceNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["addExperienceByExperience"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddExperienceByExperience)
		}
		if v, ok := d["addRankCapByExperience"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AddRankCapByExperience)
		}
	}
	return nil
}

func NewExperienceNamespaceDistributionsFromJson(data string) ExperienceNamespaceDistributions {
	req := ExperienceNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceDistributionsFromDict(data map[string]interface{}) ExperienceNamespaceDistributions {
	return ExperienceNamespaceDistributions{
		AddExperienceByExperience: func() *ExperienceNamespaceAddExperienceByExperienceDistribution {
			v, ok := data["addExperienceByExperience"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceNamespaceAddExperienceByExperienceDistributionFromDict(core.CastMap(data["addExperienceByExperience"])).Pointer()
		}(),
		AddRankCapByExperience: func() *ExperienceNamespaceAddRankCapByExperienceDistribution {
			v, ok := data["addRankCapByExperience"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceNamespaceAddRankCapByExperienceDistributionFromDict(core.CastMap(data["addRankCapByExperience"])).Pointer()
		}(),
	}
}

func (p ExperienceNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.AddExperienceByExperience != nil {
		m["addExperienceByExperience"] = func() map[string]interface{} {
			if p.AddExperienceByExperience == nil {
				return nil
			}
			return p.AddExperienceByExperience.ToDict()
		}()
	}
	if p.AddRankCapByExperience != nil {
		m["addRankCapByExperience"] = func() map[string]interface{} {
			if p.AddRankCapByExperience == nil {
				return nil
			}
			return p.AddRankCapByExperience.ToDict()
		}()
	}
	return m
}

func (p ExperienceNamespaceDistributions) Pointer() *ExperienceNamespaceDistributions {
	return &p
}

func CastExperienceNamespaceDistributionses(data []interface{}) []ExperienceNamespaceDistributions {
	v := make([]ExperienceNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespaceDistributionsesFromDict(data []ExperienceNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ExperienceNamespace struct {
	NamespaceId      *string                           `json:"namespaceId"`
	Year             *int32                            `json:"year"`
	Month            *int32                            `json:"month"`
	Day              *int32                            `json:"day"`
	NamespaceName    *string                           `json:"namespaceName"`
	Statistics       *ExperienceNamespaceStatistics    `json:"statistics"`
	Distributions    *ExperienceNamespaceDistributions `json:"distributions"`
	ExperienceModels []ExperienceExperienceModel       `json:"experienceModels"`
}

func (p *ExperienceNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ExperienceNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ExperienceNamespace{}
	} else {
		*p = ExperienceNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["experienceModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ExperienceModels)
		}
	}
	return nil
}

func NewExperienceNamespaceFromJson(data string) ExperienceNamespace {
	req := ExperienceNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewExperienceNamespaceFromDict(data map[string]interface{}) ExperienceNamespace {
	return ExperienceNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *ExperienceNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *ExperienceNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewExperienceNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		ExperienceModels: func() []ExperienceExperienceModel {
			if data["experienceModels"] == nil {
				return nil
			}
			return CastExperienceExperienceModels(core.CastArray(data["experienceModels"]))
		}(),
	}
}

func (p ExperienceNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.ExperienceModels != nil {
		m["experienceModels"] = CastExperienceExperienceModelsFromDict(
			p.ExperienceModels,
		)
	}
	return m
}

func (p ExperienceNamespace) Pointer() *ExperienceNamespace {
	return &p
}

func CastExperienceNamespaces(data []interface{}) []ExperienceNamespace {
	v := make([]ExperienceNamespace, 0)
	for _, d := range data {
		v = append(v, NewExperienceNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastExperienceNamespacesFromDict(data []ExperienceNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormStatistics struct {
	Update *int64 `json:"update"`
}

func (p *FormationFormStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormStatistics{}
	} else {
		*p = FormationFormStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["update"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Update)
		}
	}
	return nil
}

func NewFormationFormStatisticsFromJson(data string) FormationFormStatistics {
	req := FormationFormStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormStatisticsFromDict(data map[string]interface{}) FormationFormStatistics {
	return FormationFormStatistics{
		Update: func() *int64 {
			v, ok := data["update"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["update"])
		}(),
	}
}

func (p FormationFormStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Update != nil {
		m["update"] = p.Update
	}
	return m
}

func (p FormationFormStatistics) Pointer() *FormationFormStatistics {
	return &p
}

func CastFormationFormStatisticses(data []interface{}) []FormationFormStatistics {
	v := make([]FormationFormStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationFormStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormStatisticsesFromDict(data []FormationFormStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormSlotDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationFormSlotDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormSlotDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormSlotDistributionStatistics{}
	} else {
		*p = FormationFormSlotDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationFormSlotDistributionStatisticsFromJson(data string) FormationFormSlotDistributionStatistics {
	req := FormationFormSlotDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormSlotDistributionStatisticsFromDict(data map[string]interface{}) FormationFormSlotDistributionStatistics {
	return FormationFormSlotDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FormationFormSlotDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FormationFormSlotDistributionStatistics) Pointer() *FormationFormSlotDistributionStatistics {
	return &p
}

func CastFormationFormSlotDistributionStatisticses(data []interface{}) []FormationFormSlotDistributionStatistics {
	v := make([]FormationFormSlotDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationFormSlotDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormSlotDistributionStatisticsesFromDict(data []FormationFormSlotDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormSlotDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FormationFormSlotDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormSlotDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormSlotDistributionSegment{}
	} else {
		*p = FormationFormSlotDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationFormSlotDistributionSegmentFromJson(data string) FormationFormSlotDistributionSegment {
	req := FormationFormSlotDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormSlotDistributionSegmentFromDict(data map[string]interface{}) FormationFormSlotDistributionSegment {
	return FormationFormSlotDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FormationFormSlotDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FormationFormSlotDistributionSegment) Pointer() *FormationFormSlotDistributionSegment {
	return &p
}

func CastFormationFormSlotDistributionSegments(data []interface{}) []FormationFormSlotDistributionSegment {
	v := make([]FormationFormSlotDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationFormSlotDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormSlotDistributionSegmentsFromDict(data []FormationFormSlotDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormSlotDistribution struct {
	Statistics   *FormationFormSlotDistributionStatistics `json:"statistics"`
	Distribution []FormationFormSlotDistributionSegment   `json:"distribution"`
}

func (p *FormationFormSlotDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormSlotDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormSlotDistribution{}
	} else {
		*p = FormationFormSlotDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationFormSlotDistributionFromJson(data string) FormationFormSlotDistribution {
	req := FormationFormSlotDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormSlotDistributionFromDict(data map[string]interface{}) FormationFormSlotDistribution {
	return FormationFormSlotDistribution{
		Statistics: func() *FormationFormSlotDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationFormSlotDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FormationFormSlotDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFormationFormSlotDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FormationFormSlotDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFormationFormSlotDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FormationFormSlotDistribution) Pointer() *FormationFormSlotDistribution {
	return &p
}

func CastFormationFormSlotDistributions(data []interface{}) []FormationFormSlotDistribution {
	v := make([]FormationFormSlotDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationFormSlotDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormSlotDistributionsFromDict(data []FormationFormSlotDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormUsageDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationFormUsageDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormUsageDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormUsageDistributionStatistics{}
	} else {
		*p = FormationFormUsageDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationFormUsageDistributionStatisticsFromJson(data string) FormationFormUsageDistributionStatistics {
	req := FormationFormUsageDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormUsageDistributionStatisticsFromDict(data map[string]interface{}) FormationFormUsageDistributionStatistics {
	return FormationFormUsageDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FormationFormUsageDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FormationFormUsageDistributionStatistics) Pointer() *FormationFormUsageDistributionStatistics {
	return &p
}

func CastFormationFormUsageDistributionStatisticses(data []interface{}) []FormationFormUsageDistributionStatistics {
	v := make([]FormationFormUsageDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationFormUsageDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormUsageDistributionStatisticsesFromDict(data []FormationFormUsageDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormUsageDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FormationFormUsageDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormUsageDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormUsageDistributionSegment{}
	} else {
		*p = FormationFormUsageDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationFormUsageDistributionSegmentFromJson(data string) FormationFormUsageDistributionSegment {
	req := FormationFormUsageDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormUsageDistributionSegmentFromDict(data map[string]interface{}) FormationFormUsageDistributionSegment {
	return FormationFormUsageDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FormationFormUsageDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FormationFormUsageDistributionSegment) Pointer() *FormationFormUsageDistributionSegment {
	return &p
}

func CastFormationFormUsageDistributionSegments(data []interface{}) []FormationFormUsageDistributionSegment {
	v := make([]FormationFormUsageDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationFormUsageDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormUsageDistributionSegmentsFromDict(data []FormationFormUsageDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormUsageDistribution struct {
	Statistics   *FormationFormUsageDistributionStatistics `json:"statistics"`
	Distribution []FormationFormUsageDistributionSegment   `json:"distribution"`
}

func (p *FormationFormUsageDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormUsageDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormUsageDistribution{}
	} else {
		*p = FormationFormUsageDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationFormUsageDistributionFromJson(data string) FormationFormUsageDistribution {
	req := FormationFormUsageDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormUsageDistributionFromDict(data map[string]interface{}) FormationFormUsageDistribution {
	return FormationFormUsageDistribution{
		Statistics: func() *FormationFormUsageDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationFormUsageDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FormationFormUsageDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFormationFormUsageDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FormationFormUsageDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFormationFormUsageDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FormationFormUsageDistribution) Pointer() *FormationFormUsageDistribution {
	return &p
}

func CastFormationFormUsageDistributions(data []interface{}) []FormationFormUsageDistribution {
	v := make([]FormationFormUsageDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationFormUsageDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormUsageDistributionsFromDict(data []FormationFormUsageDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationFormDistributions struct {
	Slot  *FormationFormSlotDistribution  `json:"slot"`
	Usage *FormationFormUsageDistribution `json:"usage"`
}

func (p *FormationFormDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationFormDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationFormDistributions{}
	} else {
		*p = FormationFormDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["slot"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Slot)
		}
		if v, ok := d["usage"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Usage)
		}
	}
	return nil
}

func NewFormationFormDistributionsFromJson(data string) FormationFormDistributions {
	req := FormationFormDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormDistributionsFromDict(data map[string]interface{}) FormationFormDistributions {
	return FormationFormDistributions{
		Slot: func() *FormationFormSlotDistribution {
			v, ok := data["slot"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationFormSlotDistributionFromDict(core.CastMap(data["slot"])).Pointer()
		}(),
		Usage: func() *FormationFormUsageDistribution {
			v, ok := data["usage"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationFormUsageDistributionFromDict(core.CastMap(data["usage"])).Pointer()
		}(),
	}
}

func (p FormationFormDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Slot != nil {
		m["slot"] = func() map[string]interface{} {
			if p.Slot == nil {
				return nil
			}
			return p.Slot.ToDict()
		}()
	}
	if p.Usage != nil {
		m["usage"] = func() map[string]interface{} {
			if p.Usage == nil {
				return nil
			}
			return p.Usage.ToDict()
		}()
	}
	return m
}

func (p FormationFormDistributions) Pointer() *FormationFormDistributions {
	return &p
}

func CastFormationFormDistributionses(data []interface{}) []FormationFormDistributions {
	v := make([]FormationFormDistributions, 0)
	for _, d := range data {
		v = append(v, NewFormationFormDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormDistributionsesFromDict(data []FormationFormDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationForm struct {
	FormId        *string                     `json:"formId"`
	Index         *int32                      `json:"index"`
	Statistics    *FormationFormStatistics    `json:"statistics"`
	Distributions *FormationFormDistributions `json:"distributions"`
}

func (p *FormationForm) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationForm{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationForm{}
	} else {
		*p = FormationForm{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["formId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.FormId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.FormId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.FormId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.FormId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.FormId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.FormId)
				}
			}
		}
		if v, ok := d["index"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Index)
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewFormationFormFromJson(data string) FormationForm {
	req := FormationForm{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationFormFromDict(data map[string]interface{}) FormationForm {
	return FormationForm{
		FormId: func() *string {
			v, ok := data["formId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["formId"])
		}(),
		Index: func() *int32 {
			v, ok := data["index"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["index"])
		}(),
		Statistics: func() *FormationFormStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationFormStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *FormationFormDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationFormDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p FormationForm) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.FormId != nil {
		m["formId"] = p.FormId
	}
	if p.Index != nil {
		m["index"] = p.Index
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p FormationForm) Pointer() *FormationForm {
	return &p
}

func CastFormationForms(data []interface{}) []FormationForm {
	v := make([]FormationForm, 0)
	for _, d := range data {
		v = append(v, NewFormationFormFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationFormsFromDict(data []FormationForm) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldStatistics struct {
	IncreaseCapacity       *int64 `json:"increaseCapacity"`
	IncreaseCapacityAmount *int64 `json:"increaseCapacityAmount"`
}

func (p *FormationMoldStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldStatistics{}
	} else {
		*p = FormationMoldStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increaseCapacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacity)
		}
		if v, ok := d["increaseCapacityAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacityAmount)
		}
	}
	return nil
}

func NewFormationMoldStatisticsFromJson(data string) FormationMoldStatistics {
	req := FormationMoldStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldStatisticsFromDict(data map[string]interface{}) FormationMoldStatistics {
	return FormationMoldStatistics{
		IncreaseCapacity: func() *int64 {
			v, ok := data["increaseCapacity"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increaseCapacity"])
		}(),
		IncreaseCapacityAmount: func() *int64 {
			v, ok := data["increaseCapacityAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increaseCapacityAmount"])
		}(),
	}
}

func (p FormationMoldStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.IncreaseCapacity != nil {
		m["increaseCapacity"] = p.IncreaseCapacity
	}
	if p.IncreaseCapacityAmount != nil {
		m["increaseCapacityAmount"] = p.IncreaseCapacityAmount
	}
	return m
}

func (p FormationMoldStatistics) Pointer() *FormationMoldStatistics {
	return &p
}

func CastFormationMoldStatisticses(data []interface{}) []FormationMoldStatistics {
	v := make([]FormationMoldStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldStatisticsesFromDict(data []FormationMoldStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldCapacityDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationMoldCapacityDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldCapacityDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldCapacityDistributionStatistics{}
	} else {
		*p = FormationMoldCapacityDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationMoldCapacityDistributionStatisticsFromJson(data string) FormationMoldCapacityDistributionStatistics {
	req := FormationMoldCapacityDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldCapacityDistributionStatisticsFromDict(data map[string]interface{}) FormationMoldCapacityDistributionStatistics {
	return FormationMoldCapacityDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FormationMoldCapacityDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FormationMoldCapacityDistributionStatistics) Pointer() *FormationMoldCapacityDistributionStatistics {
	return &p
}

func CastFormationMoldCapacityDistributionStatisticses(data []interface{}) []FormationMoldCapacityDistributionStatistics {
	v := make([]FormationMoldCapacityDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldCapacityDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldCapacityDistributionStatisticsesFromDict(data []FormationMoldCapacityDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldCapacityDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FormationMoldCapacityDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldCapacityDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldCapacityDistributionSegment{}
	} else {
		*p = FormationMoldCapacityDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationMoldCapacityDistributionSegmentFromJson(data string) FormationMoldCapacityDistributionSegment {
	req := FormationMoldCapacityDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldCapacityDistributionSegmentFromDict(data map[string]interface{}) FormationMoldCapacityDistributionSegment {
	return FormationMoldCapacityDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FormationMoldCapacityDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FormationMoldCapacityDistributionSegment) Pointer() *FormationMoldCapacityDistributionSegment {
	return &p
}

func CastFormationMoldCapacityDistributionSegments(data []interface{}) []FormationMoldCapacityDistributionSegment {
	v := make([]FormationMoldCapacityDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldCapacityDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldCapacityDistributionSegmentsFromDict(data []FormationMoldCapacityDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldCapacityDistribution struct {
	Statistics   *FormationMoldCapacityDistributionStatistics `json:"statistics"`
	Distribution []FormationMoldCapacityDistributionSegment   `json:"distribution"`
}

func (p *FormationMoldCapacityDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldCapacityDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldCapacityDistribution{}
	} else {
		*p = FormationMoldCapacityDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationMoldCapacityDistributionFromJson(data string) FormationMoldCapacityDistribution {
	req := FormationMoldCapacityDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldCapacityDistributionFromDict(data map[string]interface{}) FormationMoldCapacityDistribution {
	return FormationMoldCapacityDistribution{
		Statistics: func() *FormationMoldCapacityDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationMoldCapacityDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FormationMoldCapacityDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFormationMoldCapacityDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FormationMoldCapacityDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFormationMoldCapacityDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FormationMoldCapacityDistribution) Pointer() *FormationMoldCapacityDistribution {
	return &p
}

func CastFormationMoldCapacityDistributions(data []interface{}) []FormationMoldCapacityDistribution {
	v := make([]FormationMoldCapacityDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldCapacityDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldCapacityDistributionsFromDict(data []FormationMoldCapacityDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldUpdateByIndexDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationMoldUpdateByIndexDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldUpdateByIndexDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldUpdateByIndexDistributionStatistics{}
	} else {
		*p = FormationMoldUpdateByIndexDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationMoldUpdateByIndexDistributionStatisticsFromJson(data string) FormationMoldUpdateByIndexDistributionStatistics {
	req := FormationMoldUpdateByIndexDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldUpdateByIndexDistributionStatisticsFromDict(data map[string]interface{}) FormationMoldUpdateByIndexDistributionStatistics {
	return FormationMoldUpdateByIndexDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FormationMoldUpdateByIndexDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FormationMoldUpdateByIndexDistributionStatistics) Pointer() *FormationMoldUpdateByIndexDistributionStatistics {
	return &p
}

func CastFormationMoldUpdateByIndexDistributionStatisticses(data []interface{}) []FormationMoldUpdateByIndexDistributionStatistics {
	v := make([]FormationMoldUpdateByIndexDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldUpdateByIndexDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldUpdateByIndexDistributionStatisticsesFromDict(data []FormationMoldUpdateByIndexDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldUpdateByIndexDistributionSegment struct {
	Index *int64 `json:"index"`
	Count *int64 `json:"count"`
}

func (p *FormationMoldUpdateByIndexDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldUpdateByIndexDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldUpdateByIndexDistributionSegment{}
	} else {
		*p = FormationMoldUpdateByIndexDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["index"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Index)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationMoldUpdateByIndexDistributionSegmentFromJson(data string) FormationMoldUpdateByIndexDistributionSegment {
	req := FormationMoldUpdateByIndexDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldUpdateByIndexDistributionSegmentFromDict(data map[string]interface{}) FormationMoldUpdateByIndexDistributionSegment {
	return FormationMoldUpdateByIndexDistributionSegment{
		Index: func() *int64 {
			v, ok := data["index"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["index"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FormationMoldUpdateByIndexDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Index != nil {
		m["index"] = p.Index
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FormationMoldUpdateByIndexDistributionSegment) Pointer() *FormationMoldUpdateByIndexDistributionSegment {
	return &p
}

func CastFormationMoldUpdateByIndexDistributionSegments(data []interface{}) []FormationMoldUpdateByIndexDistributionSegment {
	v := make([]FormationMoldUpdateByIndexDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldUpdateByIndexDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldUpdateByIndexDistributionSegmentsFromDict(data []FormationMoldUpdateByIndexDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldUpdateByIndexDistribution struct {
	Statistics   *FormationMoldUpdateByIndexDistributionStatistics `json:"statistics"`
	Distribution []FormationMoldUpdateByIndexDistributionSegment   `json:"distribution"`
}

func (p *FormationMoldUpdateByIndexDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldUpdateByIndexDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldUpdateByIndexDistribution{}
	} else {
		*p = FormationMoldUpdateByIndexDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationMoldUpdateByIndexDistributionFromJson(data string) FormationMoldUpdateByIndexDistribution {
	req := FormationMoldUpdateByIndexDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldUpdateByIndexDistributionFromDict(data map[string]interface{}) FormationMoldUpdateByIndexDistribution {
	return FormationMoldUpdateByIndexDistribution{
		Statistics: func() *FormationMoldUpdateByIndexDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationMoldUpdateByIndexDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FormationMoldUpdateByIndexDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFormationMoldUpdateByIndexDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FormationMoldUpdateByIndexDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFormationMoldUpdateByIndexDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FormationMoldUpdateByIndexDistribution) Pointer() *FormationMoldUpdateByIndexDistribution {
	return &p
}

func CastFormationMoldUpdateByIndexDistributions(data []interface{}) []FormationMoldUpdateByIndexDistribution {
	v := make([]FormationMoldUpdateByIndexDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldUpdateByIndexDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldUpdateByIndexDistributionsFromDict(data []FormationMoldUpdateByIndexDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMoldDistributions struct {
	Capacity      *FormationMoldCapacityDistribution      `json:"capacity"`
	UpdateByIndex *FormationMoldUpdateByIndexDistribution `json:"updateByIndex"`
}

func (p *FormationMoldDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMoldDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMoldDistributions{}
	} else {
		*p = FormationMoldDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["capacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Capacity)
		}
		if v, ok := d["updateByIndex"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.UpdateByIndex)
		}
	}
	return nil
}

func NewFormationMoldDistributionsFromJson(data string) FormationMoldDistributions {
	req := FormationMoldDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldDistributionsFromDict(data map[string]interface{}) FormationMoldDistributions {
	return FormationMoldDistributions{
		Capacity: func() *FormationMoldCapacityDistribution {
			v, ok := data["capacity"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationMoldCapacityDistributionFromDict(core.CastMap(data["capacity"])).Pointer()
		}(),
		UpdateByIndex: func() *FormationMoldUpdateByIndexDistribution {
			v, ok := data["updateByIndex"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationMoldUpdateByIndexDistributionFromDict(core.CastMap(data["updateByIndex"])).Pointer()
		}(),
	}
}

func (p FormationMoldDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Capacity != nil {
		m["capacity"] = func() map[string]interface{} {
			if p.Capacity == nil {
				return nil
			}
			return p.Capacity.ToDict()
		}()
	}
	if p.UpdateByIndex != nil {
		m["updateByIndex"] = func() map[string]interface{} {
			if p.UpdateByIndex == nil {
				return nil
			}
			return p.UpdateByIndex.ToDict()
		}()
	}
	return m
}

func (p FormationMoldDistributions) Pointer() *FormationMoldDistributions {
	return &p
}

func CastFormationMoldDistributionses(data []interface{}) []FormationMoldDistributions {
	v := make([]FormationMoldDistributions, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldDistributionsesFromDict(data []FormationMoldDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationMold struct {
	MoldId        *string                     `json:"moldId"`
	MoldModelName *string                     `json:"moldModelName"`
	Statistics    *FormationMoldStatistics    `json:"statistics"`
	Distributions *FormationMoldDistributions `json:"distributions"`
	Forms         []FormationForm             `json:"forms"`
}

func (p *FormationMold) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationMold{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationMold{}
	} else {
		*p = FormationMold{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["moldId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MoldId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MoldId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MoldId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MoldId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MoldId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MoldId)
				}
			}
		}
		if v, ok := d["moldModelName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MoldModelName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MoldModelName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MoldModelName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MoldModelName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["forms"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Forms)
		}
	}
	return nil
}

func NewFormationMoldFromJson(data string) FormationMold {
	req := FormationMold{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationMoldFromDict(data map[string]interface{}) FormationMold {
	return FormationMold{
		MoldId: func() *string {
			v, ok := data["moldId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["moldId"])
		}(),
		MoldModelName: func() *string {
			v, ok := data["moldModelName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["moldModelName"])
		}(),
		Statistics: func() *FormationMoldStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationMoldStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *FormationMoldDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationMoldDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		Forms: func() []FormationForm {
			if data["forms"] == nil {
				return nil
			}
			return CastFormationForms(core.CastArray(data["forms"]))
		}(),
	}
}

func (p FormationMold) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.MoldId != nil {
		m["moldId"] = p.MoldId
	}
	if p.MoldModelName != nil {
		m["moldModelName"] = p.MoldModelName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.Forms != nil {
		m["forms"] = CastFormationFormsFromDict(
			p.Forms,
		)
	}
	return m
}

func (p FormationMold) Pointer() *FormationMold {
	return &p
}

func CastFormationMolds(data []interface{}) []FormationMold {
	v := make([]FormationMold, 0)
	for _, d := range data {
		v = append(v, NewFormationMoldFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationMoldsFromDict(data []FormationMold) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceStatistics struct {
	Update   *int64 `json:"update"`
	Increase *int64 `json:"increase"`
}

func (p *FormationNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceStatistics{}
	} else {
		*p = FormationNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["update"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Update)
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
	}
	return nil
}

func NewFormationNamespaceStatisticsFromJson(data string) FormationNamespaceStatistics {
	req := FormationNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceStatisticsFromDict(data map[string]interface{}) FormationNamespaceStatistics {
	return FormationNamespaceStatistics{
		Update: func() *int64 {
			v, ok := data["update"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["update"])
		}(),
		Increase: func() *int64 {
			v, ok := data["increase"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increase"])
		}(),
	}
}

func (p FormationNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Update != nil {
		m["update"] = p.Update
	}
	if p.Increase != nil {
		m["increase"] = p.Increase
	}
	return m
}

func (p FormationNamespaceStatistics) Pointer() *FormationNamespaceStatistics {
	return &p
}

func CastFormationNamespaceStatisticses(data []interface{}) []FormationNamespaceStatistics {
	v := make([]FormationNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceStatisticsesFromDict(data []FormationNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceUpdateByMoldDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationNamespaceUpdateByMoldDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceUpdateByMoldDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceUpdateByMoldDistributionStatistics{}
	} else {
		*p = FormationNamespaceUpdateByMoldDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationNamespaceUpdateByMoldDistributionStatisticsFromJson(data string) FormationNamespaceUpdateByMoldDistributionStatistics {
	req := FormationNamespaceUpdateByMoldDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceUpdateByMoldDistributionStatisticsFromDict(data map[string]interface{}) FormationNamespaceUpdateByMoldDistributionStatistics {
	return FormationNamespaceUpdateByMoldDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FormationNamespaceUpdateByMoldDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FormationNamespaceUpdateByMoldDistributionStatistics) Pointer() *FormationNamespaceUpdateByMoldDistributionStatistics {
	return &p
}

func CastFormationNamespaceUpdateByMoldDistributionStatisticses(data []interface{}) []FormationNamespaceUpdateByMoldDistributionStatistics {
	v := make([]FormationNamespaceUpdateByMoldDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceUpdateByMoldDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceUpdateByMoldDistributionStatisticsesFromDict(data []FormationNamespaceUpdateByMoldDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceUpdateByMoldDistributionSegment struct {
	MoldModelName *string `json:"moldModelName"`
	Count         *int64  `json:"count"`
}

func (p *FormationNamespaceUpdateByMoldDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceUpdateByMoldDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceUpdateByMoldDistributionSegment{}
	} else {
		*p = FormationNamespaceUpdateByMoldDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["moldModelName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MoldModelName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MoldModelName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MoldModelName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MoldModelName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationNamespaceUpdateByMoldDistributionSegmentFromJson(data string) FormationNamespaceUpdateByMoldDistributionSegment {
	req := FormationNamespaceUpdateByMoldDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceUpdateByMoldDistributionSegmentFromDict(data map[string]interface{}) FormationNamespaceUpdateByMoldDistributionSegment {
	return FormationNamespaceUpdateByMoldDistributionSegment{
		MoldModelName: func() *string {
			v, ok := data["moldModelName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["moldModelName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FormationNamespaceUpdateByMoldDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.MoldModelName != nil {
		m["moldModelName"] = p.MoldModelName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FormationNamespaceUpdateByMoldDistributionSegment) Pointer() *FormationNamespaceUpdateByMoldDistributionSegment {
	return &p
}

func CastFormationNamespaceUpdateByMoldDistributionSegments(data []interface{}) []FormationNamespaceUpdateByMoldDistributionSegment {
	v := make([]FormationNamespaceUpdateByMoldDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceUpdateByMoldDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceUpdateByMoldDistributionSegmentsFromDict(data []FormationNamespaceUpdateByMoldDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceUpdateByMoldDistribution struct {
	Statistics   *FormationNamespaceUpdateByMoldDistributionStatistics `json:"statistics"`
	Distribution []FormationNamespaceUpdateByMoldDistributionSegment   `json:"distribution"`
}

func (p *FormationNamespaceUpdateByMoldDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceUpdateByMoldDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceUpdateByMoldDistribution{}
	} else {
		*p = FormationNamespaceUpdateByMoldDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationNamespaceUpdateByMoldDistributionFromJson(data string) FormationNamespaceUpdateByMoldDistribution {
	req := FormationNamespaceUpdateByMoldDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceUpdateByMoldDistributionFromDict(data map[string]interface{}) FormationNamespaceUpdateByMoldDistribution {
	return FormationNamespaceUpdateByMoldDistribution{
		Statistics: func() *FormationNamespaceUpdateByMoldDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationNamespaceUpdateByMoldDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FormationNamespaceUpdateByMoldDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFormationNamespaceUpdateByMoldDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FormationNamespaceUpdateByMoldDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFormationNamespaceUpdateByMoldDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FormationNamespaceUpdateByMoldDistribution) Pointer() *FormationNamespaceUpdateByMoldDistribution {
	return &p
}

func CastFormationNamespaceUpdateByMoldDistributions(data []interface{}) []FormationNamespaceUpdateByMoldDistribution {
	v := make([]FormationNamespaceUpdateByMoldDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceUpdateByMoldDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceUpdateByMoldDistributionsFromDict(data []FormationNamespaceUpdateByMoldDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceIncreaseCapacityByMoldDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FormationNamespaceIncreaseCapacityByMoldDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionStatistics{}
	} else {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionStatisticsFromJson(data string) FormationNamespaceIncreaseCapacityByMoldDistributionStatistics {
	req := FormationNamespaceIncreaseCapacityByMoldDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionStatisticsFromDict(data map[string]interface{}) FormationNamespaceIncreaseCapacityByMoldDistributionStatistics {
	return FormationNamespaceIncreaseCapacityByMoldDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FormationNamespaceIncreaseCapacityByMoldDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FormationNamespaceIncreaseCapacityByMoldDistributionStatistics) Pointer() *FormationNamespaceIncreaseCapacityByMoldDistributionStatistics {
	return &p
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributionStatisticses(data []interface{}) []FormationNamespaceIncreaseCapacityByMoldDistributionStatistics {
	v := make([]FormationNamespaceIncreaseCapacityByMoldDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceIncreaseCapacityByMoldDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributionStatisticsesFromDict(data []FormationNamespaceIncreaseCapacityByMoldDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceIncreaseCapacityByMoldDistributionSegment struct {
	MoldModelName *string `json:"moldModelName"`
	Count         *int64  `json:"count"`
}

func (p *FormationNamespaceIncreaseCapacityByMoldDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionSegment{}
	} else {
		*p = FormationNamespaceIncreaseCapacityByMoldDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["moldModelName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MoldModelName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MoldModelName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MoldModelName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MoldModelName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MoldModelName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionSegmentFromJson(data string) FormationNamespaceIncreaseCapacityByMoldDistributionSegment {
	req := FormationNamespaceIncreaseCapacityByMoldDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionSegmentFromDict(data map[string]interface{}) FormationNamespaceIncreaseCapacityByMoldDistributionSegment {
	return FormationNamespaceIncreaseCapacityByMoldDistributionSegment{
		MoldModelName: func() *string {
			v, ok := data["moldModelName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["moldModelName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FormationNamespaceIncreaseCapacityByMoldDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.MoldModelName != nil {
		m["moldModelName"] = p.MoldModelName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FormationNamespaceIncreaseCapacityByMoldDistributionSegment) Pointer() *FormationNamespaceIncreaseCapacityByMoldDistributionSegment {
	return &p
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributionSegments(data []interface{}) []FormationNamespaceIncreaseCapacityByMoldDistributionSegment {
	v := make([]FormationNamespaceIncreaseCapacityByMoldDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceIncreaseCapacityByMoldDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributionSegmentsFromDict(data []FormationNamespaceIncreaseCapacityByMoldDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceIncreaseCapacityByMoldDistribution struct {
	Statistics   *FormationNamespaceIncreaseCapacityByMoldDistributionStatistics `json:"statistics"`
	Distribution []FormationNamespaceIncreaseCapacityByMoldDistributionSegment   `json:"distribution"`
}

func (p *FormationNamespaceIncreaseCapacityByMoldDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceIncreaseCapacityByMoldDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceIncreaseCapacityByMoldDistribution{}
	} else {
		*p = FormationNamespaceIncreaseCapacityByMoldDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionFromJson(data string) FormationNamespaceIncreaseCapacityByMoldDistribution {
	req := FormationNamespaceIncreaseCapacityByMoldDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceIncreaseCapacityByMoldDistributionFromDict(data map[string]interface{}) FormationNamespaceIncreaseCapacityByMoldDistribution {
	return FormationNamespaceIncreaseCapacityByMoldDistribution{
		Statistics: func() *FormationNamespaceIncreaseCapacityByMoldDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationNamespaceIncreaseCapacityByMoldDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FormationNamespaceIncreaseCapacityByMoldDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFormationNamespaceIncreaseCapacityByMoldDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FormationNamespaceIncreaseCapacityByMoldDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFormationNamespaceIncreaseCapacityByMoldDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FormationNamespaceIncreaseCapacityByMoldDistribution) Pointer() *FormationNamespaceIncreaseCapacityByMoldDistribution {
	return &p
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributions(data []interface{}) []FormationNamespaceIncreaseCapacityByMoldDistribution {
	v := make([]FormationNamespaceIncreaseCapacityByMoldDistribution, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceIncreaseCapacityByMoldDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceIncreaseCapacityByMoldDistributionsFromDict(data []FormationNamespaceIncreaseCapacityByMoldDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespaceDistributions struct {
	UpdateByMold           *FormationNamespaceUpdateByMoldDistribution           `json:"updateByMold"`
	IncreaseCapacityByMold *FormationNamespaceIncreaseCapacityByMoldDistribution `json:"increaseCapacityByMold"`
}

func (p *FormationNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespaceDistributions{}
	} else {
		*p = FormationNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["updateByMold"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.UpdateByMold)
		}
		if v, ok := d["increaseCapacityByMold"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacityByMold)
		}
	}
	return nil
}

func NewFormationNamespaceDistributionsFromJson(data string) FormationNamespaceDistributions {
	req := FormationNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceDistributionsFromDict(data map[string]interface{}) FormationNamespaceDistributions {
	return FormationNamespaceDistributions{
		UpdateByMold: func() *FormationNamespaceUpdateByMoldDistribution {
			v, ok := data["updateByMold"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationNamespaceUpdateByMoldDistributionFromDict(core.CastMap(data["updateByMold"])).Pointer()
		}(),
		IncreaseCapacityByMold: func() *FormationNamespaceIncreaseCapacityByMoldDistribution {
			v, ok := data["increaseCapacityByMold"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationNamespaceIncreaseCapacityByMoldDistributionFromDict(core.CastMap(data["increaseCapacityByMold"])).Pointer()
		}(),
	}
}

func (p FormationNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.UpdateByMold != nil {
		m["updateByMold"] = func() map[string]interface{} {
			if p.UpdateByMold == nil {
				return nil
			}
			return p.UpdateByMold.ToDict()
		}()
	}
	if p.IncreaseCapacityByMold != nil {
		m["increaseCapacityByMold"] = func() map[string]interface{} {
			if p.IncreaseCapacityByMold == nil {
				return nil
			}
			return p.IncreaseCapacityByMold.ToDict()
		}()
	}
	return m
}

func (p FormationNamespaceDistributions) Pointer() *FormationNamespaceDistributions {
	return &p
}

func CastFormationNamespaceDistributionses(data []interface{}) []FormationNamespaceDistributions {
	v := make([]FormationNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespaceDistributionsesFromDict(data []FormationNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FormationNamespace struct {
	NamespaceId   *string                          `json:"namespaceId"`
	Year          *int32                           `json:"year"`
	Month         *int32                           `json:"month"`
	Day           *int32                           `json:"day"`
	NamespaceName *string                          `json:"namespaceName"`
	Statistics    *FormationNamespaceStatistics    `json:"statistics"`
	Distributions *FormationNamespaceDistributions `json:"distributions"`
	Molds         []FormationMold                  `json:"molds"`
}

func (p *FormationNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FormationNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FormationNamespace{}
	} else {
		*p = FormationNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["molds"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Molds)
		}
	}
	return nil
}

func NewFormationNamespaceFromJson(data string) FormationNamespace {
	req := FormationNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFormationNamespaceFromDict(data map[string]interface{}) FormationNamespace {
	return FormationNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *FormationNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *FormationNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewFormationNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		Molds: func() []FormationMold {
			if data["molds"] == nil {
				return nil
			}
			return CastFormationMolds(core.CastArray(data["molds"]))
		}(),
	}
}

func (p FormationNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.Molds != nil {
		m["molds"] = CastFormationMoldsFromDict(
			p.Molds,
		)
	}
	return m
}

func (p FormationNamespace) Pointer() *FormationNamespace {
	return &p
}

func CastFormationNamespaces(data []interface{}) []FormationNamespace {
	v := make([]FormationNamespace, 0)
	for _, d := range data {
		v = append(v, NewFormationNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFormationNamespacesFromDict(data []FormationNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceStatistics struct {
	Accept      *int64 `json:"accept"`
	Reject      *int64 `json:"reject"`
	SendRequest *int64 `json:"sendRequest"`
	Follow      *int64 `json:"follow"`
}

func (p *FriendNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceStatistics{}
	} else {
		*p = FriendNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["accept"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Accept)
		}
		if v, ok := d["reject"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Reject)
		}
		if v, ok := d["sendRequest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SendRequest)
		}
		if v, ok := d["follow"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Follow)
		}
	}
	return nil
}

func NewFriendNamespaceStatisticsFromJson(data string) FriendNamespaceStatistics {
	req := FriendNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceStatisticsFromDict(data map[string]interface{}) FriendNamespaceStatistics {
	return FriendNamespaceStatistics{
		Accept: func() *int64 {
			v, ok := data["accept"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["accept"])
		}(),
		Reject: func() *int64 {
			v, ok := data["reject"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["reject"])
		}(),
		SendRequest: func() *int64 {
			v, ok := data["sendRequest"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sendRequest"])
		}(),
		Follow: func() *int64 {
			v, ok := data["follow"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["follow"])
		}(),
	}
}

func (p FriendNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Accept != nil {
		m["accept"] = p.Accept
	}
	if p.Reject != nil {
		m["reject"] = p.Reject
	}
	if p.SendRequest != nil {
		m["sendRequest"] = p.SendRequest
	}
	if p.Follow != nil {
		m["follow"] = p.Follow
	}
	return m
}

func (p FriendNamespaceStatistics) Pointer() *FriendNamespaceStatistics {
	return &p
}

func CastFriendNamespaceStatisticses(data []interface{}) []FriendNamespaceStatistics {
	v := make([]FriendNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceStatisticsesFromDict(data []FriendNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceAcceptByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FriendNamespaceAcceptByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceAcceptByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceAcceptByUserDistributionStatistics{}
	} else {
		*p = FriendNamespaceAcceptByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFriendNamespaceAcceptByUserDistributionStatisticsFromJson(data string) FriendNamespaceAcceptByUserDistributionStatistics {
	req := FriendNamespaceAcceptByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceAcceptByUserDistributionStatisticsFromDict(data map[string]interface{}) FriendNamespaceAcceptByUserDistributionStatistics {
	return FriendNamespaceAcceptByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FriendNamespaceAcceptByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FriendNamespaceAcceptByUserDistributionStatistics) Pointer() *FriendNamespaceAcceptByUserDistributionStatistics {
	return &p
}

func CastFriendNamespaceAcceptByUserDistributionStatisticses(data []interface{}) []FriendNamespaceAcceptByUserDistributionStatistics {
	v := make([]FriendNamespaceAcceptByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceAcceptByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceAcceptByUserDistributionStatisticsesFromDict(data []FriendNamespaceAcceptByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceAcceptByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FriendNamespaceAcceptByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceAcceptByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceAcceptByUserDistributionSegment{}
	} else {
		*p = FriendNamespaceAcceptByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFriendNamespaceAcceptByUserDistributionSegmentFromJson(data string) FriendNamespaceAcceptByUserDistributionSegment {
	req := FriendNamespaceAcceptByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceAcceptByUserDistributionSegmentFromDict(data map[string]interface{}) FriendNamespaceAcceptByUserDistributionSegment {
	return FriendNamespaceAcceptByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FriendNamespaceAcceptByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FriendNamespaceAcceptByUserDistributionSegment) Pointer() *FriendNamespaceAcceptByUserDistributionSegment {
	return &p
}

func CastFriendNamespaceAcceptByUserDistributionSegments(data []interface{}) []FriendNamespaceAcceptByUserDistributionSegment {
	v := make([]FriendNamespaceAcceptByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceAcceptByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceAcceptByUserDistributionSegmentsFromDict(data []FriendNamespaceAcceptByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceAcceptByUserDistribution struct {
	Statistics   *FriendNamespaceAcceptByUserDistributionStatistics `json:"statistics"`
	Distribution []FriendNamespaceAcceptByUserDistributionSegment   `json:"distribution"`
}

func (p *FriendNamespaceAcceptByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceAcceptByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceAcceptByUserDistribution{}
	} else {
		*p = FriendNamespaceAcceptByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFriendNamespaceAcceptByUserDistributionFromJson(data string) FriendNamespaceAcceptByUserDistribution {
	req := FriendNamespaceAcceptByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceAcceptByUserDistributionFromDict(data map[string]interface{}) FriendNamespaceAcceptByUserDistribution {
	return FriendNamespaceAcceptByUserDistribution{
		Statistics: func() *FriendNamespaceAcceptByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFriendNamespaceAcceptByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FriendNamespaceAcceptByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFriendNamespaceAcceptByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FriendNamespaceAcceptByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFriendNamespaceAcceptByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FriendNamespaceAcceptByUserDistribution) Pointer() *FriendNamespaceAcceptByUserDistribution {
	return &p
}

func CastFriendNamespaceAcceptByUserDistributions(data []interface{}) []FriendNamespaceAcceptByUserDistribution {
	v := make([]FriendNamespaceAcceptByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceAcceptByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceAcceptByUserDistributionsFromDict(data []FriendNamespaceAcceptByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceRejectByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FriendNamespaceRejectByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceRejectByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceRejectByUserDistributionStatistics{}
	} else {
		*p = FriendNamespaceRejectByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFriendNamespaceRejectByUserDistributionStatisticsFromJson(data string) FriendNamespaceRejectByUserDistributionStatistics {
	req := FriendNamespaceRejectByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceRejectByUserDistributionStatisticsFromDict(data map[string]interface{}) FriendNamespaceRejectByUserDistributionStatistics {
	return FriendNamespaceRejectByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FriendNamespaceRejectByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FriendNamespaceRejectByUserDistributionStatistics) Pointer() *FriendNamespaceRejectByUserDistributionStatistics {
	return &p
}

func CastFriendNamespaceRejectByUserDistributionStatisticses(data []interface{}) []FriendNamespaceRejectByUserDistributionStatistics {
	v := make([]FriendNamespaceRejectByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceRejectByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceRejectByUserDistributionStatisticsesFromDict(data []FriendNamespaceRejectByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceRejectByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FriendNamespaceRejectByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceRejectByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceRejectByUserDistributionSegment{}
	} else {
		*p = FriendNamespaceRejectByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFriendNamespaceRejectByUserDistributionSegmentFromJson(data string) FriendNamespaceRejectByUserDistributionSegment {
	req := FriendNamespaceRejectByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceRejectByUserDistributionSegmentFromDict(data map[string]interface{}) FriendNamespaceRejectByUserDistributionSegment {
	return FriendNamespaceRejectByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FriendNamespaceRejectByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FriendNamespaceRejectByUserDistributionSegment) Pointer() *FriendNamespaceRejectByUserDistributionSegment {
	return &p
}

func CastFriendNamespaceRejectByUserDistributionSegments(data []interface{}) []FriendNamespaceRejectByUserDistributionSegment {
	v := make([]FriendNamespaceRejectByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceRejectByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceRejectByUserDistributionSegmentsFromDict(data []FriendNamespaceRejectByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceRejectByUserDistribution struct {
	Statistics   *FriendNamespaceRejectByUserDistributionStatistics `json:"statistics"`
	Distribution []FriendNamespaceRejectByUserDistributionSegment   `json:"distribution"`
}

func (p *FriendNamespaceRejectByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceRejectByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceRejectByUserDistribution{}
	} else {
		*p = FriendNamespaceRejectByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFriendNamespaceRejectByUserDistributionFromJson(data string) FriendNamespaceRejectByUserDistribution {
	req := FriendNamespaceRejectByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceRejectByUserDistributionFromDict(data map[string]interface{}) FriendNamespaceRejectByUserDistribution {
	return FriendNamespaceRejectByUserDistribution{
		Statistics: func() *FriendNamespaceRejectByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFriendNamespaceRejectByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FriendNamespaceRejectByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFriendNamespaceRejectByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FriendNamespaceRejectByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFriendNamespaceRejectByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FriendNamespaceRejectByUserDistribution) Pointer() *FriendNamespaceRejectByUserDistribution {
	return &p
}

func CastFriendNamespaceRejectByUserDistributions(data []interface{}) []FriendNamespaceRejectByUserDistribution {
	v := make([]FriendNamespaceRejectByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceRejectByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceRejectByUserDistributionsFromDict(data []FriendNamespaceRejectByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceSendRequestByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FriendNamespaceSendRequestByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceSendRequestByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceSendRequestByUserDistributionStatistics{}
	} else {
		*p = FriendNamespaceSendRequestByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFriendNamespaceSendRequestByUserDistributionStatisticsFromJson(data string) FriendNamespaceSendRequestByUserDistributionStatistics {
	req := FriendNamespaceSendRequestByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceSendRequestByUserDistributionStatisticsFromDict(data map[string]interface{}) FriendNamespaceSendRequestByUserDistributionStatistics {
	return FriendNamespaceSendRequestByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FriendNamespaceSendRequestByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FriendNamespaceSendRequestByUserDistributionStatistics) Pointer() *FriendNamespaceSendRequestByUserDistributionStatistics {
	return &p
}

func CastFriendNamespaceSendRequestByUserDistributionStatisticses(data []interface{}) []FriendNamespaceSendRequestByUserDistributionStatistics {
	v := make([]FriendNamespaceSendRequestByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceSendRequestByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceSendRequestByUserDistributionStatisticsesFromDict(data []FriendNamespaceSendRequestByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceSendRequestByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FriendNamespaceSendRequestByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceSendRequestByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceSendRequestByUserDistributionSegment{}
	} else {
		*p = FriendNamespaceSendRequestByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFriendNamespaceSendRequestByUserDistributionSegmentFromJson(data string) FriendNamespaceSendRequestByUserDistributionSegment {
	req := FriendNamespaceSendRequestByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceSendRequestByUserDistributionSegmentFromDict(data map[string]interface{}) FriendNamespaceSendRequestByUserDistributionSegment {
	return FriendNamespaceSendRequestByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FriendNamespaceSendRequestByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FriendNamespaceSendRequestByUserDistributionSegment) Pointer() *FriendNamespaceSendRequestByUserDistributionSegment {
	return &p
}

func CastFriendNamespaceSendRequestByUserDistributionSegments(data []interface{}) []FriendNamespaceSendRequestByUserDistributionSegment {
	v := make([]FriendNamespaceSendRequestByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceSendRequestByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceSendRequestByUserDistributionSegmentsFromDict(data []FriendNamespaceSendRequestByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceSendRequestByUserDistribution struct {
	Statistics   *FriendNamespaceSendRequestByUserDistributionStatistics `json:"statistics"`
	Distribution []FriendNamespaceSendRequestByUserDistributionSegment   `json:"distribution"`
}

func (p *FriendNamespaceSendRequestByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceSendRequestByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceSendRequestByUserDistribution{}
	} else {
		*p = FriendNamespaceSendRequestByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFriendNamespaceSendRequestByUserDistributionFromJson(data string) FriendNamespaceSendRequestByUserDistribution {
	req := FriendNamespaceSendRequestByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceSendRequestByUserDistributionFromDict(data map[string]interface{}) FriendNamespaceSendRequestByUserDistribution {
	return FriendNamespaceSendRequestByUserDistribution{
		Statistics: func() *FriendNamespaceSendRequestByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFriendNamespaceSendRequestByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FriendNamespaceSendRequestByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFriendNamespaceSendRequestByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FriendNamespaceSendRequestByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFriendNamespaceSendRequestByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FriendNamespaceSendRequestByUserDistribution) Pointer() *FriendNamespaceSendRequestByUserDistribution {
	return &p
}

func CastFriendNamespaceSendRequestByUserDistributions(data []interface{}) []FriendNamespaceSendRequestByUserDistribution {
	v := make([]FriendNamespaceSendRequestByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceSendRequestByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceSendRequestByUserDistributionsFromDict(data []FriendNamespaceSendRequestByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceNewFollowByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *FriendNamespaceNewFollowByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceNewFollowByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceNewFollowByUserDistributionStatistics{}
	} else {
		*p = FriendNamespaceNewFollowByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewFriendNamespaceNewFollowByUserDistributionStatisticsFromJson(data string) FriendNamespaceNewFollowByUserDistributionStatistics {
	req := FriendNamespaceNewFollowByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceNewFollowByUserDistributionStatisticsFromDict(data map[string]interface{}) FriendNamespaceNewFollowByUserDistributionStatistics {
	return FriendNamespaceNewFollowByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p FriendNamespaceNewFollowByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p FriendNamespaceNewFollowByUserDistributionStatistics) Pointer() *FriendNamespaceNewFollowByUserDistributionStatistics {
	return &p
}

func CastFriendNamespaceNewFollowByUserDistributionStatisticses(data []interface{}) []FriendNamespaceNewFollowByUserDistributionStatistics {
	v := make([]FriendNamespaceNewFollowByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceNewFollowByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceNewFollowByUserDistributionStatisticsesFromDict(data []FriendNamespaceNewFollowByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceNewFollowByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *FriendNamespaceNewFollowByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceNewFollowByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceNewFollowByUserDistributionSegment{}
	} else {
		*p = FriendNamespaceNewFollowByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewFriendNamespaceNewFollowByUserDistributionSegmentFromJson(data string) FriendNamespaceNewFollowByUserDistributionSegment {
	req := FriendNamespaceNewFollowByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceNewFollowByUserDistributionSegmentFromDict(data map[string]interface{}) FriendNamespaceNewFollowByUserDistributionSegment {
	return FriendNamespaceNewFollowByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p FriendNamespaceNewFollowByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p FriendNamespaceNewFollowByUserDistributionSegment) Pointer() *FriendNamespaceNewFollowByUserDistributionSegment {
	return &p
}

func CastFriendNamespaceNewFollowByUserDistributionSegments(data []interface{}) []FriendNamespaceNewFollowByUserDistributionSegment {
	v := make([]FriendNamespaceNewFollowByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceNewFollowByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceNewFollowByUserDistributionSegmentsFromDict(data []FriendNamespaceNewFollowByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceNewFollowByUserDistribution struct {
	Statistics   *FriendNamespaceNewFollowByUserDistributionStatistics `json:"statistics"`
	Distribution []FriendNamespaceNewFollowByUserDistributionSegment   `json:"distribution"`
}

func (p *FriendNamespaceNewFollowByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceNewFollowByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceNewFollowByUserDistribution{}
	} else {
		*p = FriendNamespaceNewFollowByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewFriendNamespaceNewFollowByUserDistributionFromJson(data string) FriendNamespaceNewFollowByUserDistribution {
	req := FriendNamespaceNewFollowByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceNewFollowByUserDistributionFromDict(data map[string]interface{}) FriendNamespaceNewFollowByUserDistribution {
	return FriendNamespaceNewFollowByUserDistribution{
		Statistics: func() *FriendNamespaceNewFollowByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFriendNamespaceNewFollowByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []FriendNamespaceNewFollowByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastFriendNamespaceNewFollowByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p FriendNamespaceNewFollowByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastFriendNamespaceNewFollowByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p FriendNamespaceNewFollowByUserDistribution) Pointer() *FriendNamespaceNewFollowByUserDistribution {
	return &p
}

func CastFriendNamespaceNewFollowByUserDistributions(data []interface{}) []FriendNamespaceNewFollowByUserDistribution {
	v := make([]FriendNamespaceNewFollowByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceNewFollowByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceNewFollowByUserDistributionsFromDict(data []FriendNamespaceNewFollowByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespaceDistributions struct {
	AcceptByUser      *FriendNamespaceAcceptByUserDistribution      `json:"acceptByUser"`
	RejectByUser      *FriendNamespaceRejectByUserDistribution      `json:"rejectByUser"`
	SendRequestByUser *FriendNamespaceSendRequestByUserDistribution `json:"sendRequestByUser"`
	NewFollowByUser   *FriendNamespaceNewFollowByUserDistribution   `json:"newFollowByUser"`
}

func (p *FriendNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespaceDistributions{}
	} else {
		*p = FriendNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["acceptByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AcceptByUser)
		}
		if v, ok := d["rejectByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RejectByUser)
		}
		if v, ok := d["sendRequestByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SendRequestByUser)
		}
		if v, ok := d["newFollowByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.NewFollowByUser)
		}
	}
	return nil
}

func NewFriendNamespaceDistributionsFromJson(data string) FriendNamespaceDistributions {
	req := FriendNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceDistributionsFromDict(data map[string]interface{}) FriendNamespaceDistributions {
	return FriendNamespaceDistributions{
		AcceptByUser: func() *FriendNamespaceAcceptByUserDistribution {
			v, ok := data["acceptByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewFriendNamespaceAcceptByUserDistributionFromDict(core.CastMap(data["acceptByUser"])).Pointer()
		}(),
		RejectByUser: func() *FriendNamespaceRejectByUserDistribution {
			v, ok := data["rejectByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewFriendNamespaceRejectByUserDistributionFromDict(core.CastMap(data["rejectByUser"])).Pointer()
		}(),
		SendRequestByUser: func() *FriendNamespaceSendRequestByUserDistribution {
			v, ok := data["sendRequestByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewFriendNamespaceSendRequestByUserDistributionFromDict(core.CastMap(data["sendRequestByUser"])).Pointer()
		}(),
		NewFollowByUser: func() *FriendNamespaceNewFollowByUserDistribution {
			v, ok := data["newFollowByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewFriendNamespaceNewFollowByUserDistributionFromDict(core.CastMap(data["newFollowByUser"])).Pointer()
		}(),
	}
}

func (p FriendNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.AcceptByUser != nil {
		m["acceptByUser"] = func() map[string]interface{} {
			if p.AcceptByUser == nil {
				return nil
			}
			return p.AcceptByUser.ToDict()
		}()
	}
	if p.RejectByUser != nil {
		m["rejectByUser"] = func() map[string]interface{} {
			if p.RejectByUser == nil {
				return nil
			}
			return p.RejectByUser.ToDict()
		}()
	}
	if p.SendRequestByUser != nil {
		m["sendRequestByUser"] = func() map[string]interface{} {
			if p.SendRequestByUser == nil {
				return nil
			}
			return p.SendRequestByUser.ToDict()
		}()
	}
	if p.NewFollowByUser != nil {
		m["newFollowByUser"] = func() map[string]interface{} {
			if p.NewFollowByUser == nil {
				return nil
			}
			return p.NewFollowByUser.ToDict()
		}()
	}
	return m
}

func (p FriendNamespaceDistributions) Pointer() *FriendNamespaceDistributions {
	return &p
}

func CastFriendNamespaceDistributionses(data []interface{}) []FriendNamespaceDistributions {
	v := make([]FriendNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespaceDistributionsesFromDict(data []FriendNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type FriendNamespace struct {
	NamespaceId   *string                       `json:"namespaceId"`
	Year          *int32                        `json:"year"`
	Month         *int32                        `json:"month"`
	Day           *int32                        `json:"day"`
	NamespaceName *string                       `json:"namespaceName"`
	Statistics    *FriendNamespaceStatistics    `json:"statistics"`
	Distributions *FriendNamespaceDistributions `json:"distributions"`
}

func (p *FriendNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = FriendNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = FriendNamespace{}
	} else {
		*p = FriendNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewFriendNamespaceFromJson(data string) FriendNamespace {
	req := FriendNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewFriendNamespaceFromDict(data map[string]interface{}) FriendNamespace {
	return FriendNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *FriendNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewFriendNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *FriendNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewFriendNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p FriendNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p FriendNamespace) Pointer() *FriendNamespace {
	return &p
}

func CastFriendNamespaces(data []interface{}) []FriendNamespace {
	v := make([]FriendNamespace, 0)
	for _, d := range data {
		v = append(v, NewFriendNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastFriendNamespacesFromDict(data []FriendNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceStatistics struct {
	Sent     *int64   `json:"sent"`
	Open     *int64   `json:"open"`
	OpenRate *float32 `json:"openRate"`
}

func (p *InboxNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceStatistics{}
	} else {
		*p = InboxNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["sent"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sent)
		}
		if v, ok := d["open"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Open)
		}
		if v, ok := d["openRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.OpenRate)
		}
	}
	return nil
}

func NewInboxNamespaceStatisticsFromJson(data string) InboxNamespaceStatistics {
	req := InboxNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceStatisticsFromDict(data map[string]interface{}) InboxNamespaceStatistics {
	return InboxNamespaceStatistics{
		Sent: func() *int64 {
			v, ok := data["sent"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sent"])
		}(),
		Open: func() *int64 {
			v, ok := data["open"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["open"])
		}(),
		OpenRate: func() *float32 {
			v, ok := data["openRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["openRate"])
		}(),
	}
}

func (p InboxNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Sent != nil {
		m["sent"] = p.Sent
	}
	if p.Open != nil {
		m["open"] = p.Open
	}
	if p.OpenRate != nil {
		m["openRate"] = p.OpenRate
	}
	return m
}

func (p InboxNamespaceStatistics) Pointer() *InboxNamespaceStatistics {
	return &p
}

func CastInboxNamespaceStatisticses(data []interface{}) []InboxNamespaceStatistics {
	v := make([]InboxNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceStatisticsesFromDict(data []InboxNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceSendByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InboxNamespaceSendByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceSendByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceSendByUserDistributionStatistics{}
	} else {
		*p = InboxNamespaceSendByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInboxNamespaceSendByUserDistributionStatisticsFromJson(data string) InboxNamespaceSendByUserDistributionStatistics {
	req := InboxNamespaceSendByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceSendByUserDistributionStatisticsFromDict(data map[string]interface{}) InboxNamespaceSendByUserDistributionStatistics {
	return InboxNamespaceSendByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InboxNamespaceSendByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InboxNamespaceSendByUserDistributionStatistics) Pointer() *InboxNamespaceSendByUserDistributionStatistics {
	return &p
}

func CastInboxNamespaceSendByUserDistributionStatisticses(data []interface{}) []InboxNamespaceSendByUserDistributionStatistics {
	v := make([]InboxNamespaceSendByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceSendByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceSendByUserDistributionStatisticsesFromDict(data []InboxNamespaceSendByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceSendByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *InboxNamespaceSendByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceSendByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceSendByUserDistributionSegment{}
	} else {
		*p = InboxNamespaceSendByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInboxNamespaceSendByUserDistributionSegmentFromJson(data string) InboxNamespaceSendByUserDistributionSegment {
	req := InboxNamespaceSendByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceSendByUserDistributionSegmentFromDict(data map[string]interface{}) InboxNamespaceSendByUserDistributionSegment {
	return InboxNamespaceSendByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p InboxNamespaceSendByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p InboxNamespaceSendByUserDistributionSegment) Pointer() *InboxNamespaceSendByUserDistributionSegment {
	return &p
}

func CastInboxNamespaceSendByUserDistributionSegments(data []interface{}) []InboxNamespaceSendByUserDistributionSegment {
	v := make([]InboxNamespaceSendByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceSendByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceSendByUserDistributionSegmentsFromDict(data []InboxNamespaceSendByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceSendByUserDistribution struct {
	Statistics   *InboxNamespaceSendByUserDistributionStatistics `json:"statistics"`
	Distribution []InboxNamespaceSendByUserDistributionSegment   `json:"distribution"`
}

func (p *InboxNamespaceSendByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceSendByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceSendByUserDistribution{}
	} else {
		*p = InboxNamespaceSendByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInboxNamespaceSendByUserDistributionFromJson(data string) InboxNamespaceSendByUserDistribution {
	req := InboxNamespaceSendByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceSendByUserDistributionFromDict(data map[string]interface{}) InboxNamespaceSendByUserDistribution {
	return InboxNamespaceSendByUserDistribution{
		Statistics: func() *InboxNamespaceSendByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInboxNamespaceSendByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InboxNamespaceSendByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInboxNamespaceSendByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InboxNamespaceSendByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInboxNamespaceSendByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InboxNamespaceSendByUserDistribution) Pointer() *InboxNamespaceSendByUserDistribution {
	return &p
}

func CastInboxNamespaceSendByUserDistributions(data []interface{}) []InboxNamespaceSendByUserDistribution {
	v := make([]InboxNamespaceSendByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceSendByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceSendByUserDistributionsFromDict(data []InboxNamespaceSendByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceReadElapsedMinutesDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InboxNamespaceReadElapsedMinutesDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceReadElapsedMinutesDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceReadElapsedMinutesDistributionStatistics{}
	} else {
		*p = InboxNamespaceReadElapsedMinutesDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInboxNamespaceReadElapsedMinutesDistributionStatisticsFromJson(data string) InboxNamespaceReadElapsedMinutesDistributionStatistics {
	req := InboxNamespaceReadElapsedMinutesDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceReadElapsedMinutesDistributionStatisticsFromDict(data map[string]interface{}) InboxNamespaceReadElapsedMinutesDistributionStatistics {
	return InboxNamespaceReadElapsedMinutesDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InboxNamespaceReadElapsedMinutesDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InboxNamespaceReadElapsedMinutesDistributionStatistics) Pointer() *InboxNamespaceReadElapsedMinutesDistributionStatistics {
	return &p
}

func CastInboxNamespaceReadElapsedMinutesDistributionStatisticses(data []interface{}) []InboxNamespaceReadElapsedMinutesDistributionStatistics {
	v := make([]InboxNamespaceReadElapsedMinutesDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceReadElapsedMinutesDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceReadElapsedMinutesDistributionStatisticsesFromDict(data []InboxNamespaceReadElapsedMinutesDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceReadElapsedMinutesDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *InboxNamespaceReadElapsedMinutesDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceReadElapsedMinutesDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceReadElapsedMinutesDistributionSegment{}
	} else {
		*p = InboxNamespaceReadElapsedMinutesDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInboxNamespaceReadElapsedMinutesDistributionSegmentFromJson(data string) InboxNamespaceReadElapsedMinutesDistributionSegment {
	req := InboxNamespaceReadElapsedMinutesDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceReadElapsedMinutesDistributionSegmentFromDict(data map[string]interface{}) InboxNamespaceReadElapsedMinutesDistributionSegment {
	return InboxNamespaceReadElapsedMinutesDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p InboxNamespaceReadElapsedMinutesDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p InboxNamespaceReadElapsedMinutesDistributionSegment) Pointer() *InboxNamespaceReadElapsedMinutesDistributionSegment {
	return &p
}

func CastInboxNamespaceReadElapsedMinutesDistributionSegments(data []interface{}) []InboxNamespaceReadElapsedMinutesDistributionSegment {
	v := make([]InboxNamespaceReadElapsedMinutesDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceReadElapsedMinutesDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceReadElapsedMinutesDistributionSegmentsFromDict(data []InboxNamespaceReadElapsedMinutesDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceReadElapsedMinutesDistribution struct {
	Statistics   *InboxNamespaceReadElapsedMinutesDistributionStatistics `json:"statistics"`
	Distribution []InboxNamespaceReadElapsedMinutesDistributionSegment   `json:"distribution"`
}

func (p *InboxNamespaceReadElapsedMinutesDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceReadElapsedMinutesDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceReadElapsedMinutesDistribution{}
	} else {
		*p = InboxNamespaceReadElapsedMinutesDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInboxNamespaceReadElapsedMinutesDistributionFromJson(data string) InboxNamespaceReadElapsedMinutesDistribution {
	req := InboxNamespaceReadElapsedMinutesDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceReadElapsedMinutesDistributionFromDict(data map[string]interface{}) InboxNamespaceReadElapsedMinutesDistribution {
	return InboxNamespaceReadElapsedMinutesDistribution{
		Statistics: func() *InboxNamespaceReadElapsedMinutesDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInboxNamespaceReadElapsedMinutesDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InboxNamespaceReadElapsedMinutesDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInboxNamespaceReadElapsedMinutesDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InboxNamespaceReadElapsedMinutesDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInboxNamespaceReadElapsedMinutesDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InboxNamespaceReadElapsedMinutesDistribution) Pointer() *InboxNamespaceReadElapsedMinutesDistribution {
	return &p
}

func CastInboxNamespaceReadElapsedMinutesDistributions(data []interface{}) []InboxNamespaceReadElapsedMinutesDistribution {
	v := make([]InboxNamespaceReadElapsedMinutesDistribution, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceReadElapsedMinutesDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceReadElapsedMinutesDistributionsFromDict(data []InboxNamespaceReadElapsedMinutesDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespaceDistributions struct {
	SendByUser         *InboxNamespaceSendByUserDistribution         `json:"sendByUser"`
	ReadElapsedMinutes *InboxNamespaceReadElapsedMinutesDistribution `json:"readElapsedMinutes"`
}

func (p *InboxNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespaceDistributions{}
	} else {
		*p = InboxNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["sendByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SendByUser)
		}
		if v, ok := d["readElapsedMinutes"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ReadElapsedMinutes)
		}
	}
	return nil
}

func NewInboxNamespaceDistributionsFromJson(data string) InboxNamespaceDistributions {
	req := InboxNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceDistributionsFromDict(data map[string]interface{}) InboxNamespaceDistributions {
	return InboxNamespaceDistributions{
		SendByUser: func() *InboxNamespaceSendByUserDistribution {
			v, ok := data["sendByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewInboxNamespaceSendByUserDistributionFromDict(core.CastMap(data["sendByUser"])).Pointer()
		}(),
		ReadElapsedMinutes: func() *InboxNamespaceReadElapsedMinutesDistribution {
			v, ok := data["readElapsedMinutes"]
			if !ok || v == nil {
				return nil
			}
			return NewInboxNamespaceReadElapsedMinutesDistributionFromDict(core.CastMap(data["readElapsedMinutes"])).Pointer()
		}(),
	}
}

func (p InboxNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.SendByUser != nil {
		m["sendByUser"] = func() map[string]interface{} {
			if p.SendByUser == nil {
				return nil
			}
			return p.SendByUser.ToDict()
		}()
	}
	if p.ReadElapsedMinutes != nil {
		m["readElapsedMinutes"] = func() map[string]interface{} {
			if p.ReadElapsedMinutes == nil {
				return nil
			}
			return p.ReadElapsedMinutes.ToDict()
		}()
	}
	return m
}

func (p InboxNamespaceDistributions) Pointer() *InboxNamespaceDistributions {
	return &p
}

func CastInboxNamespaceDistributionses(data []interface{}) []InboxNamespaceDistributions {
	v := make([]InboxNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespaceDistributionsesFromDict(data []InboxNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InboxNamespace struct {
	NamespaceId   *string                      `json:"namespaceId"`
	Year          *int32                       `json:"year"`
	Month         *int32                       `json:"month"`
	Day           *int32                       `json:"day"`
	NamespaceName *string                      `json:"namespaceName"`
	Statistics    *InboxNamespaceStatistics    `json:"statistics"`
	Distributions *InboxNamespaceDistributions `json:"distributions"`
}

func (p *InboxNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InboxNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InboxNamespace{}
	} else {
		*p = InboxNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewInboxNamespaceFromJson(data string) InboxNamespace {
	req := InboxNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInboxNamespaceFromDict(data map[string]interface{}) InboxNamespace {
	return InboxNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *InboxNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInboxNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *InboxNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewInboxNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p InboxNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p InboxNamespace) Pointer() *InboxNamespace {
	return &p
}

func CastInboxNamespaces(data []interface{}) []InboxNamespace {
	v := make([]InboxNamespace, 0)
	for _, d := range data {
		v = append(v, NewInboxNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInboxNamespacesFromDict(data []InboxNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSetStatistics struct {
	Acquired       *int64   `json:"acquired"`
	AcquiredAmount *int64   `json:"acquiredAmount"`
	Consumed       *int64   `json:"consumed"`
	ConsumedAmount *int64   `json:"consumedAmount"`
	ConsumedRate   *float32 `json:"consumedRate"`
}

func (p *InventoryItemSetStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSetStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSetStatistics{}
	} else {
		*p = InventoryItemSetStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["acquired"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Acquired)
		}
		if v, ok := d["acquiredAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AcquiredAmount)
		}
		if v, ok := d["consumed"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consumed)
		}
		if v, ok := d["consumedAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ConsumedAmount)
		}
		if v, ok := d["consumedRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ConsumedRate)
		}
	}
	return nil
}

func NewInventoryItemSetStatisticsFromJson(data string) InventoryItemSetStatistics {
	req := InventoryItemSetStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetStatisticsFromDict(data map[string]interface{}) InventoryItemSetStatistics {
	return InventoryItemSetStatistics{
		Acquired: func() *int64 {
			v, ok := data["acquired"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["acquired"])
		}(),
		AcquiredAmount: func() *int64 {
			v, ok := data["acquiredAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["acquiredAmount"])
		}(),
		Consumed: func() *int64 {
			v, ok := data["consumed"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["consumed"])
		}(),
		ConsumedAmount: func() *int64 {
			v, ok := data["consumedAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["consumedAmount"])
		}(),
		ConsumedRate: func() *float32 {
			v, ok := data["consumedRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["consumedRate"])
		}(),
	}
}

func (p InventoryItemSetStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Acquired != nil {
		m["acquired"] = p.Acquired
	}
	if p.AcquiredAmount != nil {
		m["acquiredAmount"] = p.AcquiredAmount
	}
	if p.Consumed != nil {
		m["consumed"] = p.Consumed
	}
	if p.ConsumedAmount != nil {
		m["consumedAmount"] = p.ConsumedAmount
	}
	if p.ConsumedRate != nil {
		m["consumedRate"] = p.ConsumedRate
	}
	return m
}

func (p InventoryItemSetStatistics) Pointer() *InventoryItemSetStatistics {
	return &p
}

func CastInventoryItemSetStatisticses(data []interface{}) []InventoryItemSetStatistics {
	v := make([]InventoryItemSetStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetStatisticsesFromDict(data []InventoryItemSetStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSetCountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryItemSetCountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSetCountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSetCountDistributionStatistics{}
	} else {
		*p = InventoryItemSetCountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryItemSetCountDistributionStatisticsFromJson(data string) InventoryItemSetCountDistributionStatistics {
	req := InventoryItemSetCountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetCountDistributionStatisticsFromDict(data map[string]interface{}) InventoryItemSetCountDistributionStatistics {
	return InventoryItemSetCountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryItemSetCountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryItemSetCountDistributionStatistics) Pointer() *InventoryItemSetCountDistributionStatistics {
	return &p
}

func CastInventoryItemSetCountDistributionStatisticses(data []interface{}) []InventoryItemSetCountDistributionStatistics {
	v := make([]InventoryItemSetCountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetCountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetCountDistributionStatisticsesFromDict(data []InventoryItemSetCountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSetCountDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *InventoryItemSetCountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSetCountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSetCountDistributionSegment{}
	} else {
		*p = InventoryItemSetCountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryItemSetCountDistributionSegmentFromJson(data string) InventoryItemSetCountDistributionSegment {
	req := InventoryItemSetCountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetCountDistributionSegmentFromDict(data map[string]interface{}) InventoryItemSetCountDistributionSegment {
	return InventoryItemSetCountDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p InventoryItemSetCountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p InventoryItemSetCountDistributionSegment) Pointer() *InventoryItemSetCountDistributionSegment {
	return &p
}

func CastInventoryItemSetCountDistributionSegments(data []interface{}) []InventoryItemSetCountDistributionSegment {
	v := make([]InventoryItemSetCountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetCountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetCountDistributionSegmentsFromDict(data []InventoryItemSetCountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSetCountDistribution struct {
	Statistics   *InventoryItemSetCountDistributionStatistics `json:"statistics"`
	Distribution []InventoryItemSetCountDistributionSegment   `json:"distribution"`
}

func (p *InventoryItemSetCountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSetCountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSetCountDistribution{}
	} else {
		*p = InventoryItemSetCountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryItemSetCountDistributionFromJson(data string) InventoryItemSetCountDistribution {
	req := InventoryItemSetCountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetCountDistributionFromDict(data map[string]interface{}) InventoryItemSetCountDistribution {
	return InventoryItemSetCountDistribution{
		Statistics: func() *InventoryItemSetCountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryItemSetCountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryItemSetCountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryItemSetCountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryItemSetCountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryItemSetCountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryItemSetCountDistribution) Pointer() *InventoryItemSetCountDistribution {
	return &p
}

func CastInventoryItemSetCountDistributions(data []interface{}) []InventoryItemSetCountDistribution {
	v := make([]InventoryItemSetCountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetCountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetCountDistributionsFromDict(data []InventoryItemSetCountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSetDistributions struct {
	Count *InventoryItemSetCountDistribution `json:"count"`
}

func (p *InventoryItemSetDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSetDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSetDistributions{}
	} else {
		*p = InventoryItemSetDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryItemSetDistributionsFromJson(data string) InventoryItemSetDistributions {
	req := InventoryItemSetDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetDistributionsFromDict(data map[string]interface{}) InventoryItemSetDistributions {
	return InventoryItemSetDistributions{
		Count: func() *InventoryItemSetCountDistribution {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryItemSetCountDistributionFromDict(core.CastMap(data["count"])).Pointer()
		}(),
	}
}

func (p InventoryItemSetDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = func() map[string]interface{} {
			if p.Count == nil {
				return nil
			}
			return p.Count.ToDict()
		}()
	}
	return m
}

func (p InventoryItemSetDistributions) Pointer() *InventoryItemSetDistributions {
	return &p
}

func CastInventoryItemSetDistributionses(data []interface{}) []InventoryItemSetDistributions {
	v := make([]InventoryItemSetDistributions, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetDistributionsesFromDict(data []InventoryItemSetDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryItemSet struct {
	ItemSetId     *string                        `json:"itemSetId"`
	ItemName      *string                        `json:"itemName"`
	ItemSetName   *string                        `json:"itemSetName"`
	Statistics    *InventoryItemSetStatistics    `json:"statistics"`
	Distributions *InventoryItemSetDistributions `json:"distributions"`
}

func (p *InventoryItemSet) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryItemSet{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryItemSet{}
	} else {
		*p = InventoryItemSet{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["itemSetId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemSetId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemSetId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemSetId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemSetId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemSetId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemSetId)
				}
			}
		}
		if v, ok := d["itemName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemName)
				}
			}
		}
		if v, ok := d["itemSetName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemSetName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemSetName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemSetName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemSetName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemSetName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemSetName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewInventoryItemSetFromJson(data string) InventoryItemSet {
	req := InventoryItemSet{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryItemSetFromDict(data map[string]interface{}) InventoryItemSet {
	return InventoryItemSet{
		ItemSetId: func() *string {
			v, ok := data["itemSetId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["itemSetId"])
		}(),
		ItemName: func() *string {
			v, ok := data["itemName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["itemName"])
		}(),
		ItemSetName: func() *string {
			v, ok := data["itemSetName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["itemSetName"])
		}(),
		Statistics: func() *InventoryItemSetStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryItemSetStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *InventoryItemSetDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryItemSetDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p InventoryItemSet) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ItemSetId != nil {
		m["itemSetId"] = p.ItemSetId
	}
	if p.ItemName != nil {
		m["itemName"] = p.ItemName
	}
	if p.ItemSetName != nil {
		m["itemSetName"] = p.ItemSetName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p InventoryItemSet) Pointer() *InventoryItemSet {
	return &p
}

func CastInventoryItemSets(data []interface{}) []InventoryItemSet {
	v := make([]InventoryItemSet, 0)
	for _, d := range data {
		v = append(v, NewInventoryItemSetFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryItemSetsFromDict(data []InventoryItemSet) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryStatistics struct {
	Acquired               *int64 `json:"acquired"`
	Consume                *int64 `json:"consume"`
	IncreaseCapacity       *int64 `json:"increaseCapacity"`
	IncreaseCapacityAmount *int64 `json:"increaseCapacityAmount"`
}

func (p *InventoryInventoryStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryStatistics{}
	} else {
		*p = InventoryInventoryStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["acquired"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Acquired)
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["increaseCapacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacity)
		}
		if v, ok := d["increaseCapacityAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacityAmount)
		}
	}
	return nil
}

func NewInventoryInventoryStatisticsFromJson(data string) InventoryInventoryStatistics {
	req := InventoryInventoryStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryStatisticsFromDict(data map[string]interface{}) InventoryInventoryStatistics {
	return InventoryInventoryStatistics{
		Acquired: func() *int64 {
			v, ok := data["acquired"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["acquired"])
		}(),
		Consume: func() *int64 {
			v, ok := data["consume"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["consume"])
		}(),
		IncreaseCapacity: func() *int64 {
			v, ok := data["increaseCapacity"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increaseCapacity"])
		}(),
		IncreaseCapacityAmount: func() *int64 {
			v, ok := data["increaseCapacityAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increaseCapacityAmount"])
		}(),
	}
}

func (p InventoryInventoryStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Acquired != nil {
		m["acquired"] = p.Acquired
	}
	if p.Consume != nil {
		m["consume"] = p.Consume
	}
	if p.IncreaseCapacity != nil {
		m["increaseCapacity"] = p.IncreaseCapacity
	}
	if p.IncreaseCapacityAmount != nil {
		m["increaseCapacityAmount"] = p.IncreaseCapacityAmount
	}
	return m
}

func (p InventoryInventoryStatistics) Pointer() *InventoryInventoryStatistics {
	return &p
}

func CastInventoryInventoryStatisticses(data []interface{}) []InventoryInventoryStatistics {
	v := make([]InventoryInventoryStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryStatisticsesFromDict(data []InventoryInventoryStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryCapacityDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryInventoryCapacityDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryCapacityDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryCapacityDistributionStatistics{}
	} else {
		*p = InventoryInventoryCapacityDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryInventoryCapacityDistributionStatisticsFromJson(data string) InventoryInventoryCapacityDistributionStatistics {
	req := InventoryInventoryCapacityDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryCapacityDistributionStatisticsFromDict(data map[string]interface{}) InventoryInventoryCapacityDistributionStatistics {
	return InventoryInventoryCapacityDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryInventoryCapacityDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryInventoryCapacityDistributionStatistics) Pointer() *InventoryInventoryCapacityDistributionStatistics {
	return &p
}

func CastInventoryInventoryCapacityDistributionStatisticses(data []interface{}) []InventoryInventoryCapacityDistributionStatistics {
	v := make([]InventoryInventoryCapacityDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryCapacityDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryCapacityDistributionStatisticsesFromDict(data []InventoryInventoryCapacityDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryCapacityDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *InventoryInventoryCapacityDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryCapacityDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryCapacityDistributionSegment{}
	} else {
		*p = InventoryInventoryCapacityDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryInventoryCapacityDistributionSegmentFromJson(data string) InventoryInventoryCapacityDistributionSegment {
	req := InventoryInventoryCapacityDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryCapacityDistributionSegmentFromDict(data map[string]interface{}) InventoryInventoryCapacityDistributionSegment {
	return InventoryInventoryCapacityDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p InventoryInventoryCapacityDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p InventoryInventoryCapacityDistributionSegment) Pointer() *InventoryInventoryCapacityDistributionSegment {
	return &p
}

func CastInventoryInventoryCapacityDistributionSegments(data []interface{}) []InventoryInventoryCapacityDistributionSegment {
	v := make([]InventoryInventoryCapacityDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryCapacityDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryCapacityDistributionSegmentsFromDict(data []InventoryInventoryCapacityDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryCapacityDistribution struct {
	Statistics   *InventoryInventoryCapacityDistributionStatistics `json:"statistics"`
	Distribution []InventoryInventoryCapacityDistributionSegment   `json:"distribution"`
}

func (p *InventoryInventoryCapacityDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryCapacityDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryCapacityDistribution{}
	} else {
		*p = InventoryInventoryCapacityDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryInventoryCapacityDistributionFromJson(data string) InventoryInventoryCapacityDistribution {
	req := InventoryInventoryCapacityDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryCapacityDistributionFromDict(data map[string]interface{}) InventoryInventoryCapacityDistribution {
	return InventoryInventoryCapacityDistribution{
		Statistics: func() *InventoryInventoryCapacityDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryCapacityDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryInventoryCapacityDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryInventoryCapacityDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryInventoryCapacityDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryInventoryCapacityDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryInventoryCapacityDistribution) Pointer() *InventoryInventoryCapacityDistribution {
	return &p
}

func CastInventoryInventoryCapacityDistributions(data []interface{}) []InventoryInventoryCapacityDistribution {
	v := make([]InventoryInventoryCapacityDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryCapacityDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryCapacityDistributionsFromDict(data []InventoryInventoryCapacityDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryInventoryAcquireDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireDistributionStatistics{}
	} else {
		*p = InventoryInventoryAcquireDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireDistributionStatisticsFromJson(data string) InventoryInventoryAcquireDistributionStatistics {
	req := InventoryInventoryAcquireDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireDistributionStatisticsFromDict(data map[string]interface{}) InventoryInventoryAcquireDistributionStatistics {
	return InventoryInventoryAcquireDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryInventoryAcquireDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryInventoryAcquireDistributionStatistics) Pointer() *InventoryInventoryAcquireDistributionStatistics {
	return &p
}

func CastInventoryInventoryAcquireDistributionStatisticses(data []interface{}) []InventoryInventoryAcquireDistributionStatistics {
	v := make([]InventoryInventoryAcquireDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireDistributionStatisticsesFromDict(data []InventoryInventoryAcquireDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireDistributionSegment struct {
	ItemName *string `json:"itemName"`
	Count    *int64  `json:"count"`
}

func (p *InventoryInventoryAcquireDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireDistributionSegment{}
	} else {
		*p = InventoryInventoryAcquireDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["itemName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireDistributionSegmentFromJson(data string) InventoryInventoryAcquireDistributionSegment {
	req := InventoryInventoryAcquireDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireDistributionSegmentFromDict(data map[string]interface{}) InventoryInventoryAcquireDistributionSegment {
	return InventoryInventoryAcquireDistributionSegment{
		ItemName: func() *string {
			v, ok := data["itemName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["itemName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p InventoryInventoryAcquireDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ItemName != nil {
		m["itemName"] = p.ItemName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p InventoryInventoryAcquireDistributionSegment) Pointer() *InventoryInventoryAcquireDistributionSegment {
	return &p
}

func CastInventoryInventoryAcquireDistributionSegments(data []interface{}) []InventoryInventoryAcquireDistributionSegment {
	v := make([]InventoryInventoryAcquireDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireDistributionSegmentsFromDict(data []InventoryInventoryAcquireDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireDistribution struct {
	Statistics   *InventoryInventoryAcquireDistributionStatistics `json:"statistics"`
	Distribution []InventoryInventoryAcquireDistributionSegment   `json:"distribution"`
}

func (p *InventoryInventoryAcquireDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireDistribution{}
	} else {
		*p = InventoryInventoryAcquireDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireDistributionFromJson(data string) InventoryInventoryAcquireDistribution {
	req := InventoryInventoryAcquireDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireDistributionFromDict(data map[string]interface{}) InventoryInventoryAcquireDistribution {
	return InventoryInventoryAcquireDistribution{
		Statistics: func() *InventoryInventoryAcquireDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryAcquireDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryInventoryAcquireDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryInventoryAcquireDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryInventoryAcquireDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryInventoryAcquireDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryInventoryAcquireDistribution) Pointer() *InventoryInventoryAcquireDistribution {
	return &p
}

func CastInventoryInventoryAcquireDistributions(data []interface{}) []InventoryInventoryAcquireDistribution {
	v := make([]InventoryInventoryAcquireDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireDistributionsFromDict(data []InventoryInventoryAcquireDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryInventoryAcquireAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireAmountDistributionStatistics{}
	} else {
		*p = InventoryInventoryAcquireAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireAmountDistributionStatisticsFromJson(data string) InventoryInventoryAcquireAmountDistributionStatistics {
	req := InventoryInventoryAcquireAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireAmountDistributionStatisticsFromDict(data map[string]interface{}) InventoryInventoryAcquireAmountDistributionStatistics {
	return InventoryInventoryAcquireAmountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryInventoryAcquireAmountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryInventoryAcquireAmountDistributionStatistics) Pointer() *InventoryInventoryAcquireAmountDistributionStatistics {
	return &p
}

func CastInventoryInventoryAcquireAmountDistributionStatisticses(data []interface{}) []InventoryInventoryAcquireAmountDistributionStatistics {
	v := make([]InventoryInventoryAcquireAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireAmountDistributionStatisticsesFromDict(data []InventoryInventoryAcquireAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireAmountDistributionSegment struct {
	ItemName *string `json:"itemName"`
	Sum      *int64  `json:"sum"`
}

func (p *InventoryInventoryAcquireAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireAmountDistributionSegment{}
	} else {
		*p = InventoryInventoryAcquireAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["itemName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireAmountDistributionSegmentFromJson(data string) InventoryInventoryAcquireAmountDistributionSegment {
	req := InventoryInventoryAcquireAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireAmountDistributionSegmentFromDict(data map[string]interface{}) InventoryInventoryAcquireAmountDistributionSegment {
	return InventoryInventoryAcquireAmountDistributionSegment{
		ItemName: func() *string {
			v, ok := data["itemName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["itemName"])
		}(),
		Sum: func() *int64 {
			v, ok := data["sum"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sum"])
		}(),
	}
}

func (p InventoryInventoryAcquireAmountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ItemName != nil {
		m["itemName"] = p.ItemName
	}
	if p.Sum != nil {
		m["sum"] = p.Sum
	}
	return m
}

func (p InventoryInventoryAcquireAmountDistributionSegment) Pointer() *InventoryInventoryAcquireAmountDistributionSegment {
	return &p
}

func CastInventoryInventoryAcquireAmountDistributionSegments(data []interface{}) []InventoryInventoryAcquireAmountDistributionSegment {
	v := make([]InventoryInventoryAcquireAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireAmountDistributionSegmentsFromDict(data []InventoryInventoryAcquireAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryAcquireAmountDistribution struct {
	Statistics   *InventoryInventoryAcquireAmountDistributionStatistics `json:"statistics"`
	Distribution []InventoryInventoryAcquireAmountDistributionSegment   `json:"distribution"`
}

func (p *InventoryInventoryAcquireAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryAcquireAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryAcquireAmountDistribution{}
	} else {
		*p = InventoryInventoryAcquireAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryInventoryAcquireAmountDistributionFromJson(data string) InventoryInventoryAcquireAmountDistribution {
	req := InventoryInventoryAcquireAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryAcquireAmountDistributionFromDict(data map[string]interface{}) InventoryInventoryAcquireAmountDistribution {
	return InventoryInventoryAcquireAmountDistribution{
		Statistics: func() *InventoryInventoryAcquireAmountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryAcquireAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryInventoryAcquireAmountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryInventoryAcquireAmountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryInventoryAcquireAmountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryInventoryAcquireAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryInventoryAcquireAmountDistribution) Pointer() *InventoryInventoryAcquireAmountDistribution {
	return &p
}

func CastInventoryInventoryAcquireAmountDistributions(data []interface{}) []InventoryInventoryAcquireAmountDistribution {
	v := make([]InventoryInventoryAcquireAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryAcquireAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryAcquireAmountDistributionsFromDict(data []InventoryInventoryAcquireAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryInventoryConsumeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeDistributionStatistics{}
	} else {
		*p = InventoryInventoryConsumeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeDistributionStatisticsFromJson(data string) InventoryInventoryConsumeDistributionStatistics {
	req := InventoryInventoryConsumeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeDistributionStatisticsFromDict(data map[string]interface{}) InventoryInventoryConsumeDistributionStatistics {
	return InventoryInventoryConsumeDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryInventoryConsumeDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryInventoryConsumeDistributionStatistics) Pointer() *InventoryInventoryConsumeDistributionStatistics {
	return &p
}

func CastInventoryInventoryConsumeDistributionStatisticses(data []interface{}) []InventoryInventoryConsumeDistributionStatistics {
	v := make([]InventoryInventoryConsumeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeDistributionStatisticsesFromDict(data []InventoryInventoryConsumeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeDistributionSegment struct {
	ItemName *string `json:"itemName"`
	Count    *int64  `json:"count"`
}

func (p *InventoryInventoryConsumeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeDistributionSegment{}
	} else {
		*p = InventoryInventoryConsumeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["itemName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeDistributionSegmentFromJson(data string) InventoryInventoryConsumeDistributionSegment {
	req := InventoryInventoryConsumeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeDistributionSegmentFromDict(data map[string]interface{}) InventoryInventoryConsumeDistributionSegment {
	return InventoryInventoryConsumeDistributionSegment{
		ItemName: func() *string {
			v, ok := data["itemName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["itemName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p InventoryInventoryConsumeDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ItemName != nil {
		m["itemName"] = p.ItemName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p InventoryInventoryConsumeDistributionSegment) Pointer() *InventoryInventoryConsumeDistributionSegment {
	return &p
}

func CastInventoryInventoryConsumeDistributionSegments(data []interface{}) []InventoryInventoryConsumeDistributionSegment {
	v := make([]InventoryInventoryConsumeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeDistributionSegmentsFromDict(data []InventoryInventoryConsumeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeDistribution struct {
	Statistics   *InventoryInventoryConsumeDistributionStatistics `json:"statistics"`
	Distribution []InventoryInventoryConsumeDistributionSegment   `json:"distribution"`
}

func (p *InventoryInventoryConsumeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeDistribution{}
	} else {
		*p = InventoryInventoryConsumeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeDistributionFromJson(data string) InventoryInventoryConsumeDistribution {
	req := InventoryInventoryConsumeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeDistributionFromDict(data map[string]interface{}) InventoryInventoryConsumeDistribution {
	return InventoryInventoryConsumeDistribution{
		Statistics: func() *InventoryInventoryConsumeDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryConsumeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryInventoryConsumeDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryInventoryConsumeDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryInventoryConsumeDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryInventoryConsumeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryInventoryConsumeDistribution) Pointer() *InventoryInventoryConsumeDistribution {
	return &p
}

func CastInventoryInventoryConsumeDistributions(data []interface{}) []InventoryInventoryConsumeDistribution {
	v := make([]InventoryInventoryConsumeDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeDistributionsFromDict(data []InventoryInventoryConsumeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryInventoryConsumeAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeAmountDistributionStatistics{}
	} else {
		*p = InventoryInventoryConsumeAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeAmountDistributionStatisticsFromJson(data string) InventoryInventoryConsumeAmountDistributionStatistics {
	req := InventoryInventoryConsumeAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeAmountDistributionStatisticsFromDict(data map[string]interface{}) InventoryInventoryConsumeAmountDistributionStatistics {
	return InventoryInventoryConsumeAmountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryInventoryConsumeAmountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryInventoryConsumeAmountDistributionStatistics) Pointer() *InventoryInventoryConsumeAmountDistributionStatistics {
	return &p
}

func CastInventoryInventoryConsumeAmountDistributionStatisticses(data []interface{}) []InventoryInventoryConsumeAmountDistributionStatistics {
	v := make([]InventoryInventoryConsumeAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeAmountDistributionStatisticsesFromDict(data []InventoryInventoryConsumeAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeAmountDistributionSegment struct {
	ItemName *string `json:"itemName"`
	Sum      *int64  `json:"sum"`
}

func (p *InventoryInventoryConsumeAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeAmountDistributionSegment{}
	} else {
		*p = InventoryInventoryConsumeAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["itemName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ItemName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ItemName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ItemName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ItemName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ItemName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeAmountDistributionSegmentFromJson(data string) InventoryInventoryConsumeAmountDistributionSegment {
	req := InventoryInventoryConsumeAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeAmountDistributionSegmentFromDict(data map[string]interface{}) InventoryInventoryConsumeAmountDistributionSegment {
	return InventoryInventoryConsumeAmountDistributionSegment{
		ItemName: func() *string {
			v, ok := data["itemName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["itemName"])
		}(),
		Sum: func() *int64 {
			v, ok := data["sum"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sum"])
		}(),
	}
}

func (p InventoryInventoryConsumeAmountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ItemName != nil {
		m["itemName"] = p.ItemName
	}
	if p.Sum != nil {
		m["sum"] = p.Sum
	}
	return m
}

func (p InventoryInventoryConsumeAmountDistributionSegment) Pointer() *InventoryInventoryConsumeAmountDistributionSegment {
	return &p
}

func CastInventoryInventoryConsumeAmountDistributionSegments(data []interface{}) []InventoryInventoryConsumeAmountDistributionSegment {
	v := make([]InventoryInventoryConsumeAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeAmountDistributionSegmentsFromDict(data []InventoryInventoryConsumeAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryConsumeAmountDistribution struct {
	Statistics   *InventoryInventoryConsumeAmountDistributionStatistics `json:"statistics"`
	Distribution []InventoryInventoryConsumeAmountDistributionSegment   `json:"distribution"`
}

func (p *InventoryInventoryConsumeAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryConsumeAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryConsumeAmountDistribution{}
	} else {
		*p = InventoryInventoryConsumeAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryInventoryConsumeAmountDistributionFromJson(data string) InventoryInventoryConsumeAmountDistribution {
	req := InventoryInventoryConsumeAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryConsumeAmountDistributionFromDict(data map[string]interface{}) InventoryInventoryConsumeAmountDistribution {
	return InventoryInventoryConsumeAmountDistribution{
		Statistics: func() *InventoryInventoryConsumeAmountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryConsumeAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryInventoryConsumeAmountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryInventoryConsumeAmountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryInventoryConsumeAmountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryInventoryConsumeAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryInventoryConsumeAmountDistribution) Pointer() *InventoryInventoryConsumeAmountDistribution {
	return &p
}

func CastInventoryInventoryConsumeAmountDistributions(data []interface{}) []InventoryInventoryConsumeAmountDistribution {
	v := make([]InventoryInventoryConsumeAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryConsumeAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryConsumeAmountDistributionsFromDict(data []InventoryInventoryConsumeAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventoryDistributions struct {
	Capacity      *InventoryInventoryCapacityDistribution      `json:"capacity"`
	Acquire       *InventoryInventoryAcquireDistribution       `json:"acquire"`
	AcquireAmount *InventoryInventoryAcquireAmountDistribution `json:"acquireAmount"`
	Consume       *InventoryInventoryConsumeDistribution       `json:"consume"`
	ConsumeAmount *InventoryInventoryConsumeAmountDistribution `json:"consumeAmount"`
}

func (p *InventoryInventoryDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventoryDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventoryDistributions{}
	} else {
		*p = InventoryInventoryDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["capacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Capacity)
		}
		if v, ok := d["acquire"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Acquire)
		}
		if v, ok := d["acquireAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AcquireAmount)
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["consumeAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ConsumeAmount)
		}
	}
	return nil
}

func NewInventoryInventoryDistributionsFromJson(data string) InventoryInventoryDistributions {
	req := InventoryInventoryDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryDistributionsFromDict(data map[string]interface{}) InventoryInventoryDistributions {
	return InventoryInventoryDistributions{
		Capacity: func() *InventoryInventoryCapacityDistribution {
			v, ok := data["capacity"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryCapacityDistributionFromDict(core.CastMap(data["capacity"])).Pointer()
		}(),
		Acquire: func() *InventoryInventoryAcquireDistribution {
			v, ok := data["acquire"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryAcquireDistributionFromDict(core.CastMap(data["acquire"])).Pointer()
		}(),
		AcquireAmount: func() *InventoryInventoryAcquireAmountDistribution {
			v, ok := data["acquireAmount"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryAcquireAmountDistributionFromDict(core.CastMap(data["acquireAmount"])).Pointer()
		}(),
		Consume: func() *InventoryInventoryConsumeDistribution {
			v, ok := data["consume"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryConsumeDistributionFromDict(core.CastMap(data["consume"])).Pointer()
		}(),
		ConsumeAmount: func() *InventoryInventoryConsumeAmountDistribution {
			v, ok := data["consumeAmount"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryConsumeAmountDistributionFromDict(core.CastMap(data["consumeAmount"])).Pointer()
		}(),
	}
}

func (p InventoryInventoryDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Capacity != nil {
		m["capacity"] = func() map[string]interface{} {
			if p.Capacity == nil {
				return nil
			}
			return p.Capacity.ToDict()
		}()
	}
	if p.Acquire != nil {
		m["acquire"] = func() map[string]interface{} {
			if p.Acquire == nil {
				return nil
			}
			return p.Acquire.ToDict()
		}()
	}
	if p.AcquireAmount != nil {
		m["acquireAmount"] = func() map[string]interface{} {
			if p.AcquireAmount == nil {
				return nil
			}
			return p.AcquireAmount.ToDict()
		}()
	}
	if p.Consume != nil {
		m["consume"] = func() map[string]interface{} {
			if p.Consume == nil {
				return nil
			}
			return p.Consume.ToDict()
		}()
	}
	if p.ConsumeAmount != nil {
		m["consumeAmount"] = func() map[string]interface{} {
			if p.ConsumeAmount == nil {
				return nil
			}
			return p.ConsumeAmount.ToDict()
		}()
	}
	return m
}

func (p InventoryInventoryDistributions) Pointer() *InventoryInventoryDistributions {
	return &p
}

func CastInventoryInventoryDistributionses(data []interface{}) []InventoryInventoryDistributions {
	v := make([]InventoryInventoryDistributions, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoryDistributionsesFromDict(data []InventoryInventoryDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryInventory struct {
	InventoryId   *string                          `json:"inventoryId"`
	InventoryName *string                          `json:"inventoryName"`
	Statistics    *InventoryInventoryStatistics    `json:"statistics"`
	Distributions *InventoryInventoryDistributions `json:"distributions"`
	ItemSets      []InventoryItemSet               `json:"itemSets"`
}

func (p *InventoryInventory) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryInventory{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryInventory{}
	} else {
		*p = InventoryInventory{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryId)
				}
			}
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["itemSets"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ItemSets)
		}
	}
	return nil
}

func NewInventoryInventoryFromJson(data string) InventoryInventory {
	req := InventoryInventory{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryInventoryFromDict(data map[string]interface{}) InventoryInventory {
	return InventoryInventory{
		InventoryId: func() *string {
			v, ok := data["inventoryId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["inventoryId"])
		}(),
		InventoryName: func() *string {
			v, ok := data["inventoryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["inventoryName"])
		}(),
		Statistics: func() *InventoryInventoryStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *InventoryInventoryDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryInventoryDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		ItemSets: func() []InventoryItemSet {
			if data["itemSets"] == nil {
				return nil
			}
			return CastInventoryItemSets(core.CastArray(data["itemSets"]))
		}(),
	}
}

func (p InventoryInventory) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.InventoryId != nil {
		m["inventoryId"] = p.InventoryId
	}
	if p.InventoryName != nil {
		m["inventoryName"] = p.InventoryName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.ItemSets != nil {
		m["itemSets"] = CastInventoryItemSetsFromDict(
			p.ItemSets,
		)
	}
	return m
}

func (p InventoryInventory) Pointer() *InventoryInventory {
	return &p
}

func CastInventoryInventories(data []interface{}) []InventoryInventory {
	v := make([]InventoryInventory, 0)
	for _, d := range data {
		v = append(v, NewInventoryInventoryFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryInventoriesFromDict(data []InventoryInventory) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceStatistics struct {
	Acquire          *int64 `json:"acquire"`
	Consume          *int64 `json:"consume"`
	IncreaseCapacity *int64 `json:"increaseCapacity"`
}

func (p *InventoryNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceStatistics{}
	} else {
		*p = InventoryNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["acquire"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Acquire)
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["increaseCapacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacity)
		}
	}
	return nil
}

func NewInventoryNamespaceStatisticsFromJson(data string) InventoryNamespaceStatistics {
	req := InventoryNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceStatisticsFromDict(data map[string]interface{}) InventoryNamespaceStatistics {
	return InventoryNamespaceStatistics{
		Acquire: func() *int64 {
			v, ok := data["acquire"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["acquire"])
		}(),
		Consume: func() *int64 {
			v, ok := data["consume"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["consume"])
		}(),
		IncreaseCapacity: func() *int64 {
			v, ok := data["increaseCapacity"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increaseCapacity"])
		}(),
	}
}

func (p InventoryNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Acquire != nil {
		m["acquire"] = p.Acquire
	}
	if p.Consume != nil {
		m["consume"] = p.Consume
	}
	if p.IncreaseCapacity != nil {
		m["increaseCapacity"] = p.IncreaseCapacity
	}
	return m
}

func (p InventoryNamespaceStatistics) Pointer() *InventoryNamespaceStatistics {
	return &p
}

func CastInventoryNamespaceStatisticses(data []interface{}) []InventoryNamespaceStatistics {
	v := make([]InventoryNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceStatisticsesFromDict(data []InventoryNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceAcquireDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireDistributionStatistics{}
	} else {
		*p = InventoryNamespaceAcquireDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireDistributionStatisticsFromJson(data string) InventoryNamespaceAcquireDistributionStatistics {
	req := InventoryNamespaceAcquireDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceAcquireDistributionStatistics {
	return InventoryNamespaceAcquireDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryNamespaceAcquireDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryNamespaceAcquireDistributionStatistics) Pointer() *InventoryNamespaceAcquireDistributionStatistics {
	return &p
}

func CastInventoryNamespaceAcquireDistributionStatisticses(data []interface{}) []InventoryNamespaceAcquireDistributionStatistics {
	v := make([]InventoryNamespaceAcquireDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireDistributionStatisticsesFromDict(data []InventoryNamespaceAcquireDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Count         *int64  `json:"count"`
}

func (p *InventoryNamespaceAcquireDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireDistributionSegment{}
	} else {
		*p = InventoryNamespaceAcquireDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireDistributionSegmentFromJson(data string) InventoryNamespaceAcquireDistributionSegment {
	req := InventoryNamespaceAcquireDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceAcquireDistributionSegment {
	return InventoryNamespaceAcquireDistributionSegment{
		InventoryName: func() *string {
			v, ok := data["inventoryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["inventoryName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p InventoryNamespaceAcquireDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.InventoryName != nil {
		m["inventoryName"] = p.InventoryName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p InventoryNamespaceAcquireDistributionSegment) Pointer() *InventoryNamespaceAcquireDistributionSegment {
	return &p
}

func CastInventoryNamespaceAcquireDistributionSegments(data []interface{}) []InventoryNamespaceAcquireDistributionSegment {
	v := make([]InventoryNamespaceAcquireDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireDistributionSegmentsFromDict(data []InventoryNamespaceAcquireDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireDistribution struct {
	Statistics   *InventoryNamespaceAcquireDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceAcquireDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceAcquireDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireDistribution{}
	} else {
		*p = InventoryNamespaceAcquireDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireDistributionFromJson(data string) InventoryNamespaceAcquireDistribution {
	req := InventoryNamespaceAcquireDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireDistributionFromDict(data map[string]interface{}) InventoryNamespaceAcquireDistribution {
	return InventoryNamespaceAcquireDistribution{
		Statistics: func() *InventoryNamespaceAcquireDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceAcquireDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryNamespaceAcquireDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryNamespaceAcquireDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryNamespaceAcquireDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryNamespaceAcquireDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryNamespaceAcquireDistribution) Pointer() *InventoryNamespaceAcquireDistribution {
	return &p
}

func CastInventoryNamespaceAcquireDistributions(data []interface{}) []InventoryNamespaceAcquireDistribution {
	v := make([]InventoryNamespaceAcquireDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireDistributionsFromDict(data []InventoryNamespaceAcquireDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceAcquireAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireAmountDistributionStatistics{}
	} else {
		*p = InventoryNamespaceAcquireAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireAmountDistributionStatisticsFromJson(data string) InventoryNamespaceAcquireAmountDistributionStatistics {
	req := InventoryNamespaceAcquireAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireAmountDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceAcquireAmountDistributionStatistics {
	return InventoryNamespaceAcquireAmountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryNamespaceAcquireAmountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryNamespaceAcquireAmountDistributionStatistics) Pointer() *InventoryNamespaceAcquireAmountDistributionStatistics {
	return &p
}

func CastInventoryNamespaceAcquireAmountDistributionStatisticses(data []interface{}) []InventoryNamespaceAcquireAmountDistributionStatistics {
	v := make([]InventoryNamespaceAcquireAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireAmountDistributionStatisticsesFromDict(data []InventoryNamespaceAcquireAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireAmountDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Sum           *int64  `json:"sum"`
}

func (p *InventoryNamespaceAcquireAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireAmountDistributionSegment{}
	} else {
		*p = InventoryNamespaceAcquireAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireAmountDistributionSegmentFromJson(data string) InventoryNamespaceAcquireAmountDistributionSegment {
	req := InventoryNamespaceAcquireAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireAmountDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceAcquireAmountDistributionSegment {
	return InventoryNamespaceAcquireAmountDistributionSegment{
		InventoryName: func() *string {
			v, ok := data["inventoryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["inventoryName"])
		}(),
		Sum: func() *int64 {
			v, ok := data["sum"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sum"])
		}(),
	}
}

func (p InventoryNamespaceAcquireAmountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.InventoryName != nil {
		m["inventoryName"] = p.InventoryName
	}
	if p.Sum != nil {
		m["sum"] = p.Sum
	}
	return m
}

func (p InventoryNamespaceAcquireAmountDistributionSegment) Pointer() *InventoryNamespaceAcquireAmountDistributionSegment {
	return &p
}

func CastInventoryNamespaceAcquireAmountDistributionSegments(data []interface{}) []InventoryNamespaceAcquireAmountDistributionSegment {
	v := make([]InventoryNamespaceAcquireAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireAmountDistributionSegmentsFromDict(data []InventoryNamespaceAcquireAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceAcquireAmountDistribution struct {
	Statistics   *InventoryNamespaceAcquireAmountDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceAcquireAmountDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceAcquireAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceAcquireAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceAcquireAmountDistribution{}
	} else {
		*p = InventoryNamespaceAcquireAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceAcquireAmountDistributionFromJson(data string) InventoryNamespaceAcquireAmountDistribution {
	req := InventoryNamespaceAcquireAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceAcquireAmountDistributionFromDict(data map[string]interface{}) InventoryNamespaceAcquireAmountDistribution {
	return InventoryNamespaceAcquireAmountDistribution{
		Statistics: func() *InventoryNamespaceAcquireAmountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceAcquireAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryNamespaceAcquireAmountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryNamespaceAcquireAmountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryNamespaceAcquireAmountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryNamespaceAcquireAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryNamespaceAcquireAmountDistribution) Pointer() *InventoryNamespaceAcquireAmountDistribution {
	return &p
}

func CastInventoryNamespaceAcquireAmountDistributions(data []interface{}) []InventoryNamespaceAcquireAmountDistribution {
	v := make([]InventoryNamespaceAcquireAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceAcquireAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceAcquireAmountDistributionsFromDict(data []InventoryNamespaceAcquireAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceConsumeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeDistributionStatistics{}
	} else {
		*p = InventoryNamespaceConsumeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeDistributionStatisticsFromJson(data string) InventoryNamespaceConsumeDistributionStatistics {
	req := InventoryNamespaceConsumeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceConsumeDistributionStatistics {
	return InventoryNamespaceConsumeDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryNamespaceConsumeDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryNamespaceConsumeDistributionStatistics) Pointer() *InventoryNamespaceConsumeDistributionStatistics {
	return &p
}

func CastInventoryNamespaceConsumeDistributionStatisticses(data []interface{}) []InventoryNamespaceConsumeDistributionStatistics {
	v := make([]InventoryNamespaceConsumeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeDistributionStatisticsesFromDict(data []InventoryNamespaceConsumeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Count         *int64  `json:"count"`
}

func (p *InventoryNamespaceConsumeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeDistributionSegment{}
	} else {
		*p = InventoryNamespaceConsumeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeDistributionSegmentFromJson(data string) InventoryNamespaceConsumeDistributionSegment {
	req := InventoryNamespaceConsumeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceConsumeDistributionSegment {
	return InventoryNamespaceConsumeDistributionSegment{
		InventoryName: func() *string {
			v, ok := data["inventoryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["inventoryName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p InventoryNamespaceConsumeDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.InventoryName != nil {
		m["inventoryName"] = p.InventoryName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p InventoryNamespaceConsumeDistributionSegment) Pointer() *InventoryNamespaceConsumeDistributionSegment {
	return &p
}

func CastInventoryNamespaceConsumeDistributionSegments(data []interface{}) []InventoryNamespaceConsumeDistributionSegment {
	v := make([]InventoryNamespaceConsumeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeDistributionSegmentsFromDict(data []InventoryNamespaceConsumeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeDistribution struct {
	Statistics   *InventoryNamespaceConsumeDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceConsumeDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceConsumeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeDistribution{}
	} else {
		*p = InventoryNamespaceConsumeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeDistributionFromJson(data string) InventoryNamespaceConsumeDistribution {
	req := InventoryNamespaceConsumeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeDistributionFromDict(data map[string]interface{}) InventoryNamespaceConsumeDistribution {
	return InventoryNamespaceConsumeDistribution{
		Statistics: func() *InventoryNamespaceConsumeDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceConsumeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryNamespaceConsumeDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryNamespaceConsumeDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryNamespaceConsumeDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryNamespaceConsumeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryNamespaceConsumeDistribution) Pointer() *InventoryNamespaceConsumeDistribution {
	return &p
}

func CastInventoryNamespaceConsumeDistributions(data []interface{}) []InventoryNamespaceConsumeDistribution {
	v := make([]InventoryNamespaceConsumeDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeDistributionsFromDict(data []InventoryNamespaceConsumeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceConsumeAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeAmountDistributionStatistics{}
	} else {
		*p = InventoryNamespaceConsumeAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeAmountDistributionStatisticsFromJson(data string) InventoryNamespaceConsumeAmountDistributionStatistics {
	req := InventoryNamespaceConsumeAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeAmountDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceConsumeAmountDistributionStatistics {
	return InventoryNamespaceConsumeAmountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryNamespaceConsumeAmountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryNamespaceConsumeAmountDistributionStatistics) Pointer() *InventoryNamespaceConsumeAmountDistributionStatistics {
	return &p
}

func CastInventoryNamespaceConsumeAmountDistributionStatisticses(data []interface{}) []InventoryNamespaceConsumeAmountDistributionStatistics {
	v := make([]InventoryNamespaceConsumeAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeAmountDistributionStatisticsesFromDict(data []InventoryNamespaceConsumeAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeAmountDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Sum           *int64  `json:"sum"`
}

func (p *InventoryNamespaceConsumeAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeAmountDistributionSegment{}
	} else {
		*p = InventoryNamespaceConsumeAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeAmountDistributionSegmentFromJson(data string) InventoryNamespaceConsumeAmountDistributionSegment {
	req := InventoryNamespaceConsumeAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeAmountDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceConsumeAmountDistributionSegment {
	return InventoryNamespaceConsumeAmountDistributionSegment{
		InventoryName: func() *string {
			v, ok := data["inventoryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["inventoryName"])
		}(),
		Sum: func() *int64 {
			v, ok := data["sum"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sum"])
		}(),
	}
}

func (p InventoryNamespaceConsumeAmountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.InventoryName != nil {
		m["inventoryName"] = p.InventoryName
	}
	if p.Sum != nil {
		m["sum"] = p.Sum
	}
	return m
}

func (p InventoryNamespaceConsumeAmountDistributionSegment) Pointer() *InventoryNamespaceConsumeAmountDistributionSegment {
	return &p
}

func CastInventoryNamespaceConsumeAmountDistributionSegments(data []interface{}) []InventoryNamespaceConsumeAmountDistributionSegment {
	v := make([]InventoryNamespaceConsumeAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeAmountDistributionSegmentsFromDict(data []InventoryNamespaceConsumeAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceConsumeAmountDistribution struct {
	Statistics   *InventoryNamespaceConsumeAmountDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceConsumeAmountDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceConsumeAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceConsumeAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceConsumeAmountDistribution{}
	} else {
		*p = InventoryNamespaceConsumeAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceConsumeAmountDistributionFromJson(data string) InventoryNamespaceConsumeAmountDistribution {
	req := InventoryNamespaceConsumeAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceConsumeAmountDistributionFromDict(data map[string]interface{}) InventoryNamespaceConsumeAmountDistribution {
	return InventoryNamespaceConsumeAmountDistribution{
		Statistics: func() *InventoryNamespaceConsumeAmountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceConsumeAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryNamespaceConsumeAmountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryNamespaceConsumeAmountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryNamespaceConsumeAmountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryNamespaceConsumeAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryNamespaceConsumeAmountDistribution) Pointer() *InventoryNamespaceConsumeAmountDistribution {
	return &p
}

func CastInventoryNamespaceConsumeAmountDistributions(data []interface{}) []InventoryNamespaceConsumeAmountDistribution {
	v := make([]InventoryNamespaceConsumeAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceConsumeAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceConsumeAmountDistributionsFromDict(data []InventoryNamespaceConsumeAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceIncreaseCapacityDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityDistributionStatistics{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityDistributionStatisticsFromJson(data string) InventoryNamespaceIncreaseCapacityDistributionStatistics {
	req := InventoryNamespaceIncreaseCapacityDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityDistributionStatistics {
	return InventoryNamespaceIncreaseCapacityDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryNamespaceIncreaseCapacityDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryNamespaceIncreaseCapacityDistributionStatistics) Pointer() *InventoryNamespaceIncreaseCapacityDistributionStatistics {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityDistributionStatisticses(data []interface{}) []InventoryNamespaceIncreaseCapacityDistributionStatistics {
	v := make([]InventoryNamespaceIncreaseCapacityDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityDistributionStatisticsesFromDict(data []InventoryNamespaceIncreaseCapacityDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Count         *int64  `json:"count"`
}

func (p *InventoryNamespaceIncreaseCapacityDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityDistributionSegment{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityDistributionSegmentFromJson(data string) InventoryNamespaceIncreaseCapacityDistributionSegment {
	req := InventoryNamespaceIncreaseCapacityDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityDistributionSegment {
	return InventoryNamespaceIncreaseCapacityDistributionSegment{
		InventoryName: func() *string {
			v, ok := data["inventoryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["inventoryName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p InventoryNamespaceIncreaseCapacityDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.InventoryName != nil {
		m["inventoryName"] = p.InventoryName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p InventoryNamespaceIncreaseCapacityDistributionSegment) Pointer() *InventoryNamespaceIncreaseCapacityDistributionSegment {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityDistributionSegments(data []interface{}) []InventoryNamespaceIncreaseCapacityDistributionSegment {
	v := make([]InventoryNamespaceIncreaseCapacityDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityDistributionSegmentsFromDict(data []InventoryNamespaceIncreaseCapacityDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityDistribution struct {
	Statistics   *InventoryNamespaceIncreaseCapacityDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceIncreaseCapacityDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceIncreaseCapacityDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityDistribution{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityDistributionFromJson(data string) InventoryNamespaceIncreaseCapacityDistribution {
	req := InventoryNamespaceIncreaseCapacityDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityDistributionFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityDistribution {
	return InventoryNamespaceIncreaseCapacityDistribution{
		Statistics: func() *InventoryNamespaceIncreaseCapacityDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceIncreaseCapacityDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryNamespaceIncreaseCapacityDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryNamespaceIncreaseCapacityDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryNamespaceIncreaseCapacityDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryNamespaceIncreaseCapacityDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryNamespaceIncreaseCapacityDistribution) Pointer() *InventoryNamespaceIncreaseCapacityDistribution {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityDistributions(data []interface{}) []InventoryNamespaceIncreaseCapacityDistribution {
	v := make([]InventoryNamespaceIncreaseCapacityDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityDistributionsFromDict(data []InventoryNamespaceIncreaseCapacityDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *InventoryNamespaceIncreaseCapacityAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionStatistics{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionStatisticsFromJson(data string) InventoryNamespaceIncreaseCapacityAmountDistributionStatistics {
	req := InventoryNamespaceIncreaseCapacityAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionStatisticsFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityAmountDistributionStatistics {
	return InventoryNamespaceIncreaseCapacityAmountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p InventoryNamespaceIncreaseCapacityAmountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p InventoryNamespaceIncreaseCapacityAmountDistributionStatistics) Pointer() *InventoryNamespaceIncreaseCapacityAmountDistributionStatistics {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributionStatisticses(data []interface{}) []InventoryNamespaceIncreaseCapacityAmountDistributionStatistics {
	v := make([]InventoryNamespaceIncreaseCapacityAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributionStatisticsesFromDict(data []InventoryNamespaceIncreaseCapacityAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityAmountDistributionSegment struct {
	InventoryName *string `json:"inventoryName"`
	Sum           *int64  `json:"sum"`
}

func (p *InventoryNamespaceIncreaseCapacityAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionSegment{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["inventoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.InventoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.InventoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.InventoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.InventoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.InventoryName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionSegmentFromJson(data string) InventoryNamespaceIncreaseCapacityAmountDistributionSegment {
	req := InventoryNamespaceIncreaseCapacityAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionSegmentFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityAmountDistributionSegment {
	return InventoryNamespaceIncreaseCapacityAmountDistributionSegment{
		InventoryName: func() *string {
			v, ok := data["inventoryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["inventoryName"])
		}(),
		Sum: func() *int64 {
			v, ok := data["sum"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sum"])
		}(),
	}
}

func (p InventoryNamespaceIncreaseCapacityAmountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.InventoryName != nil {
		m["inventoryName"] = p.InventoryName
	}
	if p.Sum != nil {
		m["sum"] = p.Sum
	}
	return m
}

func (p InventoryNamespaceIncreaseCapacityAmountDistributionSegment) Pointer() *InventoryNamespaceIncreaseCapacityAmountDistributionSegment {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributionSegments(data []interface{}) []InventoryNamespaceIncreaseCapacityAmountDistributionSegment {
	v := make([]InventoryNamespaceIncreaseCapacityAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributionSegmentsFromDict(data []InventoryNamespaceIncreaseCapacityAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceIncreaseCapacityAmountDistribution struct {
	Statistics   *InventoryNamespaceIncreaseCapacityAmountDistributionStatistics `json:"statistics"`
	Distribution []InventoryNamespaceIncreaseCapacityAmountDistributionSegment   `json:"distribution"`
}

func (p *InventoryNamespaceIncreaseCapacityAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceIncreaseCapacityAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceIncreaseCapacityAmountDistribution{}
	} else {
		*p = InventoryNamespaceIncreaseCapacityAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionFromJson(data string) InventoryNamespaceIncreaseCapacityAmountDistribution {
	req := InventoryNamespaceIncreaseCapacityAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceIncreaseCapacityAmountDistributionFromDict(data map[string]interface{}) InventoryNamespaceIncreaseCapacityAmountDistribution {
	return InventoryNamespaceIncreaseCapacityAmountDistribution{
		Statistics: func() *InventoryNamespaceIncreaseCapacityAmountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceIncreaseCapacityAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []InventoryNamespaceIncreaseCapacityAmountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastInventoryNamespaceIncreaseCapacityAmountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p InventoryNamespaceIncreaseCapacityAmountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastInventoryNamespaceIncreaseCapacityAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p InventoryNamespaceIncreaseCapacityAmountDistribution) Pointer() *InventoryNamespaceIncreaseCapacityAmountDistribution {
	return &p
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributions(data []interface{}) []InventoryNamespaceIncreaseCapacityAmountDistribution {
	v := make([]InventoryNamespaceIncreaseCapacityAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceIncreaseCapacityAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceIncreaseCapacityAmountDistributionsFromDict(data []InventoryNamespaceIncreaseCapacityAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespaceDistributions struct {
	Acquire                *InventoryNamespaceAcquireDistribution                `json:"acquire"`
	AcquireAmount          *InventoryNamespaceAcquireAmountDistribution          `json:"acquireAmount"`
	Consume                *InventoryNamespaceConsumeDistribution                `json:"consume"`
	ConsumeAmount          *InventoryNamespaceConsumeAmountDistribution          `json:"consumeAmount"`
	IncreaseCapacity       *InventoryNamespaceIncreaseCapacityDistribution       `json:"increaseCapacity"`
	IncreaseCapacityAmount *InventoryNamespaceIncreaseCapacityAmountDistribution `json:"increaseCapacityAmount"`
}

func (p *InventoryNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespaceDistributions{}
	} else {
		*p = InventoryNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["acquire"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Acquire)
		}
		if v, ok := d["acquireAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.AcquireAmount)
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["consumeAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ConsumeAmount)
		}
		if v, ok := d["increaseCapacity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacity)
		}
		if v, ok := d["increaseCapacityAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseCapacityAmount)
		}
	}
	return nil
}

func NewInventoryNamespaceDistributionsFromJson(data string) InventoryNamespaceDistributions {
	req := InventoryNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceDistributionsFromDict(data map[string]interface{}) InventoryNamespaceDistributions {
	return InventoryNamespaceDistributions{
		Acquire: func() *InventoryNamespaceAcquireDistribution {
			v, ok := data["acquire"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceAcquireDistributionFromDict(core.CastMap(data["acquire"])).Pointer()
		}(),
		AcquireAmount: func() *InventoryNamespaceAcquireAmountDistribution {
			v, ok := data["acquireAmount"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceAcquireAmountDistributionFromDict(core.CastMap(data["acquireAmount"])).Pointer()
		}(),
		Consume: func() *InventoryNamespaceConsumeDistribution {
			v, ok := data["consume"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceConsumeDistributionFromDict(core.CastMap(data["consume"])).Pointer()
		}(),
		ConsumeAmount: func() *InventoryNamespaceConsumeAmountDistribution {
			v, ok := data["consumeAmount"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceConsumeAmountDistributionFromDict(core.CastMap(data["consumeAmount"])).Pointer()
		}(),
		IncreaseCapacity: func() *InventoryNamespaceIncreaseCapacityDistribution {
			v, ok := data["increaseCapacity"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceIncreaseCapacityDistributionFromDict(core.CastMap(data["increaseCapacity"])).Pointer()
		}(),
		IncreaseCapacityAmount: func() *InventoryNamespaceIncreaseCapacityAmountDistribution {
			v, ok := data["increaseCapacityAmount"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceIncreaseCapacityAmountDistributionFromDict(core.CastMap(data["increaseCapacityAmount"])).Pointer()
		}(),
	}
}

func (p InventoryNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Acquire != nil {
		m["acquire"] = func() map[string]interface{} {
			if p.Acquire == nil {
				return nil
			}
			return p.Acquire.ToDict()
		}()
	}
	if p.AcquireAmount != nil {
		m["acquireAmount"] = func() map[string]interface{} {
			if p.AcquireAmount == nil {
				return nil
			}
			return p.AcquireAmount.ToDict()
		}()
	}
	if p.Consume != nil {
		m["consume"] = func() map[string]interface{} {
			if p.Consume == nil {
				return nil
			}
			return p.Consume.ToDict()
		}()
	}
	if p.ConsumeAmount != nil {
		m["consumeAmount"] = func() map[string]interface{} {
			if p.ConsumeAmount == nil {
				return nil
			}
			return p.ConsumeAmount.ToDict()
		}()
	}
	if p.IncreaseCapacity != nil {
		m["increaseCapacity"] = func() map[string]interface{} {
			if p.IncreaseCapacity == nil {
				return nil
			}
			return p.IncreaseCapacity.ToDict()
		}()
	}
	if p.IncreaseCapacityAmount != nil {
		m["increaseCapacityAmount"] = func() map[string]interface{} {
			if p.IncreaseCapacityAmount == nil {
				return nil
			}
			return p.IncreaseCapacityAmount.ToDict()
		}()
	}
	return m
}

func (p InventoryNamespaceDistributions) Pointer() *InventoryNamespaceDistributions {
	return &p
}

func CastInventoryNamespaceDistributionses(data []interface{}) []InventoryNamespaceDistributions {
	v := make([]InventoryNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespaceDistributionsesFromDict(data []InventoryNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type InventoryNamespace struct {
	NamespaceId   *string                          `json:"namespaceId"`
	Year          *int32                           `json:"year"`
	Month         *int32                           `json:"month"`
	Day           *int32                           `json:"day"`
	NamespaceName *string                          `json:"namespaceName"`
	Statistics    *InventoryNamespaceStatistics    `json:"statistics"`
	Distributions *InventoryNamespaceDistributions `json:"distributions"`
	Inventories   []InventoryInventory             `json:"inventories"`
}

func (p *InventoryNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = InventoryNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = InventoryNamespace{}
	} else {
		*p = InventoryNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["inventories"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Inventories)
		}
	}
	return nil
}

func NewInventoryNamespaceFromJson(data string) InventoryNamespace {
	req := InventoryNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewInventoryNamespaceFromDict(data map[string]interface{}) InventoryNamespace {
	return InventoryNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *InventoryNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *InventoryNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewInventoryNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		Inventories: func() []InventoryInventory {
			if data["inventories"] == nil {
				return nil
			}
			return CastInventoryInventories(core.CastArray(data["inventories"]))
		}(),
	}
}

func (p InventoryNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.Inventories != nil {
		m["inventories"] = CastInventoryInventoriesFromDict(
			p.Inventories,
		)
	}
	return m
}

func (p InventoryNamespace) Pointer() *InventoryNamespace {
	return &p
}

func CastInventoryNamespaces(data []interface{}) []InventoryNamespace {
	v := make([]InventoryNamespace, 0)
	for _, d := range data {
		v = append(v, NewInventoryNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastInventoryNamespacesFromDict(data []InventoryNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceStatistics struct {
	Encrypt *int64 `json:"encrypt"`
	Decrypt *int64 `json:"decrypt"`
}

func (p *KeyNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceStatistics{}
	} else {
		*p = KeyNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["encrypt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Encrypt)
		}
		if v, ok := d["decrypt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Decrypt)
		}
	}
	return nil
}

func NewKeyNamespaceStatisticsFromJson(data string) KeyNamespaceStatistics {
	req := KeyNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceStatisticsFromDict(data map[string]interface{}) KeyNamespaceStatistics {
	return KeyNamespaceStatistics{
		Encrypt: func() *int64 {
			v, ok := data["encrypt"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["encrypt"])
		}(),
		Decrypt: func() *int64 {
			v, ok := data["decrypt"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["decrypt"])
		}(),
	}
}

func (p KeyNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Encrypt != nil {
		m["encrypt"] = p.Encrypt
	}
	if p.Decrypt != nil {
		m["decrypt"] = p.Decrypt
	}
	return m
}

func (p KeyNamespaceStatistics) Pointer() *KeyNamespaceStatistics {
	return &p
}

func CastKeyNamespaceStatisticses(data []interface{}) []KeyNamespaceStatistics {
	v := make([]KeyNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceStatisticsesFromDict(data []KeyNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceEncryptDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *KeyNamespaceEncryptDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceEncryptDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceEncryptDistributionStatistics{}
	} else {
		*p = KeyNamespaceEncryptDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewKeyNamespaceEncryptDistributionStatisticsFromJson(data string) KeyNamespaceEncryptDistributionStatistics {
	req := KeyNamespaceEncryptDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceEncryptDistributionStatisticsFromDict(data map[string]interface{}) KeyNamespaceEncryptDistributionStatistics {
	return KeyNamespaceEncryptDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p KeyNamespaceEncryptDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p KeyNamespaceEncryptDistributionStatistics) Pointer() *KeyNamespaceEncryptDistributionStatistics {
	return &p
}

func CastKeyNamespaceEncryptDistributionStatisticses(data []interface{}) []KeyNamespaceEncryptDistributionStatistics {
	v := make([]KeyNamespaceEncryptDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceEncryptDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceEncryptDistributionStatisticsesFromDict(data []KeyNamespaceEncryptDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceEncryptDistributionSegment struct {
	KeyName *string `json:"keyName"`
	Count   *int64  `json:"count"`
}

func (p *KeyNamespaceEncryptDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceEncryptDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceEncryptDistributionSegment{}
	} else {
		*p = KeyNamespaceEncryptDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["keyName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.KeyName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.KeyName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.KeyName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.KeyName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewKeyNamespaceEncryptDistributionSegmentFromJson(data string) KeyNamespaceEncryptDistributionSegment {
	req := KeyNamespaceEncryptDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceEncryptDistributionSegmentFromDict(data map[string]interface{}) KeyNamespaceEncryptDistributionSegment {
	return KeyNamespaceEncryptDistributionSegment{
		KeyName: func() *string {
			v, ok := data["keyName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["keyName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p KeyNamespaceEncryptDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.KeyName != nil {
		m["keyName"] = p.KeyName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p KeyNamespaceEncryptDistributionSegment) Pointer() *KeyNamespaceEncryptDistributionSegment {
	return &p
}

func CastKeyNamespaceEncryptDistributionSegments(data []interface{}) []KeyNamespaceEncryptDistributionSegment {
	v := make([]KeyNamespaceEncryptDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceEncryptDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceEncryptDistributionSegmentsFromDict(data []KeyNamespaceEncryptDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceEncryptDistribution struct {
	Statistics   *KeyNamespaceEncryptDistributionStatistics `json:"statistics"`
	Distribution []KeyNamespaceEncryptDistributionSegment   `json:"distribution"`
}

func (p *KeyNamespaceEncryptDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceEncryptDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceEncryptDistribution{}
	} else {
		*p = KeyNamespaceEncryptDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewKeyNamespaceEncryptDistributionFromJson(data string) KeyNamespaceEncryptDistribution {
	req := KeyNamespaceEncryptDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceEncryptDistributionFromDict(data map[string]interface{}) KeyNamespaceEncryptDistribution {
	return KeyNamespaceEncryptDistribution{
		Statistics: func() *KeyNamespaceEncryptDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewKeyNamespaceEncryptDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []KeyNamespaceEncryptDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastKeyNamespaceEncryptDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p KeyNamespaceEncryptDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastKeyNamespaceEncryptDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p KeyNamespaceEncryptDistribution) Pointer() *KeyNamespaceEncryptDistribution {
	return &p
}

func CastKeyNamespaceEncryptDistributions(data []interface{}) []KeyNamespaceEncryptDistribution {
	v := make([]KeyNamespaceEncryptDistribution, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceEncryptDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceEncryptDistributionsFromDict(data []KeyNamespaceEncryptDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceDecryptDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *KeyNamespaceDecryptDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceDecryptDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceDecryptDistributionStatistics{}
	} else {
		*p = KeyNamespaceDecryptDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewKeyNamespaceDecryptDistributionStatisticsFromJson(data string) KeyNamespaceDecryptDistributionStatistics {
	req := KeyNamespaceDecryptDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceDecryptDistributionStatisticsFromDict(data map[string]interface{}) KeyNamespaceDecryptDistributionStatistics {
	return KeyNamespaceDecryptDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p KeyNamespaceDecryptDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p KeyNamespaceDecryptDistributionStatistics) Pointer() *KeyNamespaceDecryptDistributionStatistics {
	return &p
}

func CastKeyNamespaceDecryptDistributionStatisticses(data []interface{}) []KeyNamespaceDecryptDistributionStatistics {
	v := make([]KeyNamespaceDecryptDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceDecryptDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceDecryptDistributionStatisticsesFromDict(data []KeyNamespaceDecryptDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceDecryptDistributionSegment struct {
	KeyName *string `json:"keyName"`
	Count   *int64  `json:"count"`
}

func (p *KeyNamespaceDecryptDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceDecryptDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceDecryptDistributionSegment{}
	} else {
		*p = KeyNamespaceDecryptDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["keyName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.KeyName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.KeyName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.KeyName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.KeyName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewKeyNamespaceDecryptDistributionSegmentFromJson(data string) KeyNamespaceDecryptDistributionSegment {
	req := KeyNamespaceDecryptDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceDecryptDistributionSegmentFromDict(data map[string]interface{}) KeyNamespaceDecryptDistributionSegment {
	return KeyNamespaceDecryptDistributionSegment{
		KeyName: func() *string {
			v, ok := data["keyName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["keyName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p KeyNamespaceDecryptDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.KeyName != nil {
		m["keyName"] = p.KeyName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p KeyNamespaceDecryptDistributionSegment) Pointer() *KeyNamespaceDecryptDistributionSegment {
	return &p
}

func CastKeyNamespaceDecryptDistributionSegments(data []interface{}) []KeyNamespaceDecryptDistributionSegment {
	v := make([]KeyNamespaceDecryptDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceDecryptDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceDecryptDistributionSegmentsFromDict(data []KeyNamespaceDecryptDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceDecryptDistribution struct {
	Statistics   *KeyNamespaceDecryptDistributionStatistics `json:"statistics"`
	Distribution []KeyNamespaceDecryptDistributionSegment   `json:"distribution"`
}

func (p *KeyNamespaceDecryptDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceDecryptDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceDecryptDistribution{}
	} else {
		*p = KeyNamespaceDecryptDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewKeyNamespaceDecryptDistributionFromJson(data string) KeyNamespaceDecryptDistribution {
	req := KeyNamespaceDecryptDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceDecryptDistributionFromDict(data map[string]interface{}) KeyNamespaceDecryptDistribution {
	return KeyNamespaceDecryptDistribution{
		Statistics: func() *KeyNamespaceDecryptDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewKeyNamespaceDecryptDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []KeyNamespaceDecryptDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastKeyNamespaceDecryptDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p KeyNamespaceDecryptDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastKeyNamespaceDecryptDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p KeyNamespaceDecryptDistribution) Pointer() *KeyNamespaceDecryptDistribution {
	return &p
}

func CastKeyNamespaceDecryptDistributions(data []interface{}) []KeyNamespaceDecryptDistribution {
	v := make([]KeyNamespaceDecryptDistribution, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceDecryptDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceDecryptDistributionsFromDict(data []KeyNamespaceDecryptDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespaceDistributions struct {
	Encrypt *KeyNamespaceEncryptDistribution `json:"encrypt"`
	Decrypt *KeyNamespaceDecryptDistribution `json:"decrypt"`
}

func (p *KeyNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespaceDistributions{}
	} else {
		*p = KeyNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["encrypt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Encrypt)
		}
		if v, ok := d["decrypt"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Decrypt)
		}
	}
	return nil
}

func NewKeyNamespaceDistributionsFromJson(data string) KeyNamespaceDistributions {
	req := KeyNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceDistributionsFromDict(data map[string]interface{}) KeyNamespaceDistributions {
	return KeyNamespaceDistributions{
		Encrypt: func() *KeyNamespaceEncryptDistribution {
			v, ok := data["encrypt"]
			if !ok || v == nil {
				return nil
			}
			return NewKeyNamespaceEncryptDistributionFromDict(core.CastMap(data["encrypt"])).Pointer()
		}(),
		Decrypt: func() *KeyNamespaceDecryptDistribution {
			v, ok := data["decrypt"]
			if !ok || v == nil {
				return nil
			}
			return NewKeyNamespaceDecryptDistributionFromDict(core.CastMap(data["decrypt"])).Pointer()
		}(),
	}
}

func (p KeyNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Encrypt != nil {
		m["encrypt"] = func() map[string]interface{} {
			if p.Encrypt == nil {
				return nil
			}
			return p.Encrypt.ToDict()
		}()
	}
	if p.Decrypt != nil {
		m["decrypt"] = func() map[string]interface{} {
			if p.Decrypt == nil {
				return nil
			}
			return p.Decrypt.ToDict()
		}()
	}
	return m
}

func (p KeyNamespaceDistributions) Pointer() *KeyNamespaceDistributions {
	return &p
}

func CastKeyNamespaceDistributionses(data []interface{}) []KeyNamespaceDistributions {
	v := make([]KeyNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespaceDistributionsesFromDict(data []KeyNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyNamespace struct {
	NamespaceId   *string                    `json:"namespaceId"`
	Year          *int32                     `json:"year"`
	Month         *int32                     `json:"month"`
	Day           *int32                     `json:"day"`
	NamespaceName *string                    `json:"namespaceName"`
	Statistics    *KeyNamespaceStatistics    `json:"statistics"`
	Distributions *KeyNamespaceDistributions `json:"distributions"`
}

func (p *KeyNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyNamespace{}
	} else {
		*p = KeyNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewKeyNamespaceFromJson(data string) KeyNamespace {
	req := KeyNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyNamespaceFromDict(data map[string]interface{}) KeyNamespace {
	return KeyNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *KeyNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewKeyNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *KeyNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewKeyNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p KeyNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p KeyNamespace) Pointer() *KeyNamespace {
	return &p
}

func CastKeyNamespaces(data []interface{}) []KeyNamespace {
	v := make([]KeyNamespace, 0)
	for _, d := range data {
		v = append(v, NewKeyNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyNamespacesFromDict(data []KeyNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type KeyKey struct {
	KeyId   *string `json:"keyId"`
	KeyName *string `json:"keyName"`
}

func (p *KeyKey) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = KeyKey{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = KeyKey{}
	} else {
		*p = KeyKey{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["keyId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.KeyId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.KeyId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.KeyId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.KeyId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.KeyId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.KeyId)
				}
			}
		}
		if v, ok := d["keyName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.KeyName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.KeyName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.KeyName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.KeyName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.KeyName)
				}
			}
		}
	}
	return nil
}

func NewKeyKeyFromJson(data string) KeyKey {
	req := KeyKey{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewKeyKeyFromDict(data map[string]interface{}) KeyKey {
	return KeyKey{
		KeyId: func() *string {
			v, ok := data["keyId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["keyId"])
		}(),
		KeyName: func() *string {
			v, ok := data["keyName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["keyName"])
		}(),
	}
}

func (p KeyKey) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.KeyId != nil {
		m["keyId"] = p.KeyId
	}
	if p.KeyName != nil {
		m["keyName"] = p.KeyName
	}
	return m
}

func (p KeyKey) Pointer() *KeyKey {
	return &p
}

func CastKeyKeys(data []interface{}) []KeyKey {
	v := make([]KeyKey, 0)
	for _, d := range data {
		v = append(v, NewKeyKeyFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastKeyKeysFromDict(data []KeyKey) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounterStatistics struct {
	Increase       *int64 `json:"increase"`
	IncreaseAmount *int64 `json:"increaseAmount"`
}

func (p *LimitCounterStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounterStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounterStatistics{}
	} else {
		*p = LimitCounterStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
		if v, ok := d["increaseAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmount)
		}
	}
	return nil
}

func NewLimitCounterStatisticsFromJson(data string) LimitCounterStatistics {
	req := LimitCounterStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterStatisticsFromDict(data map[string]interface{}) LimitCounterStatistics {
	return LimitCounterStatistics{
		Increase: func() *int64 {
			v, ok := data["increase"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increase"])
		}(),
		IncreaseAmount: func() *int64 {
			v, ok := data["increaseAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increaseAmount"])
		}(),
	}
}

func (p LimitCounterStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Increase != nil {
		m["increase"] = p.Increase
	}
	if p.IncreaseAmount != nil {
		m["increaseAmount"] = p.IncreaseAmount
	}
	return m
}

func (p LimitCounterStatistics) Pointer() *LimitCounterStatistics {
	return &p
}

func CastLimitCounterStatisticses(data []interface{}) []LimitCounterStatistics {
	v := make([]LimitCounterStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCounterStatisticsesFromDict(data []LimitCounterStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounterCounterDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitCounterCounterDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounterCounterDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounterCounterDistributionStatistics{}
	} else {
		*p = LimitCounterCounterDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitCounterCounterDistributionStatisticsFromJson(data string) LimitCounterCounterDistributionStatistics {
	req := LimitCounterCounterDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterCounterDistributionStatisticsFromDict(data map[string]interface{}) LimitCounterCounterDistributionStatistics {
	return LimitCounterCounterDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LimitCounterCounterDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LimitCounterCounterDistributionStatistics) Pointer() *LimitCounterCounterDistributionStatistics {
	return &p
}

func CastLimitCounterCounterDistributionStatisticses(data []interface{}) []LimitCounterCounterDistributionStatistics {
	v := make([]LimitCounterCounterDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterCounterDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCounterCounterDistributionStatisticsesFromDict(data []LimitCounterCounterDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounterCounterDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *LimitCounterCounterDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounterCounterDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounterCounterDistributionSegment{}
	} else {
		*p = LimitCounterCounterDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLimitCounterCounterDistributionSegmentFromJson(data string) LimitCounterCounterDistributionSegment {
	req := LimitCounterCounterDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterCounterDistributionSegmentFromDict(data map[string]interface{}) LimitCounterCounterDistributionSegment {
	return LimitCounterCounterDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p LimitCounterCounterDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p LimitCounterCounterDistributionSegment) Pointer() *LimitCounterCounterDistributionSegment {
	return &p
}

func CastLimitCounterCounterDistributionSegments(data []interface{}) []LimitCounterCounterDistributionSegment {
	v := make([]LimitCounterCounterDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterCounterDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCounterCounterDistributionSegmentsFromDict(data []LimitCounterCounterDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounterCounterDistribution struct {
	Statistics   *LimitCounterCounterDistributionStatistics `json:"statistics"`
	Distribution []LimitCounterCounterDistributionSegment   `json:"distribution"`
}

func (p *LimitCounterCounterDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounterCounterDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounterCounterDistribution{}
	} else {
		*p = LimitCounterCounterDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitCounterCounterDistributionFromJson(data string) LimitCounterCounterDistribution {
	req := LimitCounterCounterDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterCounterDistributionFromDict(data map[string]interface{}) LimitCounterCounterDistribution {
	return LimitCounterCounterDistribution{
		Statistics: func() *LimitCounterCounterDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitCounterCounterDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LimitCounterCounterDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLimitCounterCounterDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LimitCounterCounterDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLimitCounterCounterDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LimitCounterCounterDistribution) Pointer() *LimitCounterCounterDistribution {
	return &p
}

func CastLimitCounterCounterDistributions(data []interface{}) []LimitCounterCounterDistribution {
	v := make([]LimitCounterCounterDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterCounterDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCounterCounterDistributionsFromDict(data []LimitCounterCounterDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounterDistributions struct {
	Counter *LimitCounterCounterDistribution `json:"counter"`
}

func (p *LimitCounterDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounterDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounterDistributions{}
	} else {
		*p = LimitCounterDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counter"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Counter)
		}
	}
	return nil
}

func NewLimitCounterDistributionsFromJson(data string) LimitCounterDistributions {
	req := LimitCounterDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterDistributionsFromDict(data map[string]interface{}) LimitCounterDistributions {
	return LimitCounterDistributions{
		Counter: func() *LimitCounterCounterDistribution {
			v, ok := data["counter"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitCounterCounterDistributionFromDict(core.CastMap(data["counter"])).Pointer()
		}(),
	}
}

func (p LimitCounterDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Counter != nil {
		m["counter"] = func() map[string]interface{} {
			if p.Counter == nil {
				return nil
			}
			return p.Counter.ToDict()
		}()
	}
	return m
}

func (p LimitCounterDistributions) Pointer() *LimitCounterDistributions {
	return &p
}

func CastLimitCounterDistributionses(data []interface{}) []LimitCounterDistributions {
	v := make([]LimitCounterDistributions, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCounterDistributionsesFromDict(data []LimitCounterDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitCounter struct {
	CounterId     *string                    `json:"counterId"`
	LimitName     *string                    `json:"limitName"`
	CounterName   *string                    `json:"counterName"`
	Statistics    *LimitCounterStatistics    `json:"statistics"`
	Distributions *LimitCounterDistributions `json:"distributions"`
}

func (p *LimitCounter) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitCounter{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitCounter{}
	} else {
		*p = LimitCounter{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterId)
				}
			}
		}
		if v, ok := d["limitName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LimitName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LimitName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LimitName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LimitName)
				}
			}
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewLimitCounterFromJson(data string) LimitCounter {
	req := LimitCounter{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitCounterFromDict(data map[string]interface{}) LimitCounter {
	return LimitCounter{
		CounterId: func() *string {
			v, ok := data["counterId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["counterId"])
		}(),
		LimitName: func() *string {
			v, ok := data["limitName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["limitName"])
		}(),
		CounterName: func() *string {
			v, ok := data["counterName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["counterName"])
		}(),
		Statistics: func() *LimitCounterStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitCounterStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *LimitCounterDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitCounterDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p LimitCounter) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.CounterId != nil {
		m["counterId"] = p.CounterId
	}
	if p.LimitName != nil {
		m["limitName"] = p.LimitName
	}
	if p.CounterName != nil {
		m["counterName"] = p.CounterName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p LimitCounter) Pointer() *LimitCounter {
	return &p
}

func CastLimitCounters(data []interface{}) []LimitCounter {
	v := make([]LimitCounter, 0)
	for _, d := range data {
		v = append(v, NewLimitCounterFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitCountersFromDict(data []LimitCounter) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelStatistics struct {
	Increase       *int64 `json:"increase"`
	IncreaseAmount *int64 `json:"increaseAmount"`
}

func (p *LimitLimitModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelStatistics{}
	} else {
		*p = LimitLimitModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
		if v, ok := d["increaseAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmount)
		}
	}
	return nil
}

func NewLimitLimitModelStatisticsFromJson(data string) LimitLimitModelStatistics {
	req := LimitLimitModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelStatisticsFromDict(data map[string]interface{}) LimitLimitModelStatistics {
	return LimitLimitModelStatistics{
		Increase: func() *int64 {
			v, ok := data["increase"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increase"])
		}(),
		IncreaseAmount: func() *int64 {
			v, ok := data["increaseAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increaseAmount"])
		}(),
	}
}

func (p LimitLimitModelStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Increase != nil {
		m["increase"] = p.Increase
	}
	if p.IncreaseAmount != nil {
		m["increaseAmount"] = p.IncreaseAmount
	}
	return m
}

func (p LimitLimitModelStatistics) Pointer() *LimitLimitModelStatistics {
	return &p
}

func CastLimitLimitModelStatisticses(data []interface{}) []LimitLimitModelStatistics {
	v := make([]LimitLimitModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelStatisticsesFromDict(data []LimitLimitModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitLimitModelIncreaseDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseDistributionStatistics{}
	} else {
		*p = LimitLimitModelIncreaseDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseDistributionStatisticsFromJson(data string) LimitLimitModelIncreaseDistributionStatistics {
	req := LimitLimitModelIncreaseDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseDistributionStatisticsFromDict(data map[string]interface{}) LimitLimitModelIncreaseDistributionStatistics {
	return LimitLimitModelIncreaseDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LimitLimitModelIncreaseDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LimitLimitModelIncreaseDistributionStatistics) Pointer() *LimitLimitModelIncreaseDistributionStatistics {
	return &p
}

func CastLimitLimitModelIncreaseDistributionStatisticses(data []interface{}) []LimitLimitModelIncreaseDistributionStatistics {
	v := make([]LimitLimitModelIncreaseDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseDistributionStatisticsesFromDict(data []LimitLimitModelIncreaseDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseDistributionSegment struct {
	CounterName *string `json:"counterName"`
	Count       *int64  `json:"count"`
}

func (p *LimitLimitModelIncreaseDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseDistributionSegment{}
	} else {
		*p = LimitLimitModelIncreaseDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseDistributionSegmentFromJson(data string) LimitLimitModelIncreaseDistributionSegment {
	req := LimitLimitModelIncreaseDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseDistributionSegmentFromDict(data map[string]interface{}) LimitLimitModelIncreaseDistributionSegment {
	return LimitLimitModelIncreaseDistributionSegment{
		CounterName: func() *string {
			v, ok := data["counterName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["counterName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p LimitLimitModelIncreaseDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.CounterName != nil {
		m["counterName"] = p.CounterName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p LimitLimitModelIncreaseDistributionSegment) Pointer() *LimitLimitModelIncreaseDistributionSegment {
	return &p
}

func CastLimitLimitModelIncreaseDistributionSegments(data []interface{}) []LimitLimitModelIncreaseDistributionSegment {
	v := make([]LimitLimitModelIncreaseDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseDistributionSegmentsFromDict(data []LimitLimitModelIncreaseDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseDistribution struct {
	Statistics   *LimitLimitModelIncreaseDistributionStatistics `json:"statistics"`
	Distribution []LimitLimitModelIncreaseDistributionSegment   `json:"distribution"`
}

func (p *LimitLimitModelIncreaseDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseDistribution{}
	} else {
		*p = LimitLimitModelIncreaseDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseDistributionFromJson(data string) LimitLimitModelIncreaseDistribution {
	req := LimitLimitModelIncreaseDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseDistributionFromDict(data map[string]interface{}) LimitLimitModelIncreaseDistribution {
	return LimitLimitModelIncreaseDistribution{
		Statistics: func() *LimitLimitModelIncreaseDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitLimitModelIncreaseDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LimitLimitModelIncreaseDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLimitLimitModelIncreaseDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LimitLimitModelIncreaseDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLimitLimitModelIncreaseDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LimitLimitModelIncreaseDistribution) Pointer() *LimitLimitModelIncreaseDistribution {
	return &p
}

func CastLimitLimitModelIncreaseDistributions(data []interface{}) []LimitLimitModelIncreaseDistribution {
	v := make([]LimitLimitModelIncreaseDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseDistributionsFromDict(data []LimitLimitModelIncreaseDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitLimitModelIncreaseAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountDistributionStatistics{}
	} else {
		*p = LimitLimitModelIncreaseAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountDistributionStatisticsFromJson(data string) LimitLimitModelIncreaseAmountDistributionStatistics {
	req := LimitLimitModelIncreaseAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountDistributionStatisticsFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountDistributionStatistics {
	return LimitLimitModelIncreaseAmountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LimitLimitModelIncreaseAmountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LimitLimitModelIncreaseAmountDistributionStatistics) Pointer() *LimitLimitModelIncreaseAmountDistributionStatistics {
	return &p
}

func CastLimitLimitModelIncreaseAmountDistributionStatisticses(data []interface{}) []LimitLimitModelIncreaseAmountDistributionStatistics {
	v := make([]LimitLimitModelIncreaseAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountDistributionStatisticsesFromDict(data []LimitLimitModelIncreaseAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountDistributionSegment struct {
	CounterName *string `json:"counterName"`
	Sum         *int64  `json:"sum"`
}

func (p *LimitLimitModelIncreaseAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountDistributionSegment{}
	} else {
		*p = LimitLimitModelIncreaseAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountDistributionSegmentFromJson(data string) LimitLimitModelIncreaseAmountDistributionSegment {
	req := LimitLimitModelIncreaseAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountDistributionSegmentFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountDistributionSegment {
	return LimitLimitModelIncreaseAmountDistributionSegment{
		CounterName: func() *string {
			v, ok := data["counterName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["counterName"])
		}(),
		Sum: func() *int64 {
			v, ok := data["sum"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sum"])
		}(),
	}
}

func (p LimitLimitModelIncreaseAmountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.CounterName != nil {
		m["counterName"] = p.CounterName
	}
	if p.Sum != nil {
		m["sum"] = p.Sum
	}
	return m
}

func (p LimitLimitModelIncreaseAmountDistributionSegment) Pointer() *LimitLimitModelIncreaseAmountDistributionSegment {
	return &p
}

func CastLimitLimitModelIncreaseAmountDistributionSegments(data []interface{}) []LimitLimitModelIncreaseAmountDistributionSegment {
	v := make([]LimitLimitModelIncreaseAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountDistributionSegmentsFromDict(data []LimitLimitModelIncreaseAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountDistribution struct {
	Statistics   *LimitLimitModelIncreaseAmountDistributionStatistics `json:"statistics"`
	Distribution []LimitLimitModelIncreaseAmountDistributionSegment   `json:"distribution"`
}

func (p *LimitLimitModelIncreaseAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountDistribution{}
	} else {
		*p = LimitLimitModelIncreaseAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountDistributionFromJson(data string) LimitLimitModelIncreaseAmountDistribution {
	req := LimitLimitModelIncreaseAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountDistributionFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountDistribution {
	return LimitLimitModelIncreaseAmountDistribution{
		Statistics: func() *LimitLimitModelIncreaseAmountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitLimitModelIncreaseAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LimitLimitModelIncreaseAmountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLimitLimitModelIncreaseAmountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LimitLimitModelIncreaseAmountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLimitLimitModelIncreaseAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LimitLimitModelIncreaseAmountDistribution) Pointer() *LimitLimitModelIncreaseAmountDistribution {
	return &p
}

func CastLimitLimitModelIncreaseAmountDistributions(data []interface{}) []LimitLimitModelIncreaseAmountDistribution {
	v := make([]LimitLimitModelIncreaseAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountDistributionsFromDict(data []LimitLimitModelIncreaseAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitLimitModelIncreaseByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseByUserDistributionStatistics{}
	} else {
		*p = LimitLimitModelIncreaseByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseByUserDistributionStatisticsFromJson(data string) LimitLimitModelIncreaseByUserDistributionStatistics {
	req := LimitLimitModelIncreaseByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseByUserDistributionStatisticsFromDict(data map[string]interface{}) LimitLimitModelIncreaseByUserDistributionStatistics {
	return LimitLimitModelIncreaseByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LimitLimitModelIncreaseByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LimitLimitModelIncreaseByUserDistributionStatistics) Pointer() *LimitLimitModelIncreaseByUserDistributionStatistics {
	return &p
}

func CastLimitLimitModelIncreaseByUserDistributionStatisticses(data []interface{}) []LimitLimitModelIncreaseByUserDistributionStatistics {
	v := make([]LimitLimitModelIncreaseByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseByUserDistributionStatisticsesFromDict(data []LimitLimitModelIncreaseByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *LimitLimitModelIncreaseByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseByUserDistributionSegment{}
	} else {
		*p = LimitLimitModelIncreaseByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseByUserDistributionSegmentFromJson(data string) LimitLimitModelIncreaseByUserDistributionSegment {
	req := LimitLimitModelIncreaseByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseByUserDistributionSegmentFromDict(data map[string]interface{}) LimitLimitModelIncreaseByUserDistributionSegment {
	return LimitLimitModelIncreaseByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p LimitLimitModelIncreaseByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p LimitLimitModelIncreaseByUserDistributionSegment) Pointer() *LimitLimitModelIncreaseByUserDistributionSegment {
	return &p
}

func CastLimitLimitModelIncreaseByUserDistributionSegments(data []interface{}) []LimitLimitModelIncreaseByUserDistributionSegment {
	v := make([]LimitLimitModelIncreaseByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseByUserDistributionSegmentsFromDict(data []LimitLimitModelIncreaseByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseByUserDistribution struct {
	Statistics   *LimitLimitModelIncreaseByUserDistributionStatistics `json:"statistics"`
	Distribution []LimitLimitModelIncreaseByUserDistributionSegment   `json:"distribution"`
}

func (p *LimitLimitModelIncreaseByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseByUserDistribution{}
	} else {
		*p = LimitLimitModelIncreaseByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseByUserDistributionFromJson(data string) LimitLimitModelIncreaseByUserDistribution {
	req := LimitLimitModelIncreaseByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseByUserDistributionFromDict(data map[string]interface{}) LimitLimitModelIncreaseByUserDistribution {
	return LimitLimitModelIncreaseByUserDistribution{
		Statistics: func() *LimitLimitModelIncreaseByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitLimitModelIncreaseByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LimitLimitModelIncreaseByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLimitLimitModelIncreaseByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LimitLimitModelIncreaseByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLimitLimitModelIncreaseByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LimitLimitModelIncreaseByUserDistribution) Pointer() *LimitLimitModelIncreaseByUserDistribution {
	return &p
}

func CastLimitLimitModelIncreaseByUserDistributions(data []interface{}) []LimitLimitModelIncreaseByUserDistribution {
	v := make([]LimitLimitModelIncreaseByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseByUserDistributionsFromDict(data []LimitLimitModelIncreaseByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitLimitModelIncreaseAmountByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountByUserDistributionStatistics{}
	} else {
		*p = LimitLimitModelIncreaseAmountByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountByUserDistributionStatisticsFromJson(data string) LimitLimitModelIncreaseAmountByUserDistributionStatistics {
	req := LimitLimitModelIncreaseAmountByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountByUserDistributionStatisticsFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountByUserDistributionStatistics {
	return LimitLimitModelIncreaseAmountByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LimitLimitModelIncreaseAmountByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LimitLimitModelIncreaseAmountByUserDistributionStatistics) Pointer() *LimitLimitModelIncreaseAmountByUserDistributionStatistics {
	return &p
}

func CastLimitLimitModelIncreaseAmountByUserDistributionStatisticses(data []interface{}) []LimitLimitModelIncreaseAmountByUserDistributionStatistics {
	v := make([]LimitLimitModelIncreaseAmountByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountByUserDistributionStatisticsesFromDict(data []LimitLimitModelIncreaseAmountByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *LimitLimitModelIncreaseAmountByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountByUserDistributionSegment{}
	} else {
		*p = LimitLimitModelIncreaseAmountByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountByUserDistributionSegmentFromJson(data string) LimitLimitModelIncreaseAmountByUserDistributionSegment {
	req := LimitLimitModelIncreaseAmountByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountByUserDistributionSegmentFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountByUserDistributionSegment {
	return LimitLimitModelIncreaseAmountByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p LimitLimitModelIncreaseAmountByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p LimitLimitModelIncreaseAmountByUserDistributionSegment) Pointer() *LimitLimitModelIncreaseAmountByUserDistributionSegment {
	return &p
}

func CastLimitLimitModelIncreaseAmountByUserDistributionSegments(data []interface{}) []LimitLimitModelIncreaseAmountByUserDistributionSegment {
	v := make([]LimitLimitModelIncreaseAmountByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountByUserDistributionSegmentsFromDict(data []LimitLimitModelIncreaseAmountByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelIncreaseAmountByUserDistribution struct {
	Statistics   *LimitLimitModelIncreaseAmountByUserDistributionStatistics `json:"statistics"`
	Distribution []LimitLimitModelIncreaseAmountByUserDistributionSegment   `json:"distribution"`
}

func (p *LimitLimitModelIncreaseAmountByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelIncreaseAmountByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelIncreaseAmountByUserDistribution{}
	} else {
		*p = LimitLimitModelIncreaseAmountByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitLimitModelIncreaseAmountByUserDistributionFromJson(data string) LimitLimitModelIncreaseAmountByUserDistribution {
	req := LimitLimitModelIncreaseAmountByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelIncreaseAmountByUserDistributionFromDict(data map[string]interface{}) LimitLimitModelIncreaseAmountByUserDistribution {
	return LimitLimitModelIncreaseAmountByUserDistribution{
		Statistics: func() *LimitLimitModelIncreaseAmountByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitLimitModelIncreaseAmountByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LimitLimitModelIncreaseAmountByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLimitLimitModelIncreaseAmountByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LimitLimitModelIncreaseAmountByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLimitLimitModelIncreaseAmountByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LimitLimitModelIncreaseAmountByUserDistribution) Pointer() *LimitLimitModelIncreaseAmountByUserDistribution {
	return &p
}

func CastLimitLimitModelIncreaseAmountByUserDistributions(data []interface{}) []LimitLimitModelIncreaseAmountByUserDistribution {
	v := make([]LimitLimitModelIncreaseAmountByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelIncreaseAmountByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelIncreaseAmountByUserDistributionsFromDict(data []LimitLimitModelIncreaseAmountByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModelDistributions struct {
	Increase             *LimitLimitModelIncreaseDistribution             `json:"increase"`
	IncreaseAmount       *LimitLimitModelIncreaseAmountDistribution       `json:"increaseAmount"`
	IncreaseByUser       *LimitLimitModelIncreaseByUserDistribution       `json:"increaseByUser"`
	IncreaseAmountByUser *LimitLimitModelIncreaseAmountByUserDistribution `json:"increaseAmountByUser"`
}

func (p *LimitLimitModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModelDistributions{}
	} else {
		*p = LimitLimitModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
		if v, ok := d["increaseAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmount)
		}
		if v, ok := d["increaseByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseByUser)
		}
		if v, ok := d["increaseAmountByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmountByUser)
		}
	}
	return nil
}

func NewLimitLimitModelDistributionsFromJson(data string) LimitLimitModelDistributions {
	req := LimitLimitModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelDistributionsFromDict(data map[string]interface{}) LimitLimitModelDistributions {
	return LimitLimitModelDistributions{
		Increase: func() *LimitLimitModelIncreaseDistribution {
			v, ok := data["increase"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitLimitModelIncreaseDistributionFromDict(core.CastMap(data["increase"])).Pointer()
		}(),
		IncreaseAmount: func() *LimitLimitModelIncreaseAmountDistribution {
			v, ok := data["increaseAmount"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitLimitModelIncreaseAmountDistributionFromDict(core.CastMap(data["increaseAmount"])).Pointer()
		}(),
		IncreaseByUser: func() *LimitLimitModelIncreaseByUserDistribution {
			v, ok := data["increaseByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitLimitModelIncreaseByUserDistributionFromDict(core.CastMap(data["increaseByUser"])).Pointer()
		}(),
		IncreaseAmountByUser: func() *LimitLimitModelIncreaseAmountByUserDistribution {
			v, ok := data["increaseAmountByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitLimitModelIncreaseAmountByUserDistributionFromDict(core.CastMap(data["increaseAmountByUser"])).Pointer()
		}(),
	}
}

func (p LimitLimitModelDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Increase != nil {
		m["increase"] = func() map[string]interface{} {
			if p.Increase == nil {
				return nil
			}
			return p.Increase.ToDict()
		}()
	}
	if p.IncreaseAmount != nil {
		m["increaseAmount"] = func() map[string]interface{} {
			if p.IncreaseAmount == nil {
				return nil
			}
			return p.IncreaseAmount.ToDict()
		}()
	}
	if p.IncreaseByUser != nil {
		m["increaseByUser"] = func() map[string]interface{} {
			if p.IncreaseByUser == nil {
				return nil
			}
			return p.IncreaseByUser.ToDict()
		}()
	}
	if p.IncreaseAmountByUser != nil {
		m["increaseAmountByUser"] = func() map[string]interface{} {
			if p.IncreaseAmountByUser == nil {
				return nil
			}
			return p.IncreaseAmountByUser.ToDict()
		}()
	}
	return m
}

func (p LimitLimitModelDistributions) Pointer() *LimitLimitModelDistributions {
	return &p
}

func CastLimitLimitModelDistributionses(data []interface{}) []LimitLimitModelDistributions {
	v := make([]LimitLimitModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelDistributionsesFromDict(data []LimitLimitModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitLimitModel struct {
	LimitModelId  *string                       `json:"limitModelId"`
	LimitName     *string                       `json:"limitName"`
	Statistics    *LimitLimitModelStatistics    `json:"statistics"`
	Distributions *LimitLimitModelDistributions `json:"distributions"`
	Counters      []LimitCounter                `json:"counters"`
}

func (p *LimitLimitModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitLimitModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitLimitModel{}
	} else {
		*p = LimitLimitModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["limitModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LimitModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LimitModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LimitModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LimitModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LimitModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LimitModelId)
				}
			}
		}
		if v, ok := d["limitName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LimitName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LimitName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LimitName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LimitName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["counters"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Counters)
		}
	}
	return nil
}

func NewLimitLimitModelFromJson(data string) LimitLimitModel {
	req := LimitLimitModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitLimitModelFromDict(data map[string]interface{}) LimitLimitModel {
	return LimitLimitModel{
		LimitModelId: func() *string {
			v, ok := data["limitModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["limitModelId"])
		}(),
		LimitName: func() *string {
			v, ok := data["limitName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["limitName"])
		}(),
		Statistics: func() *LimitLimitModelStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitLimitModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *LimitLimitModelDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitLimitModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		Counters: func() []LimitCounter {
			if data["counters"] == nil {
				return nil
			}
			return CastLimitCounters(core.CastArray(data["counters"]))
		}(),
	}
}

func (p LimitLimitModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.LimitModelId != nil {
		m["limitModelId"] = p.LimitModelId
	}
	if p.LimitName != nil {
		m["limitName"] = p.LimitName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.Counters != nil {
		m["counters"] = CastLimitCountersFromDict(
			p.Counters,
		)
	}
	return m
}

func (p LimitLimitModel) Pointer() *LimitLimitModel {
	return &p
}

func CastLimitLimitModels(data []interface{}) []LimitLimitModel {
	v := make([]LimitLimitModel, 0)
	for _, d := range data {
		v = append(v, NewLimitLimitModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitLimitModelsFromDict(data []LimitLimitModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespaceStatistics struct {
	Increase *int64 `json:"increase"`
}

func (p *LimitNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespaceStatistics{}
	} else {
		*p = LimitNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
	}
	return nil
}

func NewLimitNamespaceStatisticsFromJson(data string) LimitNamespaceStatistics {
	req := LimitNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceStatisticsFromDict(data map[string]interface{}) LimitNamespaceStatistics {
	return LimitNamespaceStatistics{
		Increase: func() *int64 {
			v, ok := data["increase"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increase"])
		}(),
	}
}

func (p LimitNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Increase != nil {
		m["increase"] = p.Increase
	}
	return m
}

func (p LimitNamespaceStatistics) Pointer() *LimitNamespaceStatistics {
	return &p
}

func CastLimitNamespaceStatisticses(data []interface{}) []LimitNamespaceStatistics {
	v := make([]LimitNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespaceStatisticsesFromDict(data []LimitNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespaceIncreaseDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LimitNamespaceIncreaseDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespaceIncreaseDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespaceIncreaseDistributionStatistics{}
	} else {
		*p = LimitNamespaceIncreaseDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLimitNamespaceIncreaseDistributionStatisticsFromJson(data string) LimitNamespaceIncreaseDistributionStatistics {
	req := LimitNamespaceIncreaseDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceIncreaseDistributionStatisticsFromDict(data map[string]interface{}) LimitNamespaceIncreaseDistributionStatistics {
	return LimitNamespaceIncreaseDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LimitNamespaceIncreaseDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LimitNamespaceIncreaseDistributionStatistics) Pointer() *LimitNamespaceIncreaseDistributionStatistics {
	return &p
}

func CastLimitNamespaceIncreaseDistributionStatisticses(data []interface{}) []LimitNamespaceIncreaseDistributionStatistics {
	v := make([]LimitNamespaceIncreaseDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceIncreaseDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespaceIncreaseDistributionStatisticsesFromDict(data []LimitNamespaceIncreaseDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespaceIncreaseDistributionSegment struct {
	LimitName *string `json:"limitName"`
	Count     *int64  `json:"count"`
}

func (p *LimitNamespaceIncreaseDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespaceIncreaseDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespaceIncreaseDistributionSegment{}
	} else {
		*p = LimitNamespaceIncreaseDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["limitName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LimitName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LimitName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LimitName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LimitName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LimitName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLimitNamespaceIncreaseDistributionSegmentFromJson(data string) LimitNamespaceIncreaseDistributionSegment {
	req := LimitNamespaceIncreaseDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceIncreaseDistributionSegmentFromDict(data map[string]interface{}) LimitNamespaceIncreaseDistributionSegment {
	return LimitNamespaceIncreaseDistributionSegment{
		LimitName: func() *string {
			v, ok := data["limitName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["limitName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p LimitNamespaceIncreaseDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.LimitName != nil {
		m["limitName"] = p.LimitName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p LimitNamespaceIncreaseDistributionSegment) Pointer() *LimitNamespaceIncreaseDistributionSegment {
	return &p
}

func CastLimitNamespaceIncreaseDistributionSegments(data []interface{}) []LimitNamespaceIncreaseDistributionSegment {
	v := make([]LimitNamespaceIncreaseDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceIncreaseDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespaceIncreaseDistributionSegmentsFromDict(data []LimitNamespaceIncreaseDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespaceIncreaseDistribution struct {
	Statistics   *LimitNamespaceIncreaseDistributionStatistics `json:"statistics"`
	Distribution []LimitNamespaceIncreaseDistributionSegment   `json:"distribution"`
}

func (p *LimitNamespaceIncreaseDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespaceIncreaseDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespaceIncreaseDistribution{}
	} else {
		*p = LimitNamespaceIncreaseDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLimitNamespaceIncreaseDistributionFromJson(data string) LimitNamespaceIncreaseDistribution {
	req := LimitNamespaceIncreaseDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceIncreaseDistributionFromDict(data map[string]interface{}) LimitNamespaceIncreaseDistribution {
	return LimitNamespaceIncreaseDistribution{
		Statistics: func() *LimitNamespaceIncreaseDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitNamespaceIncreaseDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LimitNamespaceIncreaseDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLimitNamespaceIncreaseDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LimitNamespaceIncreaseDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLimitNamespaceIncreaseDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LimitNamespaceIncreaseDistribution) Pointer() *LimitNamespaceIncreaseDistribution {
	return &p
}

func CastLimitNamespaceIncreaseDistributions(data []interface{}) []LimitNamespaceIncreaseDistribution {
	v := make([]LimitNamespaceIncreaseDistribution, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceIncreaseDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespaceIncreaseDistributionsFromDict(data []LimitNamespaceIncreaseDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespaceDistributions struct {
	Increase *LimitNamespaceIncreaseDistribution `json:"increase"`
}

func (p *LimitNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespaceDistributions{}
	} else {
		*p = LimitNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
	}
	return nil
}

func NewLimitNamespaceDistributionsFromJson(data string) LimitNamespaceDistributions {
	req := LimitNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceDistributionsFromDict(data map[string]interface{}) LimitNamespaceDistributions {
	return LimitNamespaceDistributions{
		Increase: func() *LimitNamespaceIncreaseDistribution {
			v, ok := data["increase"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitNamespaceIncreaseDistributionFromDict(core.CastMap(data["increase"])).Pointer()
		}(),
	}
}

func (p LimitNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Increase != nil {
		m["increase"] = func() map[string]interface{} {
			if p.Increase == nil {
				return nil
			}
			return p.Increase.ToDict()
		}()
	}
	return m
}

func (p LimitNamespaceDistributions) Pointer() *LimitNamespaceDistributions {
	return &p
}

func CastLimitNamespaceDistributionses(data []interface{}) []LimitNamespaceDistributions {
	v := make([]LimitNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespaceDistributionsesFromDict(data []LimitNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LimitNamespace struct {
	NamespaceId   *string                      `json:"namespaceId"`
	Year          *int32                       `json:"year"`
	Month         *int32                       `json:"month"`
	Day           *int32                       `json:"day"`
	NamespaceName *string                      `json:"namespaceName"`
	Statistics    *LimitNamespaceStatistics    `json:"statistics"`
	Distributions *LimitNamespaceDistributions `json:"distributions"`
	LimitModels   []LimitLimitModel            `json:"limitModels"`
}

func (p *LimitNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LimitNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LimitNamespace{}
	} else {
		*p = LimitNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["limitModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.LimitModels)
		}
	}
	return nil
}

func NewLimitNamespaceFromJson(data string) LimitNamespace {
	req := LimitNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLimitNamespaceFromDict(data map[string]interface{}) LimitNamespace {
	return LimitNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *LimitNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *LimitNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewLimitNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		LimitModels: func() []LimitLimitModel {
			if data["limitModels"] == nil {
				return nil
			}
			return CastLimitLimitModels(core.CastArray(data["limitModels"]))
		}(),
	}
}

func (p LimitNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.LimitModels != nil {
		m["limitModels"] = CastLimitLimitModelsFromDict(
			p.LimitModels,
		)
	}
	return m
}

func (p LimitNamespace) Pointer() *LimitNamespace {
	return &p
}

func CastLimitNamespaces(data []interface{}) []LimitNamespace {
	v := make([]LimitNamespace, 0)
	for _, d := range data {
		v = append(v, NewLimitNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLimitNamespacesFromDict(data []LimitNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryStatistics struct {
	Draw       *int64 `json:"draw"`
	DrawAmount *int64 `json:"drawAmount"`
}

func (p *LotteryLotteryStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryStatistics{}
	} else {
		*p = LotteryLotteryStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["draw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Draw)
		}
		if v, ok := d["drawAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawAmount)
		}
	}
	return nil
}

func NewLotteryLotteryStatisticsFromJson(data string) LotteryLotteryStatistics {
	req := LotteryLotteryStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryStatisticsFromDict(data map[string]interface{}) LotteryLotteryStatistics {
	return LotteryLotteryStatistics{
		Draw: func() *int64 {
			v, ok := data["draw"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["draw"])
		}(),
		DrawAmount: func() *int64 {
			v, ok := data["drawAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["drawAmount"])
		}(),
	}
}

func (p LotteryLotteryStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Draw != nil {
		m["draw"] = p.Draw
	}
	if p.DrawAmount != nil {
		m["drawAmount"] = p.DrawAmount
	}
	return m
}

func (p LotteryLotteryStatistics) Pointer() *LotteryLotteryStatistics {
	return &p
}

func CastLotteryLotteryStatisticses(data []interface{}) []LotteryLotteryStatistics {
	v := make([]LotteryLotteryStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryStatisticsesFromDict(data []LotteryLotteryStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryDrawResultDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LotteryLotteryDrawResultDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryDrawResultDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryDrawResultDistributionStatistics{}
	} else {
		*p = LotteryLotteryDrawResultDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLotteryLotteryDrawResultDistributionStatisticsFromJson(data string) LotteryLotteryDrawResultDistributionStatistics {
	req := LotteryLotteryDrawResultDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryDrawResultDistributionStatisticsFromDict(data map[string]interface{}) LotteryLotteryDrawResultDistributionStatistics {
	return LotteryLotteryDrawResultDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LotteryLotteryDrawResultDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LotteryLotteryDrawResultDistributionStatistics) Pointer() *LotteryLotteryDrawResultDistributionStatistics {
	return &p
}

func CastLotteryLotteryDrawResultDistributionStatisticses(data []interface{}) []LotteryLotteryDrawResultDistributionStatistics {
	v := make([]LotteryLotteryDrawResultDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryDrawResultDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryDrawResultDistributionStatisticsesFromDict(data []LotteryLotteryDrawResultDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryDrawResultDistributionSegment struct {
	PrizeId *string `json:"prizeId"`
	Count   *int64  `json:"count"`
}

func (p *LotteryLotteryDrawResultDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryDrawResultDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryDrawResultDistributionSegment{}
	} else {
		*p = LotteryLotteryDrawResultDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["prizeId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.PrizeId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.PrizeId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.PrizeId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.PrizeId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.PrizeId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.PrizeId)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLotteryLotteryDrawResultDistributionSegmentFromJson(data string) LotteryLotteryDrawResultDistributionSegment {
	req := LotteryLotteryDrawResultDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryDrawResultDistributionSegmentFromDict(data map[string]interface{}) LotteryLotteryDrawResultDistributionSegment {
	return LotteryLotteryDrawResultDistributionSegment{
		PrizeId: func() *string {
			v, ok := data["prizeId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["prizeId"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p LotteryLotteryDrawResultDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.PrizeId != nil {
		m["prizeId"] = p.PrizeId
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p LotteryLotteryDrawResultDistributionSegment) Pointer() *LotteryLotteryDrawResultDistributionSegment {
	return &p
}

func CastLotteryLotteryDrawResultDistributionSegments(data []interface{}) []LotteryLotteryDrawResultDistributionSegment {
	v := make([]LotteryLotteryDrawResultDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryDrawResultDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryDrawResultDistributionSegmentsFromDict(data []LotteryLotteryDrawResultDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryDrawResultDistribution struct {
	Statistics   *LotteryLotteryDrawResultDistributionStatistics `json:"statistics"`
	Distribution []LotteryLotteryDrawResultDistributionSegment   `json:"distribution"`
}

func (p *LotteryLotteryDrawResultDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryDrawResultDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryDrawResultDistribution{}
	} else {
		*p = LotteryLotteryDrawResultDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLotteryLotteryDrawResultDistributionFromJson(data string) LotteryLotteryDrawResultDistribution {
	req := LotteryLotteryDrawResultDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryDrawResultDistributionFromDict(data map[string]interface{}) LotteryLotteryDrawResultDistribution {
	return LotteryLotteryDrawResultDistribution{
		Statistics: func() *LotteryLotteryDrawResultDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryLotteryDrawResultDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LotteryLotteryDrawResultDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLotteryLotteryDrawResultDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LotteryLotteryDrawResultDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLotteryLotteryDrawResultDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LotteryLotteryDrawResultDistribution) Pointer() *LotteryLotteryDrawResultDistribution {
	return &p
}

func CastLotteryLotteryDrawResultDistributions(data []interface{}) []LotteryLotteryDrawResultDistribution {
	v := make([]LotteryLotteryDrawResultDistribution, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryDrawResultDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryDrawResultDistributionsFromDict(data []LotteryLotteryDrawResultDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryDistributions struct {
	DrawResult *LotteryLotteryDrawResultDistribution `json:"drawResult"`
}

func (p *LotteryLotteryDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryDistributions{}
	} else {
		*p = LotteryLotteryDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["drawResult"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawResult)
		}
	}
	return nil
}

func NewLotteryLotteryDistributionsFromJson(data string) LotteryLotteryDistributions {
	req := LotteryLotteryDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryDistributionsFromDict(data map[string]interface{}) LotteryLotteryDistributions {
	return LotteryLotteryDistributions{
		DrawResult: func() *LotteryLotteryDrawResultDistribution {
			v, ok := data["drawResult"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryLotteryDrawResultDistributionFromDict(core.CastMap(data["drawResult"])).Pointer()
		}(),
	}
}

func (p LotteryLotteryDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.DrawResult != nil {
		m["drawResult"] = func() map[string]interface{} {
			if p.DrawResult == nil {
				return nil
			}
			return p.DrawResult.ToDict()
		}()
	}
	return m
}

func (p LotteryLotteryDistributions) Pointer() *LotteryLotteryDistributions {
	return &p
}

func CastLotteryLotteryDistributionses(data []interface{}) []LotteryLotteryDistributions {
	v := make([]LotteryLotteryDistributions, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryDistributionsesFromDict(data []LotteryLotteryDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLottery struct {
	LotteryId     *string                      `json:"lotteryId"`
	LotteryName   *string                      `json:"lotteryName"`
	Statistics    *LotteryLotteryStatistics    `json:"statistics"`
	Distributions *LotteryLotteryDistributions `json:"distributions"`
}

func (p *LotteryLottery) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLottery{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLottery{}
	} else {
		*p = LotteryLottery{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["lotteryId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryId)
				}
			}
		}
		if v, ok := d["lotteryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewLotteryLotteryFromJson(data string) LotteryLottery {
	req := LotteryLottery{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryFromDict(data map[string]interface{}) LotteryLottery {
	return LotteryLottery{
		LotteryId: func() *string {
			v, ok := data["lotteryId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["lotteryId"])
		}(),
		LotteryName: func() *string {
			v, ok := data["lotteryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["lotteryName"])
		}(),
		Statistics: func() *LotteryLotteryStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryLotteryStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *LotteryLotteryDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryLotteryDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p LotteryLottery) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.LotteryId != nil {
		m["lotteryId"] = p.LotteryId
	}
	if p.LotteryName != nil {
		m["lotteryName"] = p.LotteryName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p LotteryLottery) Pointer() *LotteryLottery {
	return &p
}

func CastLotteryLotteries(data []interface{}) []LotteryLottery {
	v := make([]LotteryLottery, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteriesFromDict(data []LotteryLottery) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceStatistics struct {
	Draw       *int64 `json:"draw"`
	DrawAmount *int64 `json:"drawAmount"`
}

func (p *LotteryNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceStatistics{}
	} else {
		*p = LotteryNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["draw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Draw)
		}
		if v, ok := d["drawAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawAmount)
		}
	}
	return nil
}

func NewLotteryNamespaceStatisticsFromJson(data string) LotteryNamespaceStatistics {
	req := LotteryNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceStatisticsFromDict(data map[string]interface{}) LotteryNamespaceStatistics {
	return LotteryNamespaceStatistics{
		Draw: func() *int64 {
			v, ok := data["draw"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["draw"])
		}(),
		DrawAmount: func() *int64 {
			v, ok := data["drawAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["drawAmount"])
		}(),
	}
}

func (p LotteryNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Draw != nil {
		m["draw"] = p.Draw
	}
	if p.DrawAmount != nil {
		m["drawAmount"] = p.DrawAmount
	}
	return m
}

func (p LotteryNamespaceStatistics) Pointer() *LotteryNamespaceStatistics {
	return &p
}

func CastLotteryNamespaceStatisticses(data []interface{}) []LotteryNamespaceStatistics {
	v := make([]LotteryNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceStatisticsesFromDict(data []LotteryNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LotteryNamespaceDrawDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawDistributionStatistics{}
	} else {
		*p = LotteryNamespaceDrawDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawDistributionStatisticsFromJson(data string) LotteryNamespaceDrawDistributionStatistics {
	req := LotteryNamespaceDrawDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawDistributionStatisticsFromDict(data map[string]interface{}) LotteryNamespaceDrawDistributionStatistics {
	return LotteryNamespaceDrawDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LotteryNamespaceDrawDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LotteryNamespaceDrawDistributionStatistics) Pointer() *LotteryNamespaceDrawDistributionStatistics {
	return &p
}

func CastLotteryNamespaceDrawDistributionStatisticses(data []interface{}) []LotteryNamespaceDrawDistributionStatistics {
	v := make([]LotteryNamespaceDrawDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawDistributionStatisticsesFromDict(data []LotteryNamespaceDrawDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawDistributionSegment struct {
	LotteryName *string `json:"lotteryName"`
	Count       *int64  `json:"count"`
}

func (p *LotteryNamespaceDrawDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawDistributionSegment{}
	} else {
		*p = LotteryNamespaceDrawDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["lotteryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawDistributionSegmentFromJson(data string) LotteryNamespaceDrawDistributionSegment {
	req := LotteryNamespaceDrawDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawDistributionSegmentFromDict(data map[string]interface{}) LotteryNamespaceDrawDistributionSegment {
	return LotteryNamespaceDrawDistributionSegment{
		LotteryName: func() *string {
			v, ok := data["lotteryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["lotteryName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p LotteryNamespaceDrawDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.LotteryName != nil {
		m["lotteryName"] = p.LotteryName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p LotteryNamespaceDrawDistributionSegment) Pointer() *LotteryNamespaceDrawDistributionSegment {
	return &p
}

func CastLotteryNamespaceDrawDistributionSegments(data []interface{}) []LotteryNamespaceDrawDistributionSegment {
	v := make([]LotteryNamespaceDrawDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawDistributionSegmentsFromDict(data []LotteryNamespaceDrawDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawDistribution struct {
	Statistics   *LotteryNamespaceDrawDistributionStatistics `json:"statistics"`
	Distribution []LotteryNamespaceDrawDistributionSegment   `json:"distribution"`
}

func (p *LotteryNamespaceDrawDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawDistribution{}
	} else {
		*p = LotteryNamespaceDrawDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawDistributionFromJson(data string) LotteryNamespaceDrawDistribution {
	req := LotteryNamespaceDrawDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawDistributionFromDict(data map[string]interface{}) LotteryNamespaceDrawDistribution {
	return LotteryNamespaceDrawDistribution{
		Statistics: func() *LotteryNamespaceDrawDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryNamespaceDrawDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LotteryNamespaceDrawDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLotteryNamespaceDrawDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LotteryNamespaceDrawDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLotteryNamespaceDrawDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LotteryNamespaceDrawDistribution) Pointer() *LotteryNamespaceDrawDistribution {
	return &p
}

func CastLotteryNamespaceDrawDistributions(data []interface{}) []LotteryNamespaceDrawDistribution {
	v := make([]LotteryNamespaceDrawDistribution, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawDistributionsFromDict(data []LotteryNamespaceDrawDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LotteryNamespaceDrawAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountDistributionStatistics{}
	} else {
		*p = LotteryNamespaceDrawAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountDistributionStatisticsFromJson(data string) LotteryNamespaceDrawAmountDistributionStatistics {
	req := LotteryNamespaceDrawAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountDistributionStatisticsFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountDistributionStatistics {
	return LotteryNamespaceDrawAmountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LotteryNamespaceDrawAmountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LotteryNamespaceDrawAmountDistributionStatistics) Pointer() *LotteryNamespaceDrawAmountDistributionStatistics {
	return &p
}

func CastLotteryNamespaceDrawAmountDistributionStatisticses(data []interface{}) []LotteryNamespaceDrawAmountDistributionStatistics {
	v := make([]LotteryNamespaceDrawAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountDistributionStatisticsesFromDict(data []LotteryNamespaceDrawAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountDistributionSegment struct {
	LotteryName *string `json:"lotteryName"`
	Sum         *int64  `json:"sum"`
}

func (p *LotteryNamespaceDrawAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountDistributionSegment{}
	} else {
		*p = LotteryNamespaceDrawAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["lotteryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountDistributionSegmentFromJson(data string) LotteryNamespaceDrawAmountDistributionSegment {
	req := LotteryNamespaceDrawAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountDistributionSegmentFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountDistributionSegment {
	return LotteryNamespaceDrawAmountDistributionSegment{
		LotteryName: func() *string {
			v, ok := data["lotteryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["lotteryName"])
		}(),
		Sum: func() *int64 {
			v, ok := data["sum"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sum"])
		}(),
	}
}

func (p LotteryNamespaceDrawAmountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.LotteryName != nil {
		m["lotteryName"] = p.LotteryName
	}
	if p.Sum != nil {
		m["sum"] = p.Sum
	}
	return m
}

func (p LotteryNamespaceDrawAmountDistributionSegment) Pointer() *LotteryNamespaceDrawAmountDistributionSegment {
	return &p
}

func CastLotteryNamespaceDrawAmountDistributionSegments(data []interface{}) []LotteryNamespaceDrawAmountDistributionSegment {
	v := make([]LotteryNamespaceDrawAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountDistributionSegmentsFromDict(data []LotteryNamespaceDrawAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountDistribution struct {
	Statistics   *LotteryNamespaceDrawAmountDistributionStatistics `json:"statistics"`
	Distribution []LotteryNamespaceDrawAmountDistributionSegment   `json:"distribution"`
}

func (p *LotteryNamespaceDrawAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountDistribution{}
	} else {
		*p = LotteryNamespaceDrawAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountDistributionFromJson(data string) LotteryNamespaceDrawAmountDistribution {
	req := LotteryNamespaceDrawAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountDistributionFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountDistribution {
	return LotteryNamespaceDrawAmountDistribution{
		Statistics: func() *LotteryNamespaceDrawAmountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryNamespaceDrawAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LotteryNamespaceDrawAmountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLotteryNamespaceDrawAmountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LotteryNamespaceDrawAmountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLotteryNamespaceDrawAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LotteryNamespaceDrawAmountDistribution) Pointer() *LotteryNamespaceDrawAmountDistribution {
	return &p
}

func CastLotteryNamespaceDrawAmountDistributions(data []interface{}) []LotteryNamespaceDrawAmountDistribution {
	v := make([]LotteryNamespaceDrawAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountDistributionsFromDict(data []LotteryNamespaceDrawAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LotteryNamespaceDrawByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawByUserDistributionStatistics{}
	} else {
		*p = LotteryNamespaceDrawByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawByUserDistributionStatisticsFromJson(data string) LotteryNamespaceDrawByUserDistributionStatistics {
	req := LotteryNamespaceDrawByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawByUserDistributionStatisticsFromDict(data map[string]interface{}) LotteryNamespaceDrawByUserDistributionStatistics {
	return LotteryNamespaceDrawByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LotteryNamespaceDrawByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LotteryNamespaceDrawByUserDistributionStatistics) Pointer() *LotteryNamespaceDrawByUserDistributionStatistics {
	return &p
}

func CastLotteryNamespaceDrawByUserDistributionStatisticses(data []interface{}) []LotteryNamespaceDrawByUserDistributionStatistics {
	v := make([]LotteryNamespaceDrawByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawByUserDistributionStatisticsesFromDict(data []LotteryNamespaceDrawByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *LotteryNamespaceDrawByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawByUserDistributionSegment{}
	} else {
		*p = LotteryNamespaceDrawByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawByUserDistributionSegmentFromJson(data string) LotteryNamespaceDrawByUserDistributionSegment {
	req := LotteryNamespaceDrawByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawByUserDistributionSegmentFromDict(data map[string]interface{}) LotteryNamespaceDrawByUserDistributionSegment {
	return LotteryNamespaceDrawByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p LotteryNamespaceDrawByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p LotteryNamespaceDrawByUserDistributionSegment) Pointer() *LotteryNamespaceDrawByUserDistributionSegment {
	return &p
}

func CastLotteryNamespaceDrawByUserDistributionSegments(data []interface{}) []LotteryNamespaceDrawByUserDistributionSegment {
	v := make([]LotteryNamespaceDrawByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawByUserDistributionSegmentsFromDict(data []LotteryNamespaceDrawByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawByUserDistribution struct {
	Statistics   *LotteryNamespaceDrawByUserDistributionStatistics `json:"statistics"`
	Distribution []LotteryNamespaceDrawByUserDistributionSegment   `json:"distribution"`
}

func (p *LotteryNamespaceDrawByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawByUserDistribution{}
	} else {
		*p = LotteryNamespaceDrawByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawByUserDistributionFromJson(data string) LotteryNamespaceDrawByUserDistribution {
	req := LotteryNamespaceDrawByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawByUserDistributionFromDict(data map[string]interface{}) LotteryNamespaceDrawByUserDistribution {
	return LotteryNamespaceDrawByUserDistribution{
		Statistics: func() *LotteryNamespaceDrawByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryNamespaceDrawByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LotteryNamespaceDrawByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLotteryNamespaceDrawByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LotteryNamespaceDrawByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLotteryNamespaceDrawByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LotteryNamespaceDrawByUserDistribution) Pointer() *LotteryNamespaceDrawByUserDistribution {
	return &p
}

func CastLotteryNamespaceDrawByUserDistributions(data []interface{}) []LotteryNamespaceDrawByUserDistribution {
	v := make([]LotteryNamespaceDrawByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawByUserDistributionsFromDict(data []LotteryNamespaceDrawByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *LotteryNamespaceDrawAmountByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountByUserDistributionStatistics{}
	} else {
		*p = LotteryNamespaceDrawAmountByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountByUserDistributionStatisticsFromJson(data string) LotteryNamespaceDrawAmountByUserDistributionStatistics {
	req := LotteryNamespaceDrawAmountByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountByUserDistributionStatisticsFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountByUserDistributionStatistics {
	return LotteryNamespaceDrawAmountByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p LotteryNamespaceDrawAmountByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p LotteryNamespaceDrawAmountByUserDistributionStatistics) Pointer() *LotteryNamespaceDrawAmountByUserDistributionStatistics {
	return &p
}

func CastLotteryNamespaceDrawAmountByUserDistributionStatisticses(data []interface{}) []LotteryNamespaceDrawAmountByUserDistributionStatistics {
	v := make([]LotteryNamespaceDrawAmountByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountByUserDistributionStatisticsesFromDict(data []LotteryNamespaceDrawAmountByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *LotteryNamespaceDrawAmountByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountByUserDistributionSegment{}
	} else {
		*p = LotteryNamespaceDrawAmountByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountByUserDistributionSegmentFromJson(data string) LotteryNamespaceDrawAmountByUserDistributionSegment {
	req := LotteryNamespaceDrawAmountByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountByUserDistributionSegmentFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountByUserDistributionSegment {
	return LotteryNamespaceDrawAmountByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p LotteryNamespaceDrawAmountByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p LotteryNamespaceDrawAmountByUserDistributionSegment) Pointer() *LotteryNamespaceDrawAmountByUserDistributionSegment {
	return &p
}

func CastLotteryNamespaceDrawAmountByUserDistributionSegments(data []interface{}) []LotteryNamespaceDrawAmountByUserDistributionSegment {
	v := make([]LotteryNamespaceDrawAmountByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountByUserDistributionSegmentsFromDict(data []LotteryNamespaceDrawAmountByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDrawAmountByUserDistribution struct {
	Statistics   *LotteryNamespaceDrawAmountByUserDistributionStatistics `json:"statistics"`
	Distribution []LotteryNamespaceDrawAmountByUserDistributionSegment   `json:"distribution"`
}

func (p *LotteryNamespaceDrawAmountByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDrawAmountByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDrawAmountByUserDistribution{}
	} else {
		*p = LotteryNamespaceDrawAmountByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewLotteryNamespaceDrawAmountByUserDistributionFromJson(data string) LotteryNamespaceDrawAmountByUserDistribution {
	req := LotteryNamespaceDrawAmountByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDrawAmountByUserDistributionFromDict(data map[string]interface{}) LotteryNamespaceDrawAmountByUserDistribution {
	return LotteryNamespaceDrawAmountByUserDistribution{
		Statistics: func() *LotteryNamespaceDrawAmountByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryNamespaceDrawAmountByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []LotteryNamespaceDrawAmountByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastLotteryNamespaceDrawAmountByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p LotteryNamespaceDrawAmountByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastLotteryNamespaceDrawAmountByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p LotteryNamespaceDrawAmountByUserDistribution) Pointer() *LotteryNamespaceDrawAmountByUserDistribution {
	return &p
}

func CastLotteryNamespaceDrawAmountByUserDistributions(data []interface{}) []LotteryNamespaceDrawAmountByUserDistribution {
	v := make([]LotteryNamespaceDrawAmountByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDrawAmountByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDrawAmountByUserDistributionsFromDict(data []LotteryNamespaceDrawAmountByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespaceDistributions struct {
	Draw             *LotteryNamespaceDrawDistribution             `json:"draw"`
	DrawAmount       *LotteryNamespaceDrawAmountDistribution       `json:"drawAmount"`
	DrawByUser       *LotteryNamespaceDrawByUserDistribution       `json:"drawByUser"`
	DrawAmountByUser *LotteryNamespaceDrawAmountByUserDistribution `json:"drawAmountByUser"`
}

func (p *LotteryNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespaceDistributions{}
	} else {
		*p = LotteryNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["draw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Draw)
		}
		if v, ok := d["drawAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawAmount)
		}
		if v, ok := d["drawByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawByUser)
		}
		if v, ok := d["drawAmountByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DrawAmountByUser)
		}
	}
	return nil
}

func NewLotteryNamespaceDistributionsFromJson(data string) LotteryNamespaceDistributions {
	req := LotteryNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceDistributionsFromDict(data map[string]interface{}) LotteryNamespaceDistributions {
	return LotteryNamespaceDistributions{
		Draw: func() *LotteryNamespaceDrawDistribution {
			v, ok := data["draw"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryNamespaceDrawDistributionFromDict(core.CastMap(data["draw"])).Pointer()
		}(),
		DrawAmount: func() *LotteryNamespaceDrawAmountDistribution {
			v, ok := data["drawAmount"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryNamespaceDrawAmountDistributionFromDict(core.CastMap(data["drawAmount"])).Pointer()
		}(),
		DrawByUser: func() *LotteryNamespaceDrawByUserDistribution {
			v, ok := data["drawByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryNamespaceDrawByUserDistributionFromDict(core.CastMap(data["drawByUser"])).Pointer()
		}(),
		DrawAmountByUser: func() *LotteryNamespaceDrawAmountByUserDistribution {
			v, ok := data["drawAmountByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryNamespaceDrawAmountByUserDistributionFromDict(core.CastMap(data["drawAmountByUser"])).Pointer()
		}(),
	}
}

func (p LotteryNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Draw != nil {
		m["draw"] = func() map[string]interface{} {
			if p.Draw == nil {
				return nil
			}
			return p.Draw.ToDict()
		}()
	}
	if p.DrawAmount != nil {
		m["drawAmount"] = func() map[string]interface{} {
			if p.DrawAmount == nil {
				return nil
			}
			return p.DrawAmount.ToDict()
		}()
	}
	if p.DrawByUser != nil {
		m["drawByUser"] = func() map[string]interface{} {
			if p.DrawByUser == nil {
				return nil
			}
			return p.DrawByUser.ToDict()
		}()
	}
	if p.DrawAmountByUser != nil {
		m["drawAmountByUser"] = func() map[string]interface{} {
			if p.DrawAmountByUser == nil {
				return nil
			}
			return p.DrawAmountByUser.ToDict()
		}()
	}
	return m
}

func (p LotteryNamespaceDistributions) Pointer() *LotteryNamespaceDistributions {
	return &p
}

func CastLotteryNamespaceDistributionses(data []interface{}) []LotteryNamespaceDistributions {
	v := make([]LotteryNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespaceDistributionsesFromDict(data []LotteryNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryNamespace struct {
	NamespaceId   *string                        `json:"namespaceId"`
	Year          *int32                         `json:"year"`
	Month         *int32                         `json:"month"`
	Day           *int32                         `json:"day"`
	NamespaceName *string                        `json:"namespaceName"`
	Statistics    *LotteryNamespaceStatistics    `json:"statistics"`
	Distributions *LotteryNamespaceDistributions `json:"distributions"`
	Lotteries     []LotteryLottery               `json:"lotteries"`
}

func (p *LotteryNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryNamespace{}
	} else {
		*p = LotteryNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["lotteries"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Lotteries)
		}
	}
	return nil
}

func NewLotteryNamespaceFromJson(data string) LotteryNamespace {
	req := LotteryNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryNamespaceFromDict(data map[string]interface{}) LotteryNamespace {
	return LotteryNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *LotteryNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *LotteryNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewLotteryNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		Lotteries: func() []LotteryLottery {
			if data["lotteries"] == nil {
				return nil
			}
			return CastLotteryLotteries(core.CastArray(data["lotteries"]))
		}(),
	}
}

func (p LotteryNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.Lotteries != nil {
		m["lotteries"] = CastLotteryLotteriesFromDict(
			p.Lotteries,
		)
	}
	return m
}

func (p LotteryNamespace) Pointer() *LotteryNamespace {
	return &p
}

func CastLotteryNamespaces(data []interface{}) []LotteryNamespace {
	v := make([]LotteryNamespace, 0)
	for _, d := range data {
		v = append(v, NewLotteryNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryNamespacesFromDict(data []LotteryNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type LotteryLotteryModel struct {
	LotteryModelId *string `json:"lotteryModelId"`
	LotteryName    *string `json:"lotteryName"`
}

func (p *LotteryLotteryModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = LotteryLotteryModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = LotteryLotteryModel{}
	} else {
		*p = LotteryLotteryModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["lotteryModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryModelId)
				}
			}
		}
		if v, ok := d["lotteryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.LotteryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.LotteryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.LotteryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.LotteryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.LotteryName)
				}
			}
		}
	}
	return nil
}

func NewLotteryLotteryModelFromJson(data string) LotteryLotteryModel {
	req := LotteryLotteryModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewLotteryLotteryModelFromDict(data map[string]interface{}) LotteryLotteryModel {
	return LotteryLotteryModel{
		LotteryModelId: func() *string {
			v, ok := data["lotteryModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["lotteryModelId"])
		}(),
		LotteryName: func() *string {
			v, ok := data["lotteryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["lotteryName"])
		}(),
	}
}

func (p LotteryLotteryModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.LotteryModelId != nil {
		m["lotteryModelId"] = p.LotteryModelId
	}
	if p.LotteryName != nil {
		m["lotteryName"] = p.LotteryName
	}
	return m
}

func (p LotteryLotteryModel) Pointer() *LotteryLotteryModel {
	return &p
}

func CastLotteryLotteryModels(data []interface{}) []LotteryLotteryModel {
	v := make([]LotteryLotteryModel, 0)
	for _, d := range data {
		v = append(v, NewLotteryLotteryModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastLotteryLotteryModelsFromDict(data []LotteryLotteryModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceStatistics struct {
	CreateGathering *int64   `json:"createGathering"`
	Matchmaking     *int64   `json:"matchmaking"`
	CompleteRate    *float32 `json:"completeRate"`
}

func (p *MatchmakingNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceStatistics{}
	} else {
		*p = MatchmakingNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["createGathering"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CreateGathering)
		}
		if v, ok := d["matchmaking"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Matchmaking)
		}
		if v, ok := d["completeRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CompleteRate)
		}
	}
	return nil
}

func NewMatchmakingNamespaceStatisticsFromJson(data string) MatchmakingNamespaceStatistics {
	req := MatchmakingNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceStatisticsFromDict(data map[string]interface{}) MatchmakingNamespaceStatistics {
	return MatchmakingNamespaceStatistics{
		CreateGathering: func() *int64 {
			v, ok := data["createGathering"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["createGathering"])
		}(),
		Matchmaking: func() *int64 {
			v, ok := data["matchmaking"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["matchmaking"])
		}(),
		CompleteRate: func() *float32 {
			v, ok := data["completeRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["completeRate"])
		}(),
	}
}

func (p MatchmakingNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.CreateGathering != nil {
		m["createGathering"] = p.CreateGathering
	}
	if p.Matchmaking != nil {
		m["matchmaking"] = p.Matchmaking
	}
	if p.CompleteRate != nil {
		m["completeRate"] = p.CompleteRate
	}
	return m
}

func (p MatchmakingNamespaceStatistics) Pointer() *MatchmakingNamespaceStatistics {
	return &p
}

func CastMatchmakingNamespaceStatisticses(data []interface{}) []MatchmakingNamespaceStatistics {
	v := make([]MatchmakingNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceStatisticsesFromDict(data []MatchmakingNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceResultDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MatchmakingNamespaceResultDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceResultDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceResultDistributionStatistics{}
	} else {
		*p = MatchmakingNamespaceResultDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMatchmakingNamespaceResultDistributionStatisticsFromJson(data string) MatchmakingNamespaceResultDistributionStatistics {
	req := MatchmakingNamespaceResultDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceResultDistributionStatisticsFromDict(data map[string]interface{}) MatchmakingNamespaceResultDistributionStatistics {
	return MatchmakingNamespaceResultDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MatchmakingNamespaceResultDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MatchmakingNamespaceResultDistributionStatistics) Pointer() *MatchmakingNamespaceResultDistributionStatistics {
	return &p
}

func CastMatchmakingNamespaceResultDistributionStatisticses(data []interface{}) []MatchmakingNamespaceResultDistributionStatistics {
	v := make([]MatchmakingNamespaceResultDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceResultDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceResultDistributionStatisticsesFromDict(data []MatchmakingNamespaceResultDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceResultDistributionSegment struct {
	Result *string `json:"result"`
	Count  *int64  `json:"count"`
}

func (p *MatchmakingNamespaceResultDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceResultDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceResultDistributionSegment{}
	} else {
		*p = MatchmakingNamespaceResultDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["result"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.Result = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.Result = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.Result = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.Result = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.Result = &strValue
				default:
					_ = json.Unmarshal(*v, &p.Result)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMatchmakingNamespaceResultDistributionSegmentFromJson(data string) MatchmakingNamespaceResultDistributionSegment {
	req := MatchmakingNamespaceResultDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceResultDistributionSegmentFromDict(data map[string]interface{}) MatchmakingNamespaceResultDistributionSegment {
	return MatchmakingNamespaceResultDistributionSegment{
		Result: func() *string {
			v, ok := data["result"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["result"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MatchmakingNamespaceResultDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Result != nil {
		m["result"] = p.Result
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MatchmakingNamespaceResultDistributionSegment) Pointer() *MatchmakingNamespaceResultDistributionSegment {
	return &p
}

func CastMatchmakingNamespaceResultDistributionSegments(data []interface{}) []MatchmakingNamespaceResultDistributionSegment {
	v := make([]MatchmakingNamespaceResultDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceResultDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceResultDistributionSegmentsFromDict(data []MatchmakingNamespaceResultDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceResultDistribution struct {
	Statistics   *MatchmakingNamespaceResultDistributionStatistics `json:"statistics"`
	Distribution []MatchmakingNamespaceResultDistributionSegment   `json:"distribution"`
}

func (p *MatchmakingNamespaceResultDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceResultDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceResultDistribution{}
	} else {
		*p = MatchmakingNamespaceResultDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMatchmakingNamespaceResultDistributionFromJson(data string) MatchmakingNamespaceResultDistribution {
	req := MatchmakingNamespaceResultDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceResultDistributionFromDict(data map[string]interface{}) MatchmakingNamespaceResultDistribution {
	return MatchmakingNamespaceResultDistribution{
		Statistics: func() *MatchmakingNamespaceResultDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMatchmakingNamespaceResultDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MatchmakingNamespaceResultDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMatchmakingNamespaceResultDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MatchmakingNamespaceResultDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMatchmakingNamespaceResultDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MatchmakingNamespaceResultDistribution) Pointer() *MatchmakingNamespaceResultDistribution {
	return &p
}

func CastMatchmakingNamespaceResultDistributions(data []interface{}) []MatchmakingNamespaceResultDistribution {
	v := make([]MatchmakingNamespaceResultDistribution, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceResultDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceResultDistributionsFromDict(data []MatchmakingNamespaceResultDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics{}
	} else {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticsFromJson(data string) MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics {
	req := MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticsFromDict(data map[string]interface{}) MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics {
	return MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics) Pointer() *MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics {
	return &p
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticses(data []interface{}) []MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics {
	v := make([]MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticsesFromDict(data []MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceWaitElapsedSecondsDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *MatchmakingNamespaceWaitElapsedSecondsDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionSegment{}
	} else {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionSegmentFromJson(data string) MatchmakingNamespaceWaitElapsedSecondsDistributionSegment {
	req := MatchmakingNamespaceWaitElapsedSecondsDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionSegmentFromDict(data map[string]interface{}) MatchmakingNamespaceWaitElapsedSecondsDistributionSegment {
	return MatchmakingNamespaceWaitElapsedSecondsDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistributionSegment) Pointer() *MatchmakingNamespaceWaitElapsedSecondsDistributionSegment {
	return &p
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributionSegments(data []interface{}) []MatchmakingNamespaceWaitElapsedSecondsDistributionSegment {
	v := make([]MatchmakingNamespaceWaitElapsedSecondsDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceWaitElapsedSecondsDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributionSegmentsFromDict(data []MatchmakingNamespaceWaitElapsedSecondsDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceWaitElapsedSecondsDistribution struct {
	Statistics   *MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics `json:"statistics"`
	Distribution []MatchmakingNamespaceWaitElapsedSecondsDistributionSegment   `json:"distribution"`
}

func (p *MatchmakingNamespaceWaitElapsedSecondsDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistribution{}
	} else {
		*p = MatchmakingNamespaceWaitElapsedSecondsDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionFromJson(data string) MatchmakingNamespaceWaitElapsedSecondsDistribution {
	req := MatchmakingNamespaceWaitElapsedSecondsDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceWaitElapsedSecondsDistributionFromDict(data map[string]interface{}) MatchmakingNamespaceWaitElapsedSecondsDistribution {
	return MatchmakingNamespaceWaitElapsedSecondsDistribution{
		Statistics: func() *MatchmakingNamespaceWaitElapsedSecondsDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMatchmakingNamespaceWaitElapsedSecondsDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MatchmakingNamespaceWaitElapsedSecondsDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMatchmakingNamespaceWaitElapsedSecondsDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMatchmakingNamespaceWaitElapsedSecondsDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MatchmakingNamespaceWaitElapsedSecondsDistribution) Pointer() *MatchmakingNamespaceWaitElapsedSecondsDistribution {
	return &p
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributions(data []interface{}) []MatchmakingNamespaceWaitElapsedSecondsDistribution {
	v := make([]MatchmakingNamespaceWaitElapsedSecondsDistribution, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceWaitElapsedSecondsDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceWaitElapsedSecondsDistributionsFromDict(data []MatchmakingNamespaceWaitElapsedSecondsDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespaceDistributions struct {
	Result             *MatchmakingNamespaceResultDistribution             `json:"result"`
	WaitElapsedSeconds *MatchmakingNamespaceWaitElapsedSecondsDistribution `json:"waitElapsedSeconds"`
}

func (p *MatchmakingNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespaceDistributions{}
	} else {
		*p = MatchmakingNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["result"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Result)
		}
		if v, ok := d["waitElapsedSeconds"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.WaitElapsedSeconds)
		}
	}
	return nil
}

func NewMatchmakingNamespaceDistributionsFromJson(data string) MatchmakingNamespaceDistributions {
	req := MatchmakingNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceDistributionsFromDict(data map[string]interface{}) MatchmakingNamespaceDistributions {
	return MatchmakingNamespaceDistributions{
		Result: func() *MatchmakingNamespaceResultDistribution {
			v, ok := data["result"]
			if !ok || v == nil {
				return nil
			}
			return NewMatchmakingNamespaceResultDistributionFromDict(core.CastMap(data["result"])).Pointer()
		}(),
		WaitElapsedSeconds: func() *MatchmakingNamespaceWaitElapsedSecondsDistribution {
			v, ok := data["waitElapsedSeconds"]
			if !ok || v == nil {
				return nil
			}
			return NewMatchmakingNamespaceWaitElapsedSecondsDistributionFromDict(core.CastMap(data["waitElapsedSeconds"])).Pointer()
		}(),
	}
}

func (p MatchmakingNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Result != nil {
		m["result"] = func() map[string]interface{} {
			if p.Result == nil {
				return nil
			}
			return p.Result.ToDict()
		}()
	}
	if p.WaitElapsedSeconds != nil {
		m["waitElapsedSeconds"] = func() map[string]interface{} {
			if p.WaitElapsedSeconds == nil {
				return nil
			}
			return p.WaitElapsedSeconds.ToDict()
		}()
	}
	return m
}

func (p MatchmakingNamespaceDistributions) Pointer() *MatchmakingNamespaceDistributions {
	return &p
}

func CastMatchmakingNamespaceDistributionses(data []interface{}) []MatchmakingNamespaceDistributions {
	v := make([]MatchmakingNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespaceDistributionsesFromDict(data []MatchmakingNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MatchmakingNamespace struct {
	NamespaceId   *string                            `json:"namespaceId"`
	Year          *int32                             `json:"year"`
	Month         *int32                             `json:"month"`
	Day           *int32                             `json:"day"`
	NamespaceName *string                            `json:"namespaceName"`
	Statistics    *MatchmakingNamespaceStatistics    `json:"statistics"`
	Distributions *MatchmakingNamespaceDistributions `json:"distributions"`
}

func (p *MatchmakingNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MatchmakingNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MatchmakingNamespace{}
	} else {
		*p = MatchmakingNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewMatchmakingNamespaceFromJson(data string) MatchmakingNamespace {
	req := MatchmakingNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMatchmakingNamespaceFromDict(data map[string]interface{}) MatchmakingNamespace {
	return MatchmakingNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *MatchmakingNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMatchmakingNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *MatchmakingNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewMatchmakingNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p MatchmakingNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p MatchmakingNamespace) Pointer() *MatchmakingNamespace {
	return &p
}

func CastMatchmakingNamespaces(data []interface{}) []MatchmakingNamespace {
	v := make([]MatchmakingNamespace, 0)
	for _, d := range data {
		v = append(v, NewMatchmakingNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMatchmakingNamespacesFromDict(data []MatchmakingNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionCounterCounterDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MissionCounterCounterDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionCounterCounterDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionCounterCounterDistributionStatistics{}
	} else {
		*p = MissionCounterCounterDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMissionCounterCounterDistributionStatisticsFromJson(data string) MissionCounterCounterDistributionStatistics {
	req := MissionCounterCounterDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionCounterCounterDistributionStatisticsFromDict(data map[string]interface{}) MissionCounterCounterDistributionStatistics {
	return MissionCounterCounterDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MissionCounterCounterDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MissionCounterCounterDistributionStatistics) Pointer() *MissionCounterCounterDistributionStatistics {
	return &p
}

func CastMissionCounterCounterDistributionStatisticses(data []interface{}) []MissionCounterCounterDistributionStatistics {
	v := make([]MissionCounterCounterDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionCounterCounterDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionCounterCounterDistributionStatisticsesFromDict(data []MissionCounterCounterDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionCounterCounterDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *MissionCounterCounterDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionCounterCounterDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionCounterCounterDistributionSegment{}
	} else {
		*p = MissionCounterCounterDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMissionCounterCounterDistributionSegmentFromJson(data string) MissionCounterCounterDistributionSegment {
	req := MissionCounterCounterDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionCounterCounterDistributionSegmentFromDict(data map[string]interface{}) MissionCounterCounterDistributionSegment {
	return MissionCounterCounterDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MissionCounterCounterDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MissionCounterCounterDistributionSegment) Pointer() *MissionCounterCounterDistributionSegment {
	return &p
}

func CastMissionCounterCounterDistributionSegments(data []interface{}) []MissionCounterCounterDistributionSegment {
	v := make([]MissionCounterCounterDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMissionCounterCounterDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionCounterCounterDistributionSegmentsFromDict(data []MissionCounterCounterDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionCounterCounterDistribution struct {
	Statistics   *MissionCounterCounterDistributionStatistics `json:"statistics"`
	Distribution []MissionCounterCounterDistributionSegment   `json:"distribution"`
}

func (p *MissionCounterCounterDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionCounterCounterDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionCounterCounterDistribution{}
	} else {
		*p = MissionCounterCounterDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMissionCounterCounterDistributionFromJson(data string) MissionCounterCounterDistribution {
	req := MissionCounterCounterDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionCounterCounterDistributionFromDict(data map[string]interface{}) MissionCounterCounterDistribution {
	return MissionCounterCounterDistribution{
		Statistics: func() *MissionCounterCounterDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionCounterCounterDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MissionCounterCounterDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMissionCounterCounterDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MissionCounterCounterDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMissionCounterCounterDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MissionCounterCounterDistribution) Pointer() *MissionCounterCounterDistribution {
	return &p
}

func CastMissionCounterCounterDistributions(data []interface{}) []MissionCounterCounterDistribution {
	v := make([]MissionCounterCounterDistribution, 0)
	for _, d := range data {
		v = append(v, NewMissionCounterCounterDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionCounterCounterDistributionsFromDict(data []MissionCounterCounterDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionCounterDistributions struct {
	Counter *MissionCounterCounterDistribution `json:"counter"`
}

func (p *MissionCounterDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionCounterDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionCounterDistributions{}
	} else {
		*p = MissionCounterDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counter"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Counter)
		}
	}
	return nil
}

func NewMissionCounterDistributionsFromJson(data string) MissionCounterDistributions {
	req := MissionCounterDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionCounterDistributionsFromDict(data map[string]interface{}) MissionCounterDistributions {
	return MissionCounterDistributions{
		Counter: func() *MissionCounterCounterDistribution {
			v, ok := data["counter"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionCounterCounterDistributionFromDict(core.CastMap(data["counter"])).Pointer()
		}(),
	}
}

func (p MissionCounterDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Counter != nil {
		m["counter"] = func() map[string]interface{} {
			if p.Counter == nil {
				return nil
			}
			return p.Counter.ToDict()
		}()
	}
	return m
}

func (p MissionCounterDistributions) Pointer() *MissionCounterDistributions {
	return &p
}

func CastMissionCounterDistributionses(data []interface{}) []MissionCounterDistributions {
	v := make([]MissionCounterDistributions, 0)
	for _, d := range data {
		v = append(v, NewMissionCounterDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionCounterDistributionsesFromDict(data []MissionCounterDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionCounter struct {
	CounterId     *string                      `json:"counterId"`
	CounterName   *string                      `json:"counterName"`
	Distributions *MissionCounterDistributions `json:"distributions"`
}

func (p *MissionCounter) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionCounter{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionCounter{}
	} else {
		*p = MissionCounter{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterId)
				}
			}
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewMissionCounterFromJson(data string) MissionCounter {
	req := MissionCounter{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionCounterFromDict(data map[string]interface{}) MissionCounter {
	return MissionCounter{
		CounterId: func() *string {
			v, ok := data["counterId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["counterId"])
		}(),
		CounterName: func() *string {
			v, ok := data["counterName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["counterName"])
		}(),
		Distributions: func() *MissionCounterDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionCounterDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p MissionCounter) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.CounterId != nil {
		m["counterId"] = p.CounterId
	}
	if p.CounterName != nil {
		m["counterName"] = p.CounterName
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p MissionCounter) Pointer() *MissionCounter {
	return &p
}

func CastMissionCounters(data []interface{}) []MissionCounter {
	v := make([]MissionCounter, 0)
	for _, d := range data {
		v = append(v, NewMissionCounterFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionCountersFromDict(data []MissionCounter) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModelStatistics struct {
	Receive *int64 `json:"receive"`
}

func (p *MissionMissionGroupModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModelStatistics{}
	} else {
		*p = MissionMissionGroupModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["receive"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Receive)
		}
	}
	return nil
}

func NewMissionMissionGroupModelStatisticsFromJson(data string) MissionMissionGroupModelStatistics {
	req := MissionMissionGroupModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelStatisticsFromDict(data map[string]interface{}) MissionMissionGroupModelStatistics {
	return MissionMissionGroupModelStatistics{
		Receive: func() *int64 {
			v, ok := data["receive"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["receive"])
		}(),
	}
}

func (p MissionMissionGroupModelStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Receive != nil {
		m["receive"] = p.Receive
	}
	return m
}

func (p MissionMissionGroupModelStatistics) Pointer() *MissionMissionGroupModelStatistics {
	return &p
}

func CastMissionMissionGroupModelStatisticses(data []interface{}) []MissionMissionGroupModelStatistics {
	v := make([]MissionMissionGroupModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelStatisticsesFromDict(data []MissionMissionGroupModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModelReceiveDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MissionMissionGroupModelReceiveDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModelReceiveDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModelReceiveDistributionStatistics{}
	} else {
		*p = MissionMissionGroupModelReceiveDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMissionMissionGroupModelReceiveDistributionStatisticsFromJson(data string) MissionMissionGroupModelReceiveDistributionStatistics {
	req := MissionMissionGroupModelReceiveDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelReceiveDistributionStatisticsFromDict(data map[string]interface{}) MissionMissionGroupModelReceiveDistributionStatistics {
	return MissionMissionGroupModelReceiveDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MissionMissionGroupModelReceiveDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MissionMissionGroupModelReceiveDistributionStatistics) Pointer() *MissionMissionGroupModelReceiveDistributionStatistics {
	return &p
}

func CastMissionMissionGroupModelReceiveDistributionStatisticses(data []interface{}) []MissionMissionGroupModelReceiveDistributionStatistics {
	v := make([]MissionMissionGroupModelReceiveDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelReceiveDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelReceiveDistributionStatisticsesFromDict(data []MissionMissionGroupModelReceiveDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModelReceiveDistributionSegment struct {
	MissionTaskName *string `json:"missionTaskName"`
	Count           *int64  `json:"count"`
}

func (p *MissionMissionGroupModelReceiveDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModelReceiveDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModelReceiveDistributionSegment{}
	} else {
		*p = MissionMissionGroupModelReceiveDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["missionTaskName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionTaskName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionTaskName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionTaskName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionTaskName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMissionMissionGroupModelReceiveDistributionSegmentFromJson(data string) MissionMissionGroupModelReceiveDistributionSegment {
	req := MissionMissionGroupModelReceiveDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelReceiveDistributionSegmentFromDict(data map[string]interface{}) MissionMissionGroupModelReceiveDistributionSegment {
	return MissionMissionGroupModelReceiveDistributionSegment{
		MissionTaskName: func() *string {
			v, ok := data["missionTaskName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["missionTaskName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MissionMissionGroupModelReceiveDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.MissionTaskName != nil {
		m["missionTaskName"] = p.MissionTaskName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MissionMissionGroupModelReceiveDistributionSegment) Pointer() *MissionMissionGroupModelReceiveDistributionSegment {
	return &p
}

func CastMissionMissionGroupModelReceiveDistributionSegments(data []interface{}) []MissionMissionGroupModelReceiveDistributionSegment {
	v := make([]MissionMissionGroupModelReceiveDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelReceiveDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelReceiveDistributionSegmentsFromDict(data []MissionMissionGroupModelReceiveDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModelReceiveDistribution struct {
	Statistics   *MissionMissionGroupModelReceiveDistributionStatistics `json:"statistics"`
	Distribution []MissionMissionGroupModelReceiveDistributionSegment   `json:"distribution"`
}

func (p *MissionMissionGroupModelReceiveDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModelReceiveDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModelReceiveDistribution{}
	} else {
		*p = MissionMissionGroupModelReceiveDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMissionMissionGroupModelReceiveDistributionFromJson(data string) MissionMissionGroupModelReceiveDistribution {
	req := MissionMissionGroupModelReceiveDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelReceiveDistributionFromDict(data map[string]interface{}) MissionMissionGroupModelReceiveDistribution {
	return MissionMissionGroupModelReceiveDistribution{
		Statistics: func() *MissionMissionGroupModelReceiveDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionMissionGroupModelReceiveDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MissionMissionGroupModelReceiveDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMissionMissionGroupModelReceiveDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MissionMissionGroupModelReceiveDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMissionMissionGroupModelReceiveDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MissionMissionGroupModelReceiveDistribution) Pointer() *MissionMissionGroupModelReceiveDistribution {
	return &p
}

func CastMissionMissionGroupModelReceiveDistributions(data []interface{}) []MissionMissionGroupModelReceiveDistribution {
	v := make([]MissionMissionGroupModelReceiveDistribution, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelReceiveDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelReceiveDistributionsFromDict(data []MissionMissionGroupModelReceiveDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModelDistributions struct {
	Receive *MissionMissionGroupModelReceiveDistribution `json:"receive"`
}

func (p *MissionMissionGroupModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModelDistributions{}
	} else {
		*p = MissionMissionGroupModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["receive"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Receive)
		}
	}
	return nil
}

func NewMissionMissionGroupModelDistributionsFromJson(data string) MissionMissionGroupModelDistributions {
	req := MissionMissionGroupModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelDistributionsFromDict(data map[string]interface{}) MissionMissionGroupModelDistributions {
	return MissionMissionGroupModelDistributions{
		Receive: func() *MissionMissionGroupModelReceiveDistribution {
			v, ok := data["receive"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionMissionGroupModelReceiveDistributionFromDict(core.CastMap(data["receive"])).Pointer()
		}(),
	}
}

func (p MissionMissionGroupModelDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Receive != nil {
		m["receive"] = func() map[string]interface{} {
			if p.Receive == nil {
				return nil
			}
			return p.Receive.ToDict()
		}()
	}
	return m
}

func (p MissionMissionGroupModelDistributions) Pointer() *MissionMissionGroupModelDistributions {
	return &p
}

func CastMissionMissionGroupModelDistributionses(data []interface{}) []MissionMissionGroupModelDistributions {
	v := make([]MissionMissionGroupModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelDistributionsesFromDict(data []MissionMissionGroupModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionGroupModel struct {
	MissionGroupModelId *string                                `json:"missionGroupModelId"`
	MissionGroupName    *string                                `json:"missionGroupName"`
	Statistics          *MissionMissionGroupModelStatistics    `json:"statistics"`
	Distributions       *MissionMissionGroupModelDistributions `json:"distributions"`
}

func (p *MissionMissionGroupModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionGroupModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionGroupModel{}
	} else {
		*p = MissionMissionGroupModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["missionGroupModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionGroupModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionGroupModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionGroupModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionGroupModelId)
				}
			}
		}
		if v, ok := d["missionGroupName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionGroupName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionGroupName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionGroupName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionGroupName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewMissionMissionGroupModelFromJson(data string) MissionMissionGroupModel {
	req := MissionMissionGroupModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionGroupModelFromDict(data map[string]interface{}) MissionMissionGroupModel {
	return MissionMissionGroupModel{
		MissionGroupModelId: func() *string {
			v, ok := data["missionGroupModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["missionGroupModelId"])
		}(),
		MissionGroupName: func() *string {
			v, ok := data["missionGroupName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["missionGroupName"])
		}(),
		Statistics: func() *MissionMissionGroupModelStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionMissionGroupModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *MissionMissionGroupModelDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionMissionGroupModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p MissionMissionGroupModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.MissionGroupModelId != nil {
		m["missionGroupModelId"] = p.MissionGroupModelId
	}
	if p.MissionGroupName != nil {
		m["missionGroupName"] = p.MissionGroupName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p MissionMissionGroupModel) Pointer() *MissionMissionGroupModel {
	return &p
}

func CastMissionMissionGroupModels(data []interface{}) []MissionMissionGroupModel {
	v := make([]MissionMissionGroupModel, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionGroupModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionGroupModelsFromDict(data []MissionMissionGroupModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionMissionTaskModel struct {
	MissionTaskModelId *string `json:"missionTaskModelId"`
	MissionTaskName    *string `json:"missionTaskName"`
}

func (p *MissionMissionTaskModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionMissionTaskModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionMissionTaskModel{}
	} else {
		*p = MissionMissionTaskModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["missionTaskModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionTaskModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionTaskModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionTaskModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionTaskModelId)
				}
			}
		}
		if v, ok := d["missionTaskName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionTaskName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionTaskName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionTaskName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionTaskName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionTaskName)
				}
			}
		}
	}
	return nil
}

func NewMissionMissionTaskModelFromJson(data string) MissionMissionTaskModel {
	req := MissionMissionTaskModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionMissionTaskModelFromDict(data map[string]interface{}) MissionMissionTaskModel {
	return MissionMissionTaskModel{
		MissionTaskModelId: func() *string {
			v, ok := data["missionTaskModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["missionTaskModelId"])
		}(),
		MissionTaskName: func() *string {
			v, ok := data["missionTaskName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["missionTaskName"])
		}(),
	}
}

func (p MissionMissionTaskModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.MissionTaskModelId != nil {
		m["missionTaskModelId"] = p.MissionTaskModelId
	}
	if p.MissionTaskName != nil {
		m["missionTaskName"] = p.MissionTaskName
	}
	return m
}

func (p MissionMissionTaskModel) Pointer() *MissionMissionTaskModel {
	return &p
}

func CastMissionMissionTaskModels(data []interface{}) []MissionMissionTaskModel {
	v := make([]MissionMissionTaskModel, 0)
	for _, d := range data {
		v = append(v, NewMissionMissionTaskModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionMissionTaskModelsFromDict(data []MissionMissionTaskModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceStatistics struct {
	Increase       *int64 `json:"increase"`
	IncreaseAmount *int64 `json:"increaseAmount"`
	Receive        *int64 `json:"receive"`
}

func (p *MissionNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceStatistics{}
	} else {
		*p = MissionNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
		if v, ok := d["increaseAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmount)
		}
		if v, ok := d["receive"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Receive)
		}
	}
	return nil
}

func NewMissionNamespaceStatisticsFromJson(data string) MissionNamespaceStatistics {
	req := MissionNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceStatisticsFromDict(data map[string]interface{}) MissionNamespaceStatistics {
	return MissionNamespaceStatistics{
		Increase: func() *int64 {
			v, ok := data["increase"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increase"])
		}(),
		IncreaseAmount: func() *int64 {
			v, ok := data["increaseAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["increaseAmount"])
		}(),
		Receive: func() *int64 {
			v, ok := data["receive"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["receive"])
		}(),
	}
}

func (p MissionNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Increase != nil {
		m["increase"] = p.Increase
	}
	if p.IncreaseAmount != nil {
		m["increaseAmount"] = p.IncreaseAmount
	}
	if p.Receive != nil {
		m["receive"] = p.Receive
	}
	return m
}

func (p MissionNamespaceStatistics) Pointer() *MissionNamespaceStatistics {
	return &p
}

func CastMissionNamespaceStatisticses(data []interface{}) []MissionNamespaceStatistics {
	v := make([]MissionNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceStatisticsesFromDict(data []MissionNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MissionNamespaceIncreaseDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseDistributionStatistics{}
	} else {
		*p = MissionNamespaceIncreaseDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseDistributionStatisticsFromJson(data string) MissionNamespaceIncreaseDistributionStatistics {
	req := MissionNamespaceIncreaseDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseDistributionStatisticsFromDict(data map[string]interface{}) MissionNamespaceIncreaseDistributionStatistics {
	return MissionNamespaceIncreaseDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MissionNamespaceIncreaseDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MissionNamespaceIncreaseDistributionStatistics) Pointer() *MissionNamespaceIncreaseDistributionStatistics {
	return &p
}

func CastMissionNamespaceIncreaseDistributionStatisticses(data []interface{}) []MissionNamespaceIncreaseDistributionStatistics {
	v := make([]MissionNamespaceIncreaseDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseDistributionStatisticsesFromDict(data []MissionNamespaceIncreaseDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseDistributionSegment struct {
	CounterName *string `json:"counterName"`
	Count       *int64  `json:"count"`
}

func (p *MissionNamespaceIncreaseDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseDistributionSegment{}
	} else {
		*p = MissionNamespaceIncreaseDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseDistributionSegmentFromJson(data string) MissionNamespaceIncreaseDistributionSegment {
	req := MissionNamespaceIncreaseDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseDistributionSegmentFromDict(data map[string]interface{}) MissionNamespaceIncreaseDistributionSegment {
	return MissionNamespaceIncreaseDistributionSegment{
		CounterName: func() *string {
			v, ok := data["counterName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["counterName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MissionNamespaceIncreaseDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.CounterName != nil {
		m["counterName"] = p.CounterName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MissionNamespaceIncreaseDistributionSegment) Pointer() *MissionNamespaceIncreaseDistributionSegment {
	return &p
}

func CastMissionNamespaceIncreaseDistributionSegments(data []interface{}) []MissionNamespaceIncreaseDistributionSegment {
	v := make([]MissionNamespaceIncreaseDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseDistributionSegmentsFromDict(data []MissionNamespaceIncreaseDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseDistribution struct {
	Statistics   *MissionNamespaceIncreaseDistributionStatistics `json:"statistics"`
	Distribution []MissionNamespaceIncreaseDistributionSegment   `json:"distribution"`
}

func (p *MissionNamespaceIncreaseDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseDistribution{}
	} else {
		*p = MissionNamespaceIncreaseDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseDistributionFromJson(data string) MissionNamespaceIncreaseDistribution {
	req := MissionNamespaceIncreaseDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseDistributionFromDict(data map[string]interface{}) MissionNamespaceIncreaseDistribution {
	return MissionNamespaceIncreaseDistribution{
		Statistics: func() *MissionNamespaceIncreaseDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionNamespaceIncreaseDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MissionNamespaceIncreaseDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMissionNamespaceIncreaseDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MissionNamespaceIncreaseDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMissionNamespaceIncreaseDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MissionNamespaceIncreaseDistribution) Pointer() *MissionNamespaceIncreaseDistribution {
	return &p
}

func CastMissionNamespaceIncreaseDistributions(data []interface{}) []MissionNamespaceIncreaseDistribution {
	v := make([]MissionNamespaceIncreaseDistribution, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseDistributionsFromDict(data []MissionNamespaceIncreaseDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseAmountDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MissionNamespaceIncreaseAmountDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseAmountDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseAmountDistributionStatistics{}
	} else {
		*p = MissionNamespaceIncreaseAmountDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseAmountDistributionStatisticsFromJson(data string) MissionNamespaceIncreaseAmountDistributionStatistics {
	req := MissionNamespaceIncreaseAmountDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseAmountDistributionStatisticsFromDict(data map[string]interface{}) MissionNamespaceIncreaseAmountDistributionStatistics {
	return MissionNamespaceIncreaseAmountDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MissionNamespaceIncreaseAmountDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MissionNamespaceIncreaseAmountDistributionStatistics) Pointer() *MissionNamespaceIncreaseAmountDistributionStatistics {
	return &p
}

func CastMissionNamespaceIncreaseAmountDistributionStatisticses(data []interface{}) []MissionNamespaceIncreaseAmountDistributionStatistics {
	v := make([]MissionNamespaceIncreaseAmountDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseAmountDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseAmountDistributionStatisticsesFromDict(data []MissionNamespaceIncreaseAmountDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseAmountDistributionSegment struct {
	CounterName *string `json:"counterName"`
	Sum         *int64  `json:"sum"`
}

func (p *MissionNamespaceIncreaseAmountDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseAmountDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseAmountDistributionSegment{}
	} else {
		*p = MissionNamespaceIncreaseAmountDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["counterName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CounterName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CounterName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CounterName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CounterName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CounterName)
				}
			}
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseAmountDistributionSegmentFromJson(data string) MissionNamespaceIncreaseAmountDistributionSegment {
	req := MissionNamespaceIncreaseAmountDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseAmountDistributionSegmentFromDict(data map[string]interface{}) MissionNamespaceIncreaseAmountDistributionSegment {
	return MissionNamespaceIncreaseAmountDistributionSegment{
		CounterName: func() *string {
			v, ok := data["counterName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["counterName"])
		}(),
		Sum: func() *int64 {
			v, ok := data["sum"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sum"])
		}(),
	}
}

func (p MissionNamespaceIncreaseAmountDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.CounterName != nil {
		m["counterName"] = p.CounterName
	}
	if p.Sum != nil {
		m["sum"] = p.Sum
	}
	return m
}

func (p MissionNamespaceIncreaseAmountDistributionSegment) Pointer() *MissionNamespaceIncreaseAmountDistributionSegment {
	return &p
}

func CastMissionNamespaceIncreaseAmountDistributionSegments(data []interface{}) []MissionNamespaceIncreaseAmountDistributionSegment {
	v := make([]MissionNamespaceIncreaseAmountDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseAmountDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseAmountDistributionSegmentsFromDict(data []MissionNamespaceIncreaseAmountDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceIncreaseAmountDistribution struct {
	Statistics   *MissionNamespaceIncreaseAmountDistributionStatistics `json:"statistics"`
	Distribution []MissionNamespaceIncreaseAmountDistributionSegment   `json:"distribution"`
}

func (p *MissionNamespaceIncreaseAmountDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceIncreaseAmountDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceIncreaseAmountDistribution{}
	} else {
		*p = MissionNamespaceIncreaseAmountDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMissionNamespaceIncreaseAmountDistributionFromJson(data string) MissionNamespaceIncreaseAmountDistribution {
	req := MissionNamespaceIncreaseAmountDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceIncreaseAmountDistributionFromDict(data map[string]interface{}) MissionNamespaceIncreaseAmountDistribution {
	return MissionNamespaceIncreaseAmountDistribution{
		Statistics: func() *MissionNamespaceIncreaseAmountDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionNamespaceIncreaseAmountDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MissionNamespaceIncreaseAmountDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMissionNamespaceIncreaseAmountDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MissionNamespaceIncreaseAmountDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMissionNamespaceIncreaseAmountDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MissionNamespaceIncreaseAmountDistribution) Pointer() *MissionNamespaceIncreaseAmountDistribution {
	return &p
}

func CastMissionNamespaceIncreaseAmountDistributions(data []interface{}) []MissionNamespaceIncreaseAmountDistribution {
	v := make([]MissionNamespaceIncreaseAmountDistribution, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceIncreaseAmountDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceIncreaseAmountDistributionsFromDict(data []MissionNamespaceIncreaseAmountDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceReceiveDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MissionNamespaceReceiveDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceReceiveDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceReceiveDistributionStatistics{}
	} else {
		*p = MissionNamespaceReceiveDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMissionNamespaceReceiveDistributionStatisticsFromJson(data string) MissionNamespaceReceiveDistributionStatistics {
	req := MissionNamespaceReceiveDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceReceiveDistributionStatisticsFromDict(data map[string]interface{}) MissionNamespaceReceiveDistributionStatistics {
	return MissionNamespaceReceiveDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MissionNamespaceReceiveDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MissionNamespaceReceiveDistributionStatistics) Pointer() *MissionNamespaceReceiveDistributionStatistics {
	return &p
}

func CastMissionNamespaceReceiveDistributionStatisticses(data []interface{}) []MissionNamespaceReceiveDistributionStatistics {
	v := make([]MissionNamespaceReceiveDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceReceiveDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceReceiveDistributionStatisticsesFromDict(data []MissionNamespaceReceiveDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceReceiveDistributionSegment struct {
	MissionGroupName *string `json:"missionGroupName"`
	Count            *int64  `json:"count"`
}

func (p *MissionNamespaceReceiveDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceReceiveDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceReceiveDistributionSegment{}
	} else {
		*p = MissionNamespaceReceiveDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["missionGroupName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.MissionGroupName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.MissionGroupName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.MissionGroupName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.MissionGroupName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.MissionGroupName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMissionNamespaceReceiveDistributionSegmentFromJson(data string) MissionNamespaceReceiveDistributionSegment {
	req := MissionNamespaceReceiveDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceReceiveDistributionSegmentFromDict(data map[string]interface{}) MissionNamespaceReceiveDistributionSegment {
	return MissionNamespaceReceiveDistributionSegment{
		MissionGroupName: func() *string {
			v, ok := data["missionGroupName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["missionGroupName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MissionNamespaceReceiveDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.MissionGroupName != nil {
		m["missionGroupName"] = p.MissionGroupName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MissionNamespaceReceiveDistributionSegment) Pointer() *MissionNamespaceReceiveDistributionSegment {
	return &p
}

func CastMissionNamespaceReceiveDistributionSegments(data []interface{}) []MissionNamespaceReceiveDistributionSegment {
	v := make([]MissionNamespaceReceiveDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceReceiveDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceReceiveDistributionSegmentsFromDict(data []MissionNamespaceReceiveDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceReceiveDistribution struct {
	Statistics   *MissionNamespaceReceiveDistributionStatistics `json:"statistics"`
	Distribution []MissionNamespaceReceiveDistributionSegment   `json:"distribution"`
}

func (p *MissionNamespaceReceiveDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceReceiveDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceReceiveDistribution{}
	} else {
		*p = MissionNamespaceReceiveDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMissionNamespaceReceiveDistributionFromJson(data string) MissionNamespaceReceiveDistribution {
	req := MissionNamespaceReceiveDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceReceiveDistributionFromDict(data map[string]interface{}) MissionNamespaceReceiveDistribution {
	return MissionNamespaceReceiveDistribution{
		Statistics: func() *MissionNamespaceReceiveDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionNamespaceReceiveDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MissionNamespaceReceiveDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMissionNamespaceReceiveDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MissionNamespaceReceiveDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMissionNamespaceReceiveDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MissionNamespaceReceiveDistribution) Pointer() *MissionNamespaceReceiveDistribution {
	return &p
}

func CastMissionNamespaceReceiveDistributions(data []interface{}) []MissionNamespaceReceiveDistribution {
	v := make([]MissionNamespaceReceiveDistribution, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceReceiveDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceReceiveDistributionsFromDict(data []MissionNamespaceReceiveDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespaceDistributions struct {
	Increase       *MissionNamespaceIncreaseDistribution       `json:"increase"`
	IncreaseAmount *MissionNamespaceIncreaseAmountDistribution `json:"increaseAmount"`
	Receive        *MissionNamespaceReceiveDistribution        `json:"receive"`
}

func (p *MissionNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespaceDistributions{}
	} else {
		*p = MissionNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["increase"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Increase)
		}
		if v, ok := d["increaseAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.IncreaseAmount)
		}
		if v, ok := d["receive"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Receive)
		}
	}
	return nil
}

func NewMissionNamespaceDistributionsFromJson(data string) MissionNamespaceDistributions {
	req := MissionNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceDistributionsFromDict(data map[string]interface{}) MissionNamespaceDistributions {
	return MissionNamespaceDistributions{
		Increase: func() *MissionNamespaceIncreaseDistribution {
			v, ok := data["increase"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionNamespaceIncreaseDistributionFromDict(core.CastMap(data["increase"])).Pointer()
		}(),
		IncreaseAmount: func() *MissionNamespaceIncreaseAmountDistribution {
			v, ok := data["increaseAmount"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionNamespaceIncreaseAmountDistributionFromDict(core.CastMap(data["increaseAmount"])).Pointer()
		}(),
		Receive: func() *MissionNamespaceReceiveDistribution {
			v, ok := data["receive"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionNamespaceReceiveDistributionFromDict(core.CastMap(data["receive"])).Pointer()
		}(),
	}
}

func (p MissionNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Increase != nil {
		m["increase"] = func() map[string]interface{} {
			if p.Increase == nil {
				return nil
			}
			return p.Increase.ToDict()
		}()
	}
	if p.IncreaseAmount != nil {
		m["increaseAmount"] = func() map[string]interface{} {
			if p.IncreaseAmount == nil {
				return nil
			}
			return p.IncreaseAmount.ToDict()
		}()
	}
	if p.Receive != nil {
		m["receive"] = func() map[string]interface{} {
			if p.Receive == nil {
				return nil
			}
			return p.Receive.ToDict()
		}()
	}
	return m
}

func (p MissionNamespaceDistributions) Pointer() *MissionNamespaceDistributions {
	return &p
}

func CastMissionNamespaceDistributionses(data []interface{}) []MissionNamespaceDistributions {
	v := make([]MissionNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespaceDistributionsesFromDict(data []MissionNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MissionNamespace struct {
	NamespaceId        *string                        `json:"namespaceId"`
	Year               *int32                         `json:"year"`
	Month              *int32                         `json:"month"`
	Day                *int32                         `json:"day"`
	NamespaceName      *string                        `json:"namespaceName"`
	Statistics         *MissionNamespaceStatistics    `json:"statistics"`
	Distributions      *MissionNamespaceDistributions `json:"distributions"`
	MissionGroupModels []MissionMissionGroupModel     `json:"missionGroupModels"`
	Counters           []MissionCounter               `json:"counters"`
}

func (p *MissionNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MissionNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MissionNamespace{}
	} else {
		*p = MissionNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["missionGroupModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.MissionGroupModels)
		}
		if v, ok := d["counters"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Counters)
		}
	}
	return nil
}

func NewMissionNamespaceFromJson(data string) MissionNamespace {
	req := MissionNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMissionNamespaceFromDict(data map[string]interface{}) MissionNamespace {
	return MissionNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *MissionNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *MissionNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewMissionNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		MissionGroupModels: func() []MissionMissionGroupModel {
			if data["missionGroupModels"] == nil {
				return nil
			}
			return CastMissionMissionGroupModels(core.CastArray(data["missionGroupModels"]))
		}(),
		Counters: func() []MissionCounter {
			if data["counters"] == nil {
				return nil
			}
			return CastMissionCounters(core.CastArray(data["counters"]))
		}(),
	}
}

func (p MissionNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.MissionGroupModels != nil {
		m["missionGroupModels"] = CastMissionMissionGroupModelsFromDict(
			p.MissionGroupModels,
		)
	}
	if p.Counters != nil {
		m["counters"] = CastMissionCountersFromDict(
			p.Counters,
		)
	}
	return m
}

func (p MissionNamespace) Pointer() *MissionNamespace {
	return &p
}

func CastMissionNamespaces(data []interface{}) []MissionNamespace {
	v := make([]MissionNamespace, 0)
	for _, d := range data {
		v = append(v, NewMissionNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMissionNamespacesFromDict(data []MissionNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletStatistics struct {
	Deposit        *int64 `json:"deposit"`
	DepositAmount  *int64 `json:"depositAmount"`
	Withdraw       *int64 `json:"withdraw"`
	WithdrawAmount *int64 `json:"withdrawAmount"`
	Revenue        *int64 `json:"revenue"`
}

func (p *MoneyWalletStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletStatistics{}
	} else {
		*p = MoneyWalletStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["deposit"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Deposit)
		}
		if v, ok := d["depositAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DepositAmount)
		}
		if v, ok := d["withdraw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Withdraw)
		}
		if v, ok := d["withdrawAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.WithdrawAmount)
		}
		if v, ok := d["revenue"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Revenue)
		}
	}
	return nil
}

func NewMoneyWalletStatisticsFromJson(data string) MoneyWalletStatistics {
	req := MoneyWalletStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletStatisticsFromDict(data map[string]interface{}) MoneyWalletStatistics {
	return MoneyWalletStatistics{
		Deposit: func() *int64 {
			v, ok := data["deposit"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["deposit"])
		}(),
		DepositAmount: func() *int64 {
			v, ok := data["depositAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["depositAmount"])
		}(),
		Withdraw: func() *int64 {
			v, ok := data["withdraw"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["withdraw"])
		}(),
		WithdrawAmount: func() *int64 {
			v, ok := data["withdrawAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["withdrawAmount"])
		}(),
		Revenue: func() *int64 {
			v, ok := data["revenue"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["revenue"])
		}(),
	}
}

func (p MoneyWalletStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Deposit != nil {
		m["deposit"] = p.Deposit
	}
	if p.DepositAmount != nil {
		m["depositAmount"] = p.DepositAmount
	}
	if p.Withdraw != nil {
		m["withdraw"] = p.Withdraw
	}
	if p.WithdrawAmount != nil {
		m["withdrawAmount"] = p.WithdrawAmount
	}
	if p.Revenue != nil {
		m["revenue"] = p.Revenue
	}
	return m
}

func (p MoneyWalletStatistics) Pointer() *MoneyWalletStatistics {
	return &p
}

func CastMoneyWalletStatisticses(data []interface{}) []MoneyWalletStatistics {
	v := make([]MoneyWalletStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletStatisticsesFromDict(data []MoneyWalletStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletFreeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyWalletFreeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletFreeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletFreeDistributionStatistics{}
	} else {
		*p = MoneyWalletFreeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyWalletFreeDistributionStatisticsFromJson(data string) MoneyWalletFreeDistributionStatistics {
	req := MoneyWalletFreeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletFreeDistributionStatisticsFromDict(data map[string]interface{}) MoneyWalletFreeDistributionStatistics {
	return MoneyWalletFreeDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MoneyWalletFreeDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MoneyWalletFreeDistributionStatistics) Pointer() *MoneyWalletFreeDistributionStatistics {
	return &p
}

func CastMoneyWalletFreeDistributionStatisticses(data []interface{}) []MoneyWalletFreeDistributionStatistics {
	v := make([]MoneyWalletFreeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletFreeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletFreeDistributionStatisticsesFromDict(data []MoneyWalletFreeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletFreeDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *MoneyWalletFreeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletFreeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletFreeDistributionSegment{}
	} else {
		*p = MoneyWalletFreeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyWalletFreeDistributionSegmentFromJson(data string) MoneyWalletFreeDistributionSegment {
	req := MoneyWalletFreeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletFreeDistributionSegmentFromDict(data map[string]interface{}) MoneyWalletFreeDistributionSegment {
	return MoneyWalletFreeDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MoneyWalletFreeDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MoneyWalletFreeDistributionSegment) Pointer() *MoneyWalletFreeDistributionSegment {
	return &p
}

func CastMoneyWalletFreeDistributionSegments(data []interface{}) []MoneyWalletFreeDistributionSegment {
	v := make([]MoneyWalletFreeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletFreeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletFreeDistributionSegmentsFromDict(data []MoneyWalletFreeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletFreeDistribution struct {
	Statistics   *MoneyWalletFreeDistributionStatistics `json:"statistics"`
	Distribution []MoneyWalletFreeDistributionSegment   `json:"distribution"`
}

func (p *MoneyWalletFreeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletFreeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletFreeDistribution{}
	} else {
		*p = MoneyWalletFreeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyWalletFreeDistributionFromJson(data string) MoneyWalletFreeDistribution {
	req := MoneyWalletFreeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletFreeDistributionFromDict(data map[string]interface{}) MoneyWalletFreeDistribution {
	return MoneyWalletFreeDistribution{
		Statistics: func() *MoneyWalletFreeDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyWalletFreeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MoneyWalletFreeDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMoneyWalletFreeDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MoneyWalletFreeDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMoneyWalletFreeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MoneyWalletFreeDistribution) Pointer() *MoneyWalletFreeDistribution {
	return &p
}

func CastMoneyWalletFreeDistributions(data []interface{}) []MoneyWalletFreeDistribution {
	v := make([]MoneyWalletFreeDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletFreeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletFreeDistributionsFromDict(data []MoneyWalletFreeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletPaidDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyWalletPaidDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletPaidDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletPaidDistributionStatistics{}
	} else {
		*p = MoneyWalletPaidDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyWalletPaidDistributionStatisticsFromJson(data string) MoneyWalletPaidDistributionStatistics {
	req := MoneyWalletPaidDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletPaidDistributionStatisticsFromDict(data map[string]interface{}) MoneyWalletPaidDistributionStatistics {
	return MoneyWalletPaidDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MoneyWalletPaidDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MoneyWalletPaidDistributionStatistics) Pointer() *MoneyWalletPaidDistributionStatistics {
	return &p
}

func CastMoneyWalletPaidDistributionStatisticses(data []interface{}) []MoneyWalletPaidDistributionStatistics {
	v := make([]MoneyWalletPaidDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletPaidDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletPaidDistributionStatisticsesFromDict(data []MoneyWalletPaidDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletPaidDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *MoneyWalletPaidDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletPaidDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletPaidDistributionSegment{}
	} else {
		*p = MoneyWalletPaidDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyWalletPaidDistributionSegmentFromJson(data string) MoneyWalletPaidDistributionSegment {
	req := MoneyWalletPaidDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletPaidDistributionSegmentFromDict(data map[string]interface{}) MoneyWalletPaidDistributionSegment {
	return MoneyWalletPaidDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MoneyWalletPaidDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MoneyWalletPaidDistributionSegment) Pointer() *MoneyWalletPaidDistributionSegment {
	return &p
}

func CastMoneyWalletPaidDistributionSegments(data []interface{}) []MoneyWalletPaidDistributionSegment {
	v := make([]MoneyWalletPaidDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletPaidDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletPaidDistributionSegmentsFromDict(data []MoneyWalletPaidDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletPaidDistribution struct {
	Statistics   *MoneyWalletPaidDistributionStatistics `json:"statistics"`
	Distribution []MoneyWalletPaidDistributionSegment   `json:"distribution"`
}

func (p *MoneyWalletPaidDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletPaidDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletPaidDistribution{}
	} else {
		*p = MoneyWalletPaidDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyWalletPaidDistributionFromJson(data string) MoneyWalletPaidDistribution {
	req := MoneyWalletPaidDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletPaidDistributionFromDict(data map[string]interface{}) MoneyWalletPaidDistribution {
	return MoneyWalletPaidDistribution{
		Statistics: func() *MoneyWalletPaidDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyWalletPaidDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MoneyWalletPaidDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMoneyWalletPaidDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MoneyWalletPaidDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMoneyWalletPaidDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MoneyWalletPaidDistribution) Pointer() *MoneyWalletPaidDistribution {
	return &p
}

func CastMoneyWalletPaidDistributions(data []interface{}) []MoneyWalletPaidDistribution {
	v := make([]MoneyWalletPaidDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletPaidDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletPaidDistributionsFromDict(data []MoneyWalletPaidDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWalletDistributions struct {
	Free *MoneyWalletFreeDistribution `json:"free"`
	Paid *MoneyWalletPaidDistribution `json:"paid"`
}

func (p *MoneyWalletDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWalletDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWalletDistributions{}
	} else {
		*p = MoneyWalletDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["free"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Free)
		}
		if v, ok := d["paid"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Paid)
		}
	}
	return nil
}

func NewMoneyWalletDistributionsFromJson(data string) MoneyWalletDistributions {
	req := MoneyWalletDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletDistributionsFromDict(data map[string]interface{}) MoneyWalletDistributions {
	return MoneyWalletDistributions{
		Free: func() *MoneyWalletFreeDistribution {
			v, ok := data["free"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyWalletFreeDistributionFromDict(core.CastMap(data["free"])).Pointer()
		}(),
		Paid: func() *MoneyWalletPaidDistribution {
			v, ok := data["paid"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyWalletPaidDistributionFromDict(core.CastMap(data["paid"])).Pointer()
		}(),
	}
}

func (p MoneyWalletDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Free != nil {
		m["free"] = func() map[string]interface{} {
			if p.Free == nil {
				return nil
			}
			return p.Free.ToDict()
		}()
	}
	if p.Paid != nil {
		m["paid"] = func() map[string]interface{} {
			if p.Paid == nil {
				return nil
			}
			return p.Paid.ToDict()
		}()
	}
	return m
}

func (p MoneyWalletDistributions) Pointer() *MoneyWalletDistributions {
	return &p
}

func CastMoneyWalletDistributionses(data []interface{}) []MoneyWalletDistributions {
	v := make([]MoneyWalletDistributions, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletDistributionsesFromDict(data []MoneyWalletDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyWallet struct {
	WalletId      *string                   `json:"walletId"`
	Slot          *int32                    `json:"slot"`
	Statistics    *MoneyWalletStatistics    `json:"statistics"`
	Distributions *MoneyWalletDistributions `json:"distributions"`
}

func (p *MoneyWallet) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyWallet{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyWallet{}
	} else {
		*p = MoneyWallet{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["walletId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.WalletId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.WalletId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.WalletId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.WalletId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.WalletId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.WalletId)
				}
			}
		}
		if v, ok := d["slot"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Slot)
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewMoneyWalletFromJson(data string) MoneyWallet {
	req := MoneyWallet{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyWalletFromDict(data map[string]interface{}) MoneyWallet {
	return MoneyWallet{
		WalletId: func() *string {
			v, ok := data["walletId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["walletId"])
		}(),
		Slot: func() *int32 {
			v, ok := data["slot"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["slot"])
		}(),
		Statistics: func() *MoneyWalletStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyWalletStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *MoneyWalletDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyWalletDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p MoneyWallet) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.WalletId != nil {
		m["walletId"] = p.WalletId
	}
	if p.Slot != nil {
		m["slot"] = p.Slot
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p MoneyWallet) Pointer() *MoneyWallet {
	return &p
}

func CastMoneyWallets(data []interface{}) []MoneyWallet {
	v := make([]MoneyWallet, 0)
	for _, d := range data {
		v = append(v, NewMoneyWalletFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyWalletsFromDict(data []MoneyWallet) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceiptStatistics struct {
	Verification *int64 `json:"verification"`
}

func (p *MoneyReceiptStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceiptStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceiptStatistics{}
	} else {
		*p = MoneyReceiptStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["verification"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Verification)
		}
	}
	return nil
}

func NewMoneyReceiptStatisticsFromJson(data string) MoneyReceiptStatistics {
	req := MoneyReceiptStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptStatisticsFromDict(data map[string]interface{}) MoneyReceiptStatistics {
	return MoneyReceiptStatistics{
		Verification: func() *int64 {
			v, ok := data["verification"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["verification"])
		}(),
	}
}

func (p MoneyReceiptStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Verification != nil {
		m["verification"] = p.Verification
	}
	return m
}

func (p MoneyReceiptStatistics) Pointer() *MoneyReceiptStatistics {
	return &p
}

func CastMoneyReceiptStatisticses(data []interface{}) []MoneyReceiptStatistics {
	v := make([]MoneyReceiptStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptStatisticsesFromDict(data []MoneyReceiptStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceiptVerificationByUserDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyReceiptVerificationByUserDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceiptVerificationByUserDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceiptVerificationByUserDistributionStatistics{}
	} else {
		*p = MoneyReceiptVerificationByUserDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyReceiptVerificationByUserDistributionStatisticsFromJson(data string) MoneyReceiptVerificationByUserDistributionStatistics {
	req := MoneyReceiptVerificationByUserDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptVerificationByUserDistributionStatisticsFromDict(data map[string]interface{}) MoneyReceiptVerificationByUserDistributionStatistics {
	return MoneyReceiptVerificationByUserDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MoneyReceiptVerificationByUserDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MoneyReceiptVerificationByUserDistributionStatistics) Pointer() *MoneyReceiptVerificationByUserDistributionStatistics {
	return &p
}

func CastMoneyReceiptVerificationByUserDistributionStatisticses(data []interface{}) []MoneyReceiptVerificationByUserDistributionStatistics {
	v := make([]MoneyReceiptVerificationByUserDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptVerificationByUserDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptVerificationByUserDistributionStatisticsesFromDict(data []MoneyReceiptVerificationByUserDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceiptVerificationByUserDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *MoneyReceiptVerificationByUserDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceiptVerificationByUserDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceiptVerificationByUserDistributionSegment{}
	} else {
		*p = MoneyReceiptVerificationByUserDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyReceiptVerificationByUserDistributionSegmentFromJson(data string) MoneyReceiptVerificationByUserDistributionSegment {
	req := MoneyReceiptVerificationByUserDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptVerificationByUserDistributionSegmentFromDict(data map[string]interface{}) MoneyReceiptVerificationByUserDistributionSegment {
	return MoneyReceiptVerificationByUserDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MoneyReceiptVerificationByUserDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MoneyReceiptVerificationByUserDistributionSegment) Pointer() *MoneyReceiptVerificationByUserDistributionSegment {
	return &p
}

func CastMoneyReceiptVerificationByUserDistributionSegments(data []interface{}) []MoneyReceiptVerificationByUserDistributionSegment {
	v := make([]MoneyReceiptVerificationByUserDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptVerificationByUserDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptVerificationByUserDistributionSegmentsFromDict(data []MoneyReceiptVerificationByUserDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceiptVerificationByUserDistribution struct {
	Statistics   *MoneyReceiptVerificationByUserDistributionStatistics `json:"statistics"`
	Distribution []MoneyReceiptVerificationByUserDistributionSegment   `json:"distribution"`
}

func (p *MoneyReceiptVerificationByUserDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceiptVerificationByUserDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceiptVerificationByUserDistribution{}
	} else {
		*p = MoneyReceiptVerificationByUserDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyReceiptVerificationByUserDistributionFromJson(data string) MoneyReceiptVerificationByUserDistribution {
	req := MoneyReceiptVerificationByUserDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptVerificationByUserDistributionFromDict(data map[string]interface{}) MoneyReceiptVerificationByUserDistribution {
	return MoneyReceiptVerificationByUserDistribution{
		Statistics: func() *MoneyReceiptVerificationByUserDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyReceiptVerificationByUserDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MoneyReceiptVerificationByUserDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMoneyReceiptVerificationByUserDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MoneyReceiptVerificationByUserDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMoneyReceiptVerificationByUserDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MoneyReceiptVerificationByUserDistribution) Pointer() *MoneyReceiptVerificationByUserDistribution {
	return &p
}

func CastMoneyReceiptVerificationByUserDistributions(data []interface{}) []MoneyReceiptVerificationByUserDistribution {
	v := make([]MoneyReceiptVerificationByUserDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptVerificationByUserDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptVerificationByUserDistributionsFromDict(data []MoneyReceiptVerificationByUserDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceiptDistributions struct {
	VerificationByUser *MoneyReceiptVerificationByUserDistribution `json:"verificationByUser"`
}

func (p *MoneyReceiptDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceiptDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceiptDistributions{}
	} else {
		*p = MoneyReceiptDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["verificationByUser"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.VerificationByUser)
		}
	}
	return nil
}

func NewMoneyReceiptDistributionsFromJson(data string) MoneyReceiptDistributions {
	req := MoneyReceiptDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptDistributionsFromDict(data map[string]interface{}) MoneyReceiptDistributions {
	return MoneyReceiptDistributions{
		VerificationByUser: func() *MoneyReceiptVerificationByUserDistribution {
			v, ok := data["verificationByUser"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyReceiptVerificationByUserDistributionFromDict(core.CastMap(data["verificationByUser"])).Pointer()
		}(),
	}
}

func (p MoneyReceiptDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.VerificationByUser != nil {
		m["verificationByUser"] = func() map[string]interface{} {
			if p.VerificationByUser == nil {
				return nil
			}
			return p.VerificationByUser.ToDict()
		}()
	}
	return m
}

func (p MoneyReceiptDistributions) Pointer() *MoneyReceiptDistributions {
	return &p
}

func CastMoneyReceiptDistributionses(data []interface{}) []MoneyReceiptDistributions {
	v := make([]MoneyReceiptDistributions, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptDistributionsesFromDict(data []MoneyReceiptDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyReceipt struct {
	ReceiptId     *string                    `json:"receiptId"`
	ContentsId    *string                    `json:"contentsId"`
	Statistics    *MoneyReceiptStatistics    `json:"statistics"`
	Distributions *MoneyReceiptDistributions `json:"distributions"`
}

func (p *MoneyReceipt) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyReceipt{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyReceipt{}
	} else {
		*p = MoneyReceipt{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["receiptId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ReceiptId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ReceiptId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ReceiptId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ReceiptId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ReceiptId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ReceiptId)
				}
			}
		}
		if v, ok := d["contentsId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ContentsId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ContentsId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ContentsId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ContentsId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ContentsId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ContentsId)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewMoneyReceiptFromJson(data string) MoneyReceipt {
	req := MoneyReceipt{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyReceiptFromDict(data map[string]interface{}) MoneyReceipt {
	return MoneyReceipt{
		ReceiptId: func() *string {
			v, ok := data["receiptId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["receiptId"])
		}(),
		ContentsId: func() *string {
			v, ok := data["contentsId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["contentsId"])
		}(),
		Statistics: func() *MoneyReceiptStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyReceiptStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *MoneyReceiptDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyReceiptDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p MoneyReceipt) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ReceiptId != nil {
		m["receiptId"] = p.ReceiptId
	}
	if p.ContentsId != nil {
		m["contentsId"] = p.ContentsId
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p MoneyReceipt) Pointer() *MoneyReceipt {
	return &p
}

func CastMoneyReceipts(data []interface{}) []MoneyReceipt {
	v := make([]MoneyReceipt, 0)
	for _, d := range data {
		v = append(v, NewMoneyReceiptFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyReceiptsFromDict(data []MoneyReceipt) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceStatistics struct {
	Verification *int64 `json:"verification"`
	Deposit      *int64 `json:"deposit"`
	Withdraw     *int64 `json:"withdraw"`
	Revenue      *int64 `json:"revenue"`
}

func (p *MoneyNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceStatistics{}
	} else {
		*p = MoneyNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["verification"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Verification)
		}
		if v, ok := d["deposit"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Deposit)
		}
		if v, ok := d["withdraw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Withdraw)
		}
		if v, ok := d["revenue"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Revenue)
		}
	}
	return nil
}

func NewMoneyNamespaceStatisticsFromJson(data string) MoneyNamespaceStatistics {
	req := MoneyNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceStatisticsFromDict(data map[string]interface{}) MoneyNamespaceStatistics {
	return MoneyNamespaceStatistics{
		Verification: func() *int64 {
			v, ok := data["verification"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["verification"])
		}(),
		Deposit: func() *int64 {
			v, ok := data["deposit"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["deposit"])
		}(),
		Withdraw: func() *int64 {
			v, ok := data["withdraw"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["withdraw"])
		}(),
		Revenue: func() *int64 {
			v, ok := data["revenue"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["revenue"])
		}(),
	}
}

func (p MoneyNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Verification != nil {
		m["verification"] = p.Verification
	}
	if p.Deposit != nil {
		m["deposit"] = p.Deposit
	}
	if p.Withdraw != nil {
		m["withdraw"] = p.Withdraw
	}
	if p.Revenue != nil {
		m["revenue"] = p.Revenue
	}
	return m
}

func (p MoneyNamespaceStatistics) Pointer() *MoneyNamespaceStatistics {
	return &p
}

func CastMoneyNamespaceStatisticses(data []interface{}) []MoneyNamespaceStatistics {
	v := make([]MoneyNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceStatisticsesFromDict(data []MoneyNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceVerificationDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyNamespaceVerificationDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceVerificationDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceVerificationDistributionStatistics{}
	} else {
		*p = MoneyNamespaceVerificationDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyNamespaceVerificationDistributionStatisticsFromJson(data string) MoneyNamespaceVerificationDistributionStatistics {
	req := MoneyNamespaceVerificationDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceVerificationDistributionStatisticsFromDict(data map[string]interface{}) MoneyNamespaceVerificationDistributionStatistics {
	return MoneyNamespaceVerificationDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MoneyNamespaceVerificationDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MoneyNamespaceVerificationDistributionStatistics) Pointer() *MoneyNamespaceVerificationDistributionStatistics {
	return &p
}

func CastMoneyNamespaceVerificationDistributionStatisticses(data []interface{}) []MoneyNamespaceVerificationDistributionStatistics {
	v := make([]MoneyNamespaceVerificationDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceVerificationDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceVerificationDistributionStatisticsesFromDict(data []MoneyNamespaceVerificationDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceVerificationDistributionSegment struct {
	ContentsId *string `json:"contentsId"`
	Count      *int64  `json:"count"`
}

func (p *MoneyNamespaceVerificationDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceVerificationDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceVerificationDistributionSegment{}
	} else {
		*p = MoneyNamespaceVerificationDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["contentsId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ContentsId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ContentsId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ContentsId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ContentsId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ContentsId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ContentsId)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyNamespaceVerificationDistributionSegmentFromJson(data string) MoneyNamespaceVerificationDistributionSegment {
	req := MoneyNamespaceVerificationDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceVerificationDistributionSegmentFromDict(data map[string]interface{}) MoneyNamespaceVerificationDistributionSegment {
	return MoneyNamespaceVerificationDistributionSegment{
		ContentsId: func() *string {
			v, ok := data["contentsId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["contentsId"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MoneyNamespaceVerificationDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ContentsId != nil {
		m["contentsId"] = p.ContentsId
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MoneyNamespaceVerificationDistributionSegment) Pointer() *MoneyNamespaceVerificationDistributionSegment {
	return &p
}

func CastMoneyNamespaceVerificationDistributionSegments(data []interface{}) []MoneyNamespaceVerificationDistributionSegment {
	v := make([]MoneyNamespaceVerificationDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceVerificationDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceVerificationDistributionSegmentsFromDict(data []MoneyNamespaceVerificationDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceVerificationDistribution struct {
	Statistics   *MoneyNamespaceVerificationDistributionStatistics `json:"statistics"`
	Distribution []MoneyNamespaceVerificationDistributionSegment   `json:"distribution"`
}

func (p *MoneyNamespaceVerificationDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceVerificationDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceVerificationDistribution{}
	} else {
		*p = MoneyNamespaceVerificationDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyNamespaceVerificationDistributionFromJson(data string) MoneyNamespaceVerificationDistribution {
	req := MoneyNamespaceVerificationDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceVerificationDistributionFromDict(data map[string]interface{}) MoneyNamespaceVerificationDistribution {
	return MoneyNamespaceVerificationDistribution{
		Statistics: func() *MoneyNamespaceVerificationDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyNamespaceVerificationDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MoneyNamespaceVerificationDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMoneyNamespaceVerificationDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MoneyNamespaceVerificationDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMoneyNamespaceVerificationDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MoneyNamespaceVerificationDistribution) Pointer() *MoneyNamespaceVerificationDistribution {
	return &p
}

func CastMoneyNamespaceVerificationDistributions(data []interface{}) []MoneyNamespaceVerificationDistribution {
	v := make([]MoneyNamespaceVerificationDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceVerificationDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceVerificationDistributionsFromDict(data []MoneyNamespaceVerificationDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceDepositDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyNamespaceDepositDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceDepositDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceDepositDistributionStatistics{}
	} else {
		*p = MoneyNamespaceDepositDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyNamespaceDepositDistributionStatisticsFromJson(data string) MoneyNamespaceDepositDistributionStatistics {
	req := MoneyNamespaceDepositDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceDepositDistributionStatisticsFromDict(data map[string]interface{}) MoneyNamespaceDepositDistributionStatistics {
	return MoneyNamespaceDepositDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MoneyNamespaceDepositDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MoneyNamespaceDepositDistributionStatistics) Pointer() *MoneyNamespaceDepositDistributionStatistics {
	return &p
}

func CastMoneyNamespaceDepositDistributionStatisticses(data []interface{}) []MoneyNamespaceDepositDistributionStatistics {
	v := make([]MoneyNamespaceDepositDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceDepositDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceDepositDistributionStatisticsesFromDict(data []MoneyNamespaceDepositDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceDepositDistributionSegment struct {
	Slot  *int32 `json:"slot"`
	Count *int64 `json:"count"`
}

func (p *MoneyNamespaceDepositDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceDepositDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceDepositDistributionSegment{}
	} else {
		*p = MoneyNamespaceDepositDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["slot"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Slot)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyNamespaceDepositDistributionSegmentFromJson(data string) MoneyNamespaceDepositDistributionSegment {
	req := MoneyNamespaceDepositDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceDepositDistributionSegmentFromDict(data map[string]interface{}) MoneyNamespaceDepositDistributionSegment {
	return MoneyNamespaceDepositDistributionSegment{
		Slot: func() *int32 {
			v, ok := data["slot"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["slot"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MoneyNamespaceDepositDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Slot != nil {
		m["slot"] = p.Slot
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MoneyNamespaceDepositDistributionSegment) Pointer() *MoneyNamespaceDepositDistributionSegment {
	return &p
}

func CastMoneyNamespaceDepositDistributionSegments(data []interface{}) []MoneyNamespaceDepositDistributionSegment {
	v := make([]MoneyNamespaceDepositDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceDepositDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceDepositDistributionSegmentsFromDict(data []MoneyNamespaceDepositDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceDepositDistribution struct {
	Statistics   *MoneyNamespaceDepositDistributionStatistics `json:"statistics"`
	Distribution []MoneyNamespaceDepositDistributionSegment   `json:"distribution"`
}

func (p *MoneyNamespaceDepositDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceDepositDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceDepositDistribution{}
	} else {
		*p = MoneyNamespaceDepositDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyNamespaceDepositDistributionFromJson(data string) MoneyNamespaceDepositDistribution {
	req := MoneyNamespaceDepositDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceDepositDistributionFromDict(data map[string]interface{}) MoneyNamespaceDepositDistribution {
	return MoneyNamespaceDepositDistribution{
		Statistics: func() *MoneyNamespaceDepositDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyNamespaceDepositDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MoneyNamespaceDepositDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMoneyNamespaceDepositDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MoneyNamespaceDepositDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMoneyNamespaceDepositDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MoneyNamespaceDepositDistribution) Pointer() *MoneyNamespaceDepositDistribution {
	return &p
}

func CastMoneyNamespaceDepositDistributions(data []interface{}) []MoneyNamespaceDepositDistribution {
	v := make([]MoneyNamespaceDepositDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceDepositDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceDepositDistributionsFromDict(data []MoneyNamespaceDepositDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceWithdrawDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyNamespaceWithdrawDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceWithdrawDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceWithdrawDistributionStatistics{}
	} else {
		*p = MoneyNamespaceWithdrawDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyNamespaceWithdrawDistributionStatisticsFromJson(data string) MoneyNamespaceWithdrawDistributionStatistics {
	req := MoneyNamespaceWithdrawDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceWithdrawDistributionStatisticsFromDict(data map[string]interface{}) MoneyNamespaceWithdrawDistributionStatistics {
	return MoneyNamespaceWithdrawDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MoneyNamespaceWithdrawDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MoneyNamespaceWithdrawDistributionStatistics) Pointer() *MoneyNamespaceWithdrawDistributionStatistics {
	return &p
}

func CastMoneyNamespaceWithdrawDistributionStatisticses(data []interface{}) []MoneyNamespaceWithdrawDistributionStatistics {
	v := make([]MoneyNamespaceWithdrawDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceWithdrawDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceWithdrawDistributionStatisticsesFromDict(data []MoneyNamespaceWithdrawDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceWithdrawDistributionSegment struct {
	Slot  *int32 `json:"slot"`
	Count *int64 `json:"count"`
}

func (p *MoneyNamespaceWithdrawDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceWithdrawDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceWithdrawDistributionSegment{}
	} else {
		*p = MoneyNamespaceWithdrawDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["slot"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Slot)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewMoneyNamespaceWithdrawDistributionSegmentFromJson(data string) MoneyNamespaceWithdrawDistributionSegment {
	req := MoneyNamespaceWithdrawDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceWithdrawDistributionSegmentFromDict(data map[string]interface{}) MoneyNamespaceWithdrawDistributionSegment {
	return MoneyNamespaceWithdrawDistributionSegment{
		Slot: func() *int32 {
			v, ok := data["slot"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["slot"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p MoneyNamespaceWithdrawDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Slot != nil {
		m["slot"] = p.Slot
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p MoneyNamespaceWithdrawDistributionSegment) Pointer() *MoneyNamespaceWithdrawDistributionSegment {
	return &p
}

func CastMoneyNamespaceWithdrawDistributionSegments(data []interface{}) []MoneyNamespaceWithdrawDistributionSegment {
	v := make([]MoneyNamespaceWithdrawDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceWithdrawDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceWithdrawDistributionSegmentsFromDict(data []MoneyNamespaceWithdrawDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceWithdrawDistribution struct {
	Statistics   *MoneyNamespaceWithdrawDistributionStatistics `json:"statistics"`
	Distribution []MoneyNamespaceWithdrawDistributionSegment   `json:"distribution"`
}

func (p *MoneyNamespaceWithdrawDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceWithdrawDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceWithdrawDistribution{}
	} else {
		*p = MoneyNamespaceWithdrawDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyNamespaceWithdrawDistributionFromJson(data string) MoneyNamespaceWithdrawDistribution {
	req := MoneyNamespaceWithdrawDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceWithdrawDistributionFromDict(data map[string]interface{}) MoneyNamespaceWithdrawDistribution {
	return MoneyNamespaceWithdrawDistribution{
		Statistics: func() *MoneyNamespaceWithdrawDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyNamespaceWithdrawDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MoneyNamespaceWithdrawDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMoneyNamespaceWithdrawDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MoneyNamespaceWithdrawDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMoneyNamespaceWithdrawDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MoneyNamespaceWithdrawDistribution) Pointer() *MoneyNamespaceWithdrawDistribution {
	return &p
}

func CastMoneyNamespaceWithdrawDistributions(data []interface{}) []MoneyNamespaceWithdrawDistribution {
	v := make([]MoneyNamespaceWithdrawDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceWithdrawDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceWithdrawDistributionsFromDict(data []MoneyNamespaceWithdrawDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceRevenueDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *MoneyNamespaceRevenueDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceRevenueDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceRevenueDistributionStatistics{}
	} else {
		*p = MoneyNamespaceRevenueDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewMoneyNamespaceRevenueDistributionStatisticsFromJson(data string) MoneyNamespaceRevenueDistributionStatistics {
	req := MoneyNamespaceRevenueDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceRevenueDistributionStatisticsFromDict(data map[string]interface{}) MoneyNamespaceRevenueDistributionStatistics {
	return MoneyNamespaceRevenueDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p MoneyNamespaceRevenueDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p MoneyNamespaceRevenueDistributionStatistics) Pointer() *MoneyNamespaceRevenueDistributionStatistics {
	return &p
}

func CastMoneyNamespaceRevenueDistributionStatisticses(data []interface{}) []MoneyNamespaceRevenueDistributionStatistics {
	v := make([]MoneyNamespaceRevenueDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceRevenueDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceRevenueDistributionStatisticsesFromDict(data []MoneyNamespaceRevenueDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceRevenueDistributionSegment struct {
	Slot *int32 `json:"slot"`
	Sum  *int64 `json:"sum"`
}

func (p *MoneyNamespaceRevenueDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceRevenueDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceRevenueDistributionSegment{}
	} else {
		*p = MoneyNamespaceRevenueDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["slot"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Slot)
		}
		if v, ok := d["sum"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Sum)
		}
	}
	return nil
}

func NewMoneyNamespaceRevenueDistributionSegmentFromJson(data string) MoneyNamespaceRevenueDistributionSegment {
	req := MoneyNamespaceRevenueDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceRevenueDistributionSegmentFromDict(data map[string]interface{}) MoneyNamespaceRevenueDistributionSegment {
	return MoneyNamespaceRevenueDistributionSegment{
		Slot: func() *int32 {
			v, ok := data["slot"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["slot"])
		}(),
		Sum: func() *int64 {
			v, ok := data["sum"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["sum"])
		}(),
	}
}

func (p MoneyNamespaceRevenueDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Slot != nil {
		m["slot"] = p.Slot
	}
	if p.Sum != nil {
		m["sum"] = p.Sum
	}
	return m
}

func (p MoneyNamespaceRevenueDistributionSegment) Pointer() *MoneyNamespaceRevenueDistributionSegment {
	return &p
}

func CastMoneyNamespaceRevenueDistributionSegments(data []interface{}) []MoneyNamespaceRevenueDistributionSegment {
	v := make([]MoneyNamespaceRevenueDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceRevenueDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceRevenueDistributionSegmentsFromDict(data []MoneyNamespaceRevenueDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceRevenueDistribution struct {
	Statistics   *MoneyNamespaceRevenueDistributionStatistics `json:"statistics"`
	Distribution []MoneyNamespaceRevenueDistributionSegment   `json:"distribution"`
}

func (p *MoneyNamespaceRevenueDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceRevenueDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceRevenueDistribution{}
	} else {
		*p = MoneyNamespaceRevenueDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewMoneyNamespaceRevenueDistributionFromJson(data string) MoneyNamespaceRevenueDistribution {
	req := MoneyNamespaceRevenueDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceRevenueDistributionFromDict(data map[string]interface{}) MoneyNamespaceRevenueDistribution {
	return MoneyNamespaceRevenueDistribution{
		Statistics: func() *MoneyNamespaceRevenueDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyNamespaceRevenueDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []MoneyNamespaceRevenueDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastMoneyNamespaceRevenueDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p MoneyNamespaceRevenueDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastMoneyNamespaceRevenueDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p MoneyNamespaceRevenueDistribution) Pointer() *MoneyNamespaceRevenueDistribution {
	return &p
}

func CastMoneyNamespaceRevenueDistributions(data []interface{}) []MoneyNamespaceRevenueDistribution {
	v := make([]MoneyNamespaceRevenueDistribution, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceRevenueDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceRevenueDistributionsFromDict(data []MoneyNamespaceRevenueDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespaceDistributions struct {
	Verification *MoneyNamespaceVerificationDistribution `json:"verification"`
	Deposit      *MoneyNamespaceDepositDistribution      `json:"deposit"`
	Withdraw     *MoneyNamespaceWithdrawDistribution     `json:"withdraw"`
	Revenue      *MoneyNamespaceRevenueDistribution      `json:"revenue"`
}

func (p *MoneyNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespaceDistributions{}
	} else {
		*p = MoneyNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["verification"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Verification)
		}
		if v, ok := d["deposit"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Deposit)
		}
		if v, ok := d["withdraw"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Withdraw)
		}
		if v, ok := d["revenue"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Revenue)
		}
	}
	return nil
}

func NewMoneyNamespaceDistributionsFromJson(data string) MoneyNamespaceDistributions {
	req := MoneyNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceDistributionsFromDict(data map[string]interface{}) MoneyNamespaceDistributions {
	return MoneyNamespaceDistributions{
		Verification: func() *MoneyNamespaceVerificationDistribution {
			v, ok := data["verification"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyNamespaceVerificationDistributionFromDict(core.CastMap(data["verification"])).Pointer()
		}(),
		Deposit: func() *MoneyNamespaceDepositDistribution {
			v, ok := data["deposit"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyNamespaceDepositDistributionFromDict(core.CastMap(data["deposit"])).Pointer()
		}(),
		Withdraw: func() *MoneyNamespaceWithdrawDistribution {
			v, ok := data["withdraw"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyNamespaceWithdrawDistributionFromDict(core.CastMap(data["withdraw"])).Pointer()
		}(),
		Revenue: func() *MoneyNamespaceRevenueDistribution {
			v, ok := data["revenue"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyNamespaceRevenueDistributionFromDict(core.CastMap(data["revenue"])).Pointer()
		}(),
	}
}

func (p MoneyNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Verification != nil {
		m["verification"] = func() map[string]interface{} {
			if p.Verification == nil {
				return nil
			}
			return p.Verification.ToDict()
		}()
	}
	if p.Deposit != nil {
		m["deposit"] = func() map[string]interface{} {
			if p.Deposit == nil {
				return nil
			}
			return p.Deposit.ToDict()
		}()
	}
	if p.Withdraw != nil {
		m["withdraw"] = func() map[string]interface{} {
			if p.Withdraw == nil {
				return nil
			}
			return p.Withdraw.ToDict()
		}()
	}
	if p.Revenue != nil {
		m["revenue"] = func() map[string]interface{} {
			if p.Revenue == nil {
				return nil
			}
			return p.Revenue.ToDict()
		}()
	}
	return m
}

func (p MoneyNamespaceDistributions) Pointer() *MoneyNamespaceDistributions {
	return &p
}

func CastMoneyNamespaceDistributionses(data []interface{}) []MoneyNamespaceDistributions {
	v := make([]MoneyNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespaceDistributionsesFromDict(data []MoneyNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type MoneyNamespace struct {
	NamespaceId   *string                      `json:"namespaceId"`
	Year          *int32                       `json:"year"`
	Month         *int32                       `json:"month"`
	Day           *int32                       `json:"day"`
	NamespaceName *string                      `json:"namespaceName"`
	Statistics    *MoneyNamespaceStatistics    `json:"statistics"`
	Distributions *MoneyNamespaceDistributions `json:"distributions"`
	Wallets       []MoneyWallet                `json:"wallets"`
	Receipts      []MoneyReceipt               `json:"receipts"`
}

func (p *MoneyNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = MoneyNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = MoneyNamespace{}
	} else {
		*p = MoneyNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["wallets"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Wallets)
		}
		if v, ok := d["receipts"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Receipts)
		}
	}
	return nil
}

func NewMoneyNamespaceFromJson(data string) MoneyNamespace {
	req := MoneyNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewMoneyNamespaceFromDict(data map[string]interface{}) MoneyNamespace {
	return MoneyNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *MoneyNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *MoneyNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewMoneyNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		Wallets: func() []MoneyWallet {
			if data["wallets"] == nil {
				return nil
			}
			return CastMoneyWallets(core.CastArray(data["wallets"]))
		}(),
		Receipts: func() []MoneyReceipt {
			if data["receipts"] == nil {
				return nil
			}
			return CastMoneyReceipts(core.CastArray(data["receipts"]))
		}(),
	}
}

func (p MoneyNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.Wallets != nil {
		m["wallets"] = CastMoneyWalletsFromDict(
			p.Wallets,
		)
	}
	if p.Receipts != nil {
		m["receipts"] = CastMoneyReceiptsFromDict(
			p.Receipts,
		)
	}
	return m
}

func (p MoneyNamespace) Pointer() *MoneyNamespace {
	return &p
}

func CastMoneyNamespaces(data []interface{}) []MoneyNamespace {
	v := make([]MoneyNamespace, 0)
	for _, d := range data {
		v = append(v, NewMoneyNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastMoneyNamespacesFromDict(data []MoneyNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModelStatistics struct {
	StartQuest     *int64   `json:"startQuest"`
	EndQuest       *int64   `json:"endQuest"`
	Successful     *int64   `json:"successful"`
	SuccessfulRate *float32 `json:"successfulRate"`
}

func (p *QuestQuestModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModelStatistics{}
	} else {
		*p = QuestQuestModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["startQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.StartQuest)
		}
		if v, ok := d["endQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EndQuest)
		}
		if v, ok := d["successful"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Successful)
		}
		if v, ok := d["successfulRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SuccessfulRate)
		}
	}
	return nil
}

func NewQuestQuestModelStatisticsFromJson(data string) QuestQuestModelStatistics {
	req := QuestQuestModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelStatisticsFromDict(data map[string]interface{}) QuestQuestModelStatistics {
	return QuestQuestModelStatistics{
		StartQuest: func() *int64 {
			v, ok := data["startQuest"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["startQuest"])
		}(),
		EndQuest: func() *int64 {
			v, ok := data["endQuest"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["endQuest"])
		}(),
		Successful: func() *int64 {
			v, ok := data["successful"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["successful"])
		}(),
		SuccessfulRate: func() *float32 {
			v, ok := data["successfulRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["successfulRate"])
		}(),
	}
}

func (p QuestQuestModelStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.StartQuest != nil {
		m["startQuest"] = p.StartQuest
	}
	if p.EndQuest != nil {
		m["endQuest"] = p.EndQuest
	}
	if p.Successful != nil {
		m["successful"] = p.Successful
	}
	if p.SuccessfulRate != nil {
		m["successfulRate"] = p.SuccessfulRate
	}
	return m
}

func (p QuestQuestModelStatistics) Pointer() *QuestQuestModelStatistics {
	return &p
}

func CastQuestQuestModelStatisticses(data []interface{}) []QuestQuestModelStatistics {
	v := make([]QuestQuestModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelStatisticsesFromDict(data []QuestQuestModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModelPlayTimeSecondsDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *QuestQuestModelPlayTimeSecondsDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModelPlayTimeSecondsDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModelPlayTimeSecondsDistributionStatistics{}
	} else {
		*p = QuestQuestModelPlayTimeSecondsDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewQuestQuestModelPlayTimeSecondsDistributionStatisticsFromJson(data string) QuestQuestModelPlayTimeSecondsDistributionStatistics {
	req := QuestQuestModelPlayTimeSecondsDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelPlayTimeSecondsDistributionStatisticsFromDict(data map[string]interface{}) QuestQuestModelPlayTimeSecondsDistributionStatistics {
	return QuestQuestModelPlayTimeSecondsDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p QuestQuestModelPlayTimeSecondsDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p QuestQuestModelPlayTimeSecondsDistributionStatistics) Pointer() *QuestQuestModelPlayTimeSecondsDistributionStatistics {
	return &p
}

func CastQuestQuestModelPlayTimeSecondsDistributionStatisticses(data []interface{}) []QuestQuestModelPlayTimeSecondsDistributionStatistics {
	v := make([]QuestQuestModelPlayTimeSecondsDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelPlayTimeSecondsDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelPlayTimeSecondsDistributionStatisticsesFromDict(data []QuestQuestModelPlayTimeSecondsDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModelPlayTimeSecondsDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *QuestQuestModelPlayTimeSecondsDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModelPlayTimeSecondsDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModelPlayTimeSecondsDistributionSegment{}
	} else {
		*p = QuestQuestModelPlayTimeSecondsDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewQuestQuestModelPlayTimeSecondsDistributionSegmentFromJson(data string) QuestQuestModelPlayTimeSecondsDistributionSegment {
	req := QuestQuestModelPlayTimeSecondsDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelPlayTimeSecondsDistributionSegmentFromDict(data map[string]interface{}) QuestQuestModelPlayTimeSecondsDistributionSegment {
	return QuestQuestModelPlayTimeSecondsDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p QuestQuestModelPlayTimeSecondsDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p QuestQuestModelPlayTimeSecondsDistributionSegment) Pointer() *QuestQuestModelPlayTimeSecondsDistributionSegment {
	return &p
}

func CastQuestQuestModelPlayTimeSecondsDistributionSegments(data []interface{}) []QuestQuestModelPlayTimeSecondsDistributionSegment {
	v := make([]QuestQuestModelPlayTimeSecondsDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelPlayTimeSecondsDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelPlayTimeSecondsDistributionSegmentsFromDict(data []QuestQuestModelPlayTimeSecondsDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModelPlayTimeSecondsDistribution struct {
	Statistics   *QuestQuestModelPlayTimeSecondsDistributionStatistics `json:"statistics"`
	Distribution []QuestQuestModelPlayTimeSecondsDistributionSegment   `json:"distribution"`
}

func (p *QuestQuestModelPlayTimeSecondsDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModelPlayTimeSecondsDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModelPlayTimeSecondsDistribution{}
	} else {
		*p = QuestQuestModelPlayTimeSecondsDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewQuestQuestModelPlayTimeSecondsDistributionFromJson(data string) QuestQuestModelPlayTimeSecondsDistribution {
	req := QuestQuestModelPlayTimeSecondsDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelPlayTimeSecondsDistributionFromDict(data map[string]interface{}) QuestQuestModelPlayTimeSecondsDistribution {
	return QuestQuestModelPlayTimeSecondsDistribution{
		Statistics: func() *QuestQuestModelPlayTimeSecondsDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestQuestModelPlayTimeSecondsDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []QuestQuestModelPlayTimeSecondsDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastQuestQuestModelPlayTimeSecondsDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p QuestQuestModelPlayTimeSecondsDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastQuestQuestModelPlayTimeSecondsDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p QuestQuestModelPlayTimeSecondsDistribution) Pointer() *QuestQuestModelPlayTimeSecondsDistribution {
	return &p
}

func CastQuestQuestModelPlayTimeSecondsDistributions(data []interface{}) []QuestQuestModelPlayTimeSecondsDistribution {
	v := make([]QuestQuestModelPlayTimeSecondsDistribution, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelPlayTimeSecondsDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelPlayTimeSecondsDistributionsFromDict(data []QuestQuestModelPlayTimeSecondsDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModelDistributions struct {
	PlayTimeSeconds *QuestQuestModelPlayTimeSecondsDistribution `json:"playTimeSeconds"`
}

func (p *QuestQuestModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModelDistributions{}
	} else {
		*p = QuestQuestModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["playTimeSeconds"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.PlayTimeSeconds)
		}
	}
	return nil
}

func NewQuestQuestModelDistributionsFromJson(data string) QuestQuestModelDistributions {
	req := QuestQuestModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelDistributionsFromDict(data map[string]interface{}) QuestQuestModelDistributions {
	return QuestQuestModelDistributions{
		PlayTimeSeconds: func() *QuestQuestModelPlayTimeSecondsDistribution {
			v, ok := data["playTimeSeconds"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestQuestModelPlayTimeSecondsDistributionFromDict(core.CastMap(data["playTimeSeconds"])).Pointer()
		}(),
	}
}

func (p QuestQuestModelDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.PlayTimeSeconds != nil {
		m["playTimeSeconds"] = func() map[string]interface{} {
			if p.PlayTimeSeconds == nil {
				return nil
			}
			return p.PlayTimeSeconds.ToDict()
		}()
	}
	return m
}

func (p QuestQuestModelDistributions) Pointer() *QuestQuestModelDistributions {
	return &p
}

func CastQuestQuestModelDistributionses(data []interface{}) []QuestQuestModelDistributions {
	v := make([]QuestQuestModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelDistributionsesFromDict(data []QuestQuestModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestModel struct {
	QuestModelId  *string                       `json:"questModelId"`
	QuestName     *string                       `json:"questName"`
	Statistics    *QuestQuestModelStatistics    `json:"statistics"`
	Distributions *QuestQuestModelDistributions `json:"distributions"`
}

func (p *QuestQuestModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestModel{}
	} else {
		*p = QuestQuestModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["questModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestModelId)
				}
			}
		}
		if v, ok := d["questName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewQuestQuestModelFromJson(data string) QuestQuestModel {
	req := QuestQuestModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestModelFromDict(data map[string]interface{}) QuestQuestModel {
	return QuestQuestModel{
		QuestModelId: func() *string {
			v, ok := data["questModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["questModelId"])
		}(),
		QuestName: func() *string {
			v, ok := data["questName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["questName"])
		}(),
		Statistics: func() *QuestQuestModelStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestQuestModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *QuestQuestModelDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestQuestModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p QuestQuestModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.QuestModelId != nil {
		m["questModelId"] = p.QuestModelId
	}
	if p.QuestName != nil {
		m["questName"] = p.QuestName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p QuestQuestModel) Pointer() *QuestQuestModel {
	return &p
}

func CastQuestQuestModels(data []interface{}) []QuestQuestModel {
	v := make([]QuestQuestModel, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestModelsFromDict(data []QuestQuestModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModelStatistics struct {
	StartQuest     *int64   `json:"startQuest"`
	EndQuest       *int64   `json:"endQuest"`
	Successful     *int64   `json:"successful"`
	SuccessfulRate *float32 `json:"successfulRate"`
}

func (p *QuestQuestGroupModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModelStatistics{}
	} else {
		*p = QuestQuestGroupModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["startQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.StartQuest)
		}
		if v, ok := d["endQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EndQuest)
		}
		if v, ok := d["successful"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Successful)
		}
		if v, ok := d["successfulRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SuccessfulRate)
		}
	}
	return nil
}

func NewQuestQuestGroupModelStatisticsFromJson(data string) QuestQuestGroupModelStatistics {
	req := QuestQuestGroupModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelStatisticsFromDict(data map[string]interface{}) QuestQuestGroupModelStatistics {
	return QuestQuestGroupModelStatistics{
		StartQuest: func() *int64 {
			v, ok := data["startQuest"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["startQuest"])
		}(),
		EndQuest: func() *int64 {
			v, ok := data["endQuest"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["endQuest"])
		}(),
		Successful: func() *int64 {
			v, ok := data["successful"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["successful"])
		}(),
		SuccessfulRate: func() *float32 {
			v, ok := data["successfulRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["successfulRate"])
		}(),
	}
}

func (p QuestQuestGroupModelStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.StartQuest != nil {
		m["startQuest"] = p.StartQuest
	}
	if p.EndQuest != nil {
		m["endQuest"] = p.EndQuest
	}
	if p.Successful != nil {
		m["successful"] = p.Successful
	}
	if p.SuccessfulRate != nil {
		m["successfulRate"] = p.SuccessfulRate
	}
	return m
}

func (p QuestQuestGroupModelStatistics) Pointer() *QuestQuestGroupModelStatistics {
	return &p
}

func CastQuestQuestGroupModelStatisticses(data []interface{}) []QuestQuestGroupModelStatistics {
	v := make([]QuestQuestGroupModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelStatisticsesFromDict(data []QuestQuestGroupModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModelQuestDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *QuestQuestGroupModelQuestDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModelQuestDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModelQuestDistributionStatistics{}
	} else {
		*p = QuestQuestGroupModelQuestDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewQuestQuestGroupModelQuestDistributionStatisticsFromJson(data string) QuestQuestGroupModelQuestDistributionStatistics {
	req := QuestQuestGroupModelQuestDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelQuestDistributionStatisticsFromDict(data map[string]interface{}) QuestQuestGroupModelQuestDistributionStatistics {
	return QuestQuestGroupModelQuestDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p QuestQuestGroupModelQuestDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p QuestQuestGroupModelQuestDistributionStatistics) Pointer() *QuestQuestGroupModelQuestDistributionStatistics {
	return &p
}

func CastQuestQuestGroupModelQuestDistributionStatisticses(data []interface{}) []QuestQuestGroupModelQuestDistributionStatistics {
	v := make([]QuestQuestGroupModelQuestDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelQuestDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelQuestDistributionStatisticsesFromDict(data []QuestQuestGroupModelQuestDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModelQuestDistributionSegment struct {
	QuestName *string `json:"questName"`
	Count     *int64  `json:"count"`
}

func (p *QuestQuestGroupModelQuestDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModelQuestDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModelQuestDistributionSegment{}
	} else {
		*p = QuestQuestGroupModelQuestDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["questName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewQuestQuestGroupModelQuestDistributionSegmentFromJson(data string) QuestQuestGroupModelQuestDistributionSegment {
	req := QuestQuestGroupModelQuestDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelQuestDistributionSegmentFromDict(data map[string]interface{}) QuestQuestGroupModelQuestDistributionSegment {
	return QuestQuestGroupModelQuestDistributionSegment{
		QuestName: func() *string {
			v, ok := data["questName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["questName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p QuestQuestGroupModelQuestDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.QuestName != nil {
		m["questName"] = p.QuestName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p QuestQuestGroupModelQuestDistributionSegment) Pointer() *QuestQuestGroupModelQuestDistributionSegment {
	return &p
}

func CastQuestQuestGroupModelQuestDistributionSegments(data []interface{}) []QuestQuestGroupModelQuestDistributionSegment {
	v := make([]QuestQuestGroupModelQuestDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelQuestDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelQuestDistributionSegmentsFromDict(data []QuestQuestGroupModelQuestDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModelQuestDistribution struct {
	Statistics   *QuestQuestGroupModelQuestDistributionStatistics `json:"statistics"`
	Distribution []QuestQuestGroupModelQuestDistributionSegment   `json:"distribution"`
}

func (p *QuestQuestGroupModelQuestDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModelQuestDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModelQuestDistribution{}
	} else {
		*p = QuestQuestGroupModelQuestDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewQuestQuestGroupModelQuestDistributionFromJson(data string) QuestQuestGroupModelQuestDistribution {
	req := QuestQuestGroupModelQuestDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelQuestDistributionFromDict(data map[string]interface{}) QuestQuestGroupModelQuestDistribution {
	return QuestQuestGroupModelQuestDistribution{
		Statistics: func() *QuestQuestGroupModelQuestDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestQuestGroupModelQuestDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []QuestQuestGroupModelQuestDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastQuestQuestGroupModelQuestDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p QuestQuestGroupModelQuestDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastQuestQuestGroupModelQuestDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p QuestQuestGroupModelQuestDistribution) Pointer() *QuestQuestGroupModelQuestDistribution {
	return &p
}

func CastQuestQuestGroupModelQuestDistributions(data []interface{}) []QuestQuestGroupModelQuestDistribution {
	v := make([]QuestQuestGroupModelQuestDistribution, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelQuestDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelQuestDistributionsFromDict(data []QuestQuestGroupModelQuestDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModelDistributions struct {
	Quest *QuestQuestGroupModelQuestDistribution `json:"quest"`
}

func (p *QuestQuestGroupModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModelDistributions{}
	} else {
		*p = QuestQuestGroupModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["quest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Quest)
		}
	}
	return nil
}

func NewQuestQuestGroupModelDistributionsFromJson(data string) QuestQuestGroupModelDistributions {
	req := QuestQuestGroupModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelDistributionsFromDict(data map[string]interface{}) QuestQuestGroupModelDistributions {
	return QuestQuestGroupModelDistributions{
		Quest: func() *QuestQuestGroupModelQuestDistribution {
			v, ok := data["quest"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestQuestGroupModelQuestDistributionFromDict(core.CastMap(data["quest"])).Pointer()
		}(),
	}
}

func (p QuestQuestGroupModelDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Quest != nil {
		m["quest"] = func() map[string]interface{} {
			if p.Quest == nil {
				return nil
			}
			return p.Quest.ToDict()
		}()
	}
	return m
}

func (p QuestQuestGroupModelDistributions) Pointer() *QuestQuestGroupModelDistributions {
	return &p
}

func CastQuestQuestGroupModelDistributionses(data []interface{}) []QuestQuestGroupModelDistributions {
	v := make([]QuestQuestGroupModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelDistributionsesFromDict(data []QuestQuestGroupModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestQuestGroupModel struct {
	QuestGroupModelId *string                            `json:"questGroupModelId"`
	QuestGroupName    *string                            `json:"questGroupName"`
	Statistics        *QuestQuestGroupModelStatistics    `json:"statistics"`
	Distributions     *QuestQuestGroupModelDistributions `json:"distributions"`
	QuestModels       []QuestQuestModel                  `json:"questModels"`
}

func (p *QuestQuestGroupModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestQuestGroupModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestQuestGroupModel{}
	} else {
		*p = QuestQuestGroupModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["questGroupModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestGroupModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestGroupModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestGroupModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestGroupModelId)
				}
			}
		}
		if v, ok := d["questGroupName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestGroupName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestGroupName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestGroupName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestGroupName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["questModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.QuestModels)
		}
	}
	return nil
}

func NewQuestQuestGroupModelFromJson(data string) QuestQuestGroupModel {
	req := QuestQuestGroupModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestQuestGroupModelFromDict(data map[string]interface{}) QuestQuestGroupModel {
	return QuestQuestGroupModel{
		QuestGroupModelId: func() *string {
			v, ok := data["questGroupModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["questGroupModelId"])
		}(),
		QuestGroupName: func() *string {
			v, ok := data["questGroupName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["questGroupName"])
		}(),
		Statistics: func() *QuestQuestGroupModelStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestQuestGroupModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *QuestQuestGroupModelDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestQuestGroupModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		QuestModels: func() []QuestQuestModel {
			if data["questModels"] == nil {
				return nil
			}
			return CastQuestQuestModels(core.CastArray(data["questModels"]))
		}(),
	}
}

func (p QuestQuestGroupModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.QuestGroupModelId != nil {
		m["questGroupModelId"] = p.QuestGroupModelId
	}
	if p.QuestGroupName != nil {
		m["questGroupName"] = p.QuestGroupName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.QuestModels != nil {
		m["questModels"] = CastQuestQuestModelsFromDict(
			p.QuestModels,
		)
	}
	return m
}

func (p QuestQuestGroupModel) Pointer() *QuestQuestGroupModel {
	return &p
}

func CastQuestQuestGroupModels(data []interface{}) []QuestQuestGroupModel {
	v := make([]QuestQuestGroupModel, 0)
	for _, d := range data {
		v = append(v, NewQuestQuestGroupModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestQuestGroupModelsFromDict(data []QuestQuestGroupModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespaceStatistics struct {
	StartQuest     *int64   `json:"startQuest"`
	EndQuest       *int64   `json:"endQuest"`
	Successful     *int64   `json:"successful"`
	SuccessfulRate *float32 `json:"successfulRate"`
}

func (p *QuestNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespaceStatistics{}
	} else {
		*p = QuestNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["startQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.StartQuest)
		}
		if v, ok := d["endQuest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.EndQuest)
		}
		if v, ok := d["successful"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Successful)
		}
		if v, ok := d["successfulRate"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.SuccessfulRate)
		}
	}
	return nil
}

func NewQuestNamespaceStatisticsFromJson(data string) QuestNamespaceStatistics {
	req := QuestNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceStatisticsFromDict(data map[string]interface{}) QuestNamespaceStatistics {
	return QuestNamespaceStatistics{
		StartQuest: func() *int64 {
			v, ok := data["startQuest"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["startQuest"])
		}(),
		EndQuest: func() *int64 {
			v, ok := data["endQuest"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["endQuest"])
		}(),
		Successful: func() *int64 {
			v, ok := data["successful"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["successful"])
		}(),
		SuccessfulRate: func() *float32 {
			v, ok := data["successfulRate"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["successfulRate"])
		}(),
	}
}

func (p QuestNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.StartQuest != nil {
		m["startQuest"] = p.StartQuest
	}
	if p.EndQuest != nil {
		m["endQuest"] = p.EndQuest
	}
	if p.Successful != nil {
		m["successful"] = p.Successful
	}
	if p.SuccessfulRate != nil {
		m["successfulRate"] = p.SuccessfulRate
	}
	return m
}

func (p QuestNamespaceStatistics) Pointer() *QuestNamespaceStatistics {
	return &p
}

func CastQuestNamespaceStatisticses(data []interface{}) []QuestNamespaceStatistics {
	v := make([]QuestNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespaceStatisticsesFromDict(data []QuestNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespaceQuestDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *QuestNamespaceQuestDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespaceQuestDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespaceQuestDistributionStatistics{}
	} else {
		*p = QuestNamespaceQuestDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewQuestNamespaceQuestDistributionStatisticsFromJson(data string) QuestNamespaceQuestDistributionStatistics {
	req := QuestNamespaceQuestDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceQuestDistributionStatisticsFromDict(data map[string]interface{}) QuestNamespaceQuestDistributionStatistics {
	return QuestNamespaceQuestDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p QuestNamespaceQuestDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p QuestNamespaceQuestDistributionStatistics) Pointer() *QuestNamespaceQuestDistributionStatistics {
	return &p
}

func CastQuestNamespaceQuestDistributionStatisticses(data []interface{}) []QuestNamespaceQuestDistributionStatistics {
	v := make([]QuestNamespaceQuestDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceQuestDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespaceQuestDistributionStatisticsesFromDict(data []QuestNamespaceQuestDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespaceQuestDistributionSegment struct {
	QuestGroupName *string `json:"questGroupName"`
	Count          *int64  `json:"count"`
}

func (p *QuestNamespaceQuestDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespaceQuestDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespaceQuestDistributionSegment{}
	} else {
		*p = QuestNamespaceQuestDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["questGroupName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.QuestGroupName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.QuestGroupName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.QuestGroupName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.QuestGroupName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.QuestGroupName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewQuestNamespaceQuestDistributionSegmentFromJson(data string) QuestNamespaceQuestDistributionSegment {
	req := QuestNamespaceQuestDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceQuestDistributionSegmentFromDict(data map[string]interface{}) QuestNamespaceQuestDistributionSegment {
	return QuestNamespaceQuestDistributionSegment{
		QuestGroupName: func() *string {
			v, ok := data["questGroupName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["questGroupName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p QuestNamespaceQuestDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.QuestGroupName != nil {
		m["questGroupName"] = p.QuestGroupName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p QuestNamespaceQuestDistributionSegment) Pointer() *QuestNamespaceQuestDistributionSegment {
	return &p
}

func CastQuestNamespaceQuestDistributionSegments(data []interface{}) []QuestNamespaceQuestDistributionSegment {
	v := make([]QuestNamespaceQuestDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceQuestDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespaceQuestDistributionSegmentsFromDict(data []QuestNamespaceQuestDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespaceQuestDistribution struct {
	Statistics   *QuestNamespaceQuestDistributionStatistics `json:"statistics"`
	Distribution []QuestNamespaceQuestDistributionSegment   `json:"distribution"`
}

func (p *QuestNamespaceQuestDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespaceQuestDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespaceQuestDistribution{}
	} else {
		*p = QuestNamespaceQuestDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewQuestNamespaceQuestDistributionFromJson(data string) QuestNamespaceQuestDistribution {
	req := QuestNamespaceQuestDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceQuestDistributionFromDict(data map[string]interface{}) QuestNamespaceQuestDistribution {
	return QuestNamespaceQuestDistribution{
		Statistics: func() *QuestNamespaceQuestDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestNamespaceQuestDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []QuestNamespaceQuestDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastQuestNamespaceQuestDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p QuestNamespaceQuestDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastQuestNamespaceQuestDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p QuestNamespaceQuestDistribution) Pointer() *QuestNamespaceQuestDistribution {
	return &p
}

func CastQuestNamespaceQuestDistributions(data []interface{}) []QuestNamespaceQuestDistribution {
	v := make([]QuestNamespaceQuestDistribution, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceQuestDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespaceQuestDistributionsFromDict(data []QuestNamespaceQuestDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespaceDistributions struct {
	Quest *QuestNamespaceQuestDistribution `json:"quest"`
}

func (p *QuestNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespaceDistributions{}
	} else {
		*p = QuestNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["quest"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Quest)
		}
	}
	return nil
}

func NewQuestNamespaceDistributionsFromJson(data string) QuestNamespaceDistributions {
	req := QuestNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceDistributionsFromDict(data map[string]interface{}) QuestNamespaceDistributions {
	return QuestNamespaceDistributions{
		Quest: func() *QuestNamespaceQuestDistribution {
			v, ok := data["quest"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestNamespaceQuestDistributionFromDict(core.CastMap(data["quest"])).Pointer()
		}(),
	}
}

func (p QuestNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Quest != nil {
		m["quest"] = func() map[string]interface{} {
			if p.Quest == nil {
				return nil
			}
			return p.Quest.ToDict()
		}()
	}
	return m
}

func (p QuestNamespaceDistributions) Pointer() *QuestNamespaceDistributions {
	return &p
}

func CastQuestNamespaceDistributionses(data []interface{}) []QuestNamespaceDistributions {
	v := make([]QuestNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespaceDistributionsesFromDict(data []QuestNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type QuestNamespace struct {
	NamespaceId      *string                      `json:"namespaceId"`
	Year             *int32                       `json:"year"`
	Month            *int32                       `json:"month"`
	Day              *int32                       `json:"day"`
	NamespaceName    *string                      `json:"namespaceName"`
	Statistics       *QuestNamespaceStatistics    `json:"statistics"`
	Distributions    *QuestNamespaceDistributions `json:"distributions"`
	QuestGroupModels []QuestQuestGroupModel       `json:"questGroupModels"`
}

func (p *QuestNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = QuestNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = QuestNamespace{}
	} else {
		*p = QuestNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["questGroupModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.QuestGroupModels)
		}
	}
	return nil
}

func NewQuestNamespaceFromJson(data string) QuestNamespace {
	req := QuestNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewQuestNamespaceFromDict(data map[string]interface{}) QuestNamespace {
	return QuestNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *QuestNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *QuestNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewQuestNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		QuestGroupModels: func() []QuestQuestGroupModel {
			if data["questGroupModels"] == nil {
				return nil
			}
			return CastQuestQuestGroupModels(core.CastArray(data["questGroupModels"]))
		}(),
	}
}

func (p QuestNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.QuestGroupModels != nil {
		m["questGroupModels"] = CastQuestQuestGroupModelsFromDict(
			p.QuestGroupModels,
		)
	}
	return m
}

func (p QuestNamespace) Pointer() *QuestNamespace {
	return &p
}

func CastQuestNamespaces(data []interface{}) []QuestNamespace {
	v := make([]QuestNamespace, 0)
	for _, d := range data {
		v = append(v, NewQuestNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastQuestNamespacesFromDict(data []QuestNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModelStatistics struct {
	Put *int64 `json:"put"`
}

func (p *RankingCategoryModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModelStatistics{}
	} else {
		*p = RankingCategoryModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["put"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Put)
		}
	}
	return nil
}

func NewRankingCategoryModelStatisticsFromJson(data string) RankingCategoryModelStatistics {
	req := RankingCategoryModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelStatisticsFromDict(data map[string]interface{}) RankingCategoryModelStatistics {
	return RankingCategoryModelStatistics{
		Put: func() *int64 {
			v, ok := data["put"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["put"])
		}(),
	}
}

func (p RankingCategoryModelStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Put != nil {
		m["put"] = p.Put
	}
	return m
}

func (p RankingCategoryModelStatistics) Pointer() *RankingCategoryModelStatistics {
	return &p
}

func CastRankingCategoryModelStatisticses(data []interface{}) []RankingCategoryModelStatistics {
	v := make([]RankingCategoryModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelStatisticsesFromDict(data []RankingCategoryModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModelScoreDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *RankingCategoryModelScoreDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModelScoreDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModelScoreDistributionStatistics{}
	} else {
		*p = RankingCategoryModelScoreDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewRankingCategoryModelScoreDistributionStatisticsFromJson(data string) RankingCategoryModelScoreDistributionStatistics {
	req := RankingCategoryModelScoreDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelScoreDistributionStatisticsFromDict(data map[string]interface{}) RankingCategoryModelScoreDistributionStatistics {
	return RankingCategoryModelScoreDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p RankingCategoryModelScoreDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p RankingCategoryModelScoreDistributionStatistics) Pointer() *RankingCategoryModelScoreDistributionStatistics {
	return &p
}

func CastRankingCategoryModelScoreDistributionStatisticses(data []interface{}) []RankingCategoryModelScoreDistributionStatistics {
	v := make([]RankingCategoryModelScoreDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelScoreDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelScoreDistributionStatisticsesFromDict(data []RankingCategoryModelScoreDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModelScoreDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *RankingCategoryModelScoreDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModelScoreDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModelScoreDistributionSegment{}
	} else {
		*p = RankingCategoryModelScoreDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewRankingCategoryModelScoreDistributionSegmentFromJson(data string) RankingCategoryModelScoreDistributionSegment {
	req := RankingCategoryModelScoreDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelScoreDistributionSegmentFromDict(data map[string]interface{}) RankingCategoryModelScoreDistributionSegment {
	return RankingCategoryModelScoreDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p RankingCategoryModelScoreDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p RankingCategoryModelScoreDistributionSegment) Pointer() *RankingCategoryModelScoreDistributionSegment {
	return &p
}

func CastRankingCategoryModelScoreDistributionSegments(data []interface{}) []RankingCategoryModelScoreDistributionSegment {
	v := make([]RankingCategoryModelScoreDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelScoreDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelScoreDistributionSegmentsFromDict(data []RankingCategoryModelScoreDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModelScoreDistribution struct {
	Statistics   *RankingCategoryModelScoreDistributionStatistics `json:"statistics"`
	Distribution []RankingCategoryModelScoreDistributionSegment   `json:"distribution"`
}

func (p *RankingCategoryModelScoreDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModelScoreDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModelScoreDistribution{}
	} else {
		*p = RankingCategoryModelScoreDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewRankingCategoryModelScoreDistributionFromJson(data string) RankingCategoryModelScoreDistribution {
	req := RankingCategoryModelScoreDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelScoreDistributionFromDict(data map[string]interface{}) RankingCategoryModelScoreDistribution {
	return RankingCategoryModelScoreDistribution{
		Statistics: func() *RankingCategoryModelScoreDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewRankingCategoryModelScoreDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []RankingCategoryModelScoreDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastRankingCategoryModelScoreDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p RankingCategoryModelScoreDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastRankingCategoryModelScoreDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p RankingCategoryModelScoreDistribution) Pointer() *RankingCategoryModelScoreDistribution {
	return &p
}

func CastRankingCategoryModelScoreDistributions(data []interface{}) []RankingCategoryModelScoreDistribution {
	v := make([]RankingCategoryModelScoreDistribution, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelScoreDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelScoreDistributionsFromDict(data []RankingCategoryModelScoreDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModelDistributions struct {
	Score *RankingCategoryModelScoreDistribution `json:"score"`
}

func (p *RankingCategoryModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModelDistributions{}
	} else {
		*p = RankingCategoryModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["score"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Score)
		}
	}
	return nil
}

func NewRankingCategoryModelDistributionsFromJson(data string) RankingCategoryModelDistributions {
	req := RankingCategoryModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelDistributionsFromDict(data map[string]interface{}) RankingCategoryModelDistributions {
	return RankingCategoryModelDistributions{
		Score: func() *RankingCategoryModelScoreDistribution {
			v, ok := data["score"]
			if !ok || v == nil {
				return nil
			}
			return NewRankingCategoryModelScoreDistributionFromDict(core.CastMap(data["score"])).Pointer()
		}(),
	}
}

func (p RankingCategoryModelDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Score != nil {
		m["score"] = func() map[string]interface{} {
			if p.Score == nil {
				return nil
			}
			return p.Score.ToDict()
		}()
	}
	return m
}

func (p RankingCategoryModelDistributions) Pointer() *RankingCategoryModelDistributions {
	return &p
}

func CastRankingCategoryModelDistributionses(data []interface{}) []RankingCategoryModelDistributions {
	v := make([]RankingCategoryModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelDistributionsesFromDict(data []RankingCategoryModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingCategoryModel struct {
	CategoryModelId *string                            `json:"categoryModelId"`
	CategoryName    *string                            `json:"categoryName"`
	Statistics      *RankingCategoryModelStatistics    `json:"statistics"`
	Distributions   *RankingCategoryModelDistributions `json:"distributions"`
}

func (p *RankingCategoryModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingCategoryModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingCategoryModel{}
	} else {
		*p = RankingCategoryModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["categoryModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CategoryModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CategoryModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CategoryModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CategoryModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CategoryModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CategoryModelId)
				}
			}
		}
		if v, ok := d["categoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CategoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CategoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CategoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CategoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CategoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CategoryName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewRankingCategoryModelFromJson(data string) RankingCategoryModel {
	req := RankingCategoryModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingCategoryModelFromDict(data map[string]interface{}) RankingCategoryModel {
	return RankingCategoryModel{
		CategoryModelId: func() *string {
			v, ok := data["categoryModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["categoryModelId"])
		}(),
		CategoryName: func() *string {
			v, ok := data["categoryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["categoryName"])
		}(),
		Statistics: func() *RankingCategoryModelStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewRankingCategoryModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *RankingCategoryModelDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewRankingCategoryModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p RankingCategoryModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.CategoryModelId != nil {
		m["categoryModelId"] = p.CategoryModelId
	}
	if p.CategoryName != nil {
		m["categoryName"] = p.CategoryName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p RankingCategoryModel) Pointer() *RankingCategoryModel {
	return &p
}

func CastRankingCategoryModels(data []interface{}) []RankingCategoryModel {
	v := make([]RankingCategoryModel, 0)
	for _, d := range data {
		v = append(v, NewRankingCategoryModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingCategoryModelsFromDict(data []RankingCategoryModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespaceStatistics struct {
	Put *int64 `json:"put"`
}

func (p *RankingNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespaceStatistics{}
	} else {
		*p = RankingNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["put"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Put)
		}
	}
	return nil
}

func NewRankingNamespaceStatisticsFromJson(data string) RankingNamespaceStatistics {
	req := RankingNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespaceStatisticsFromDict(data map[string]interface{}) RankingNamespaceStatistics {
	return RankingNamespaceStatistics{
		Put: func() *int64 {
			v, ok := data["put"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["put"])
		}(),
	}
}

func (p RankingNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Put != nil {
		m["put"] = p.Put
	}
	return m
}

func (p RankingNamespaceStatistics) Pointer() *RankingNamespaceStatistics {
	return &p
}

func CastRankingNamespaceStatisticses(data []interface{}) []RankingNamespaceStatistics {
	v := make([]RankingNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespaceStatisticsesFromDict(data []RankingNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespacePutDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *RankingNamespacePutDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespacePutDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespacePutDistributionStatistics{}
	} else {
		*p = RankingNamespacePutDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewRankingNamespacePutDistributionStatisticsFromJson(data string) RankingNamespacePutDistributionStatistics {
	req := RankingNamespacePutDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespacePutDistributionStatisticsFromDict(data map[string]interface{}) RankingNamespacePutDistributionStatistics {
	return RankingNamespacePutDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p RankingNamespacePutDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p RankingNamespacePutDistributionStatistics) Pointer() *RankingNamespacePutDistributionStatistics {
	return &p
}

func CastRankingNamespacePutDistributionStatisticses(data []interface{}) []RankingNamespacePutDistributionStatistics {
	v := make([]RankingNamespacePutDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespacePutDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespacePutDistributionStatisticsesFromDict(data []RankingNamespacePutDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespacePutDistributionSegment struct {
	CategoryName *string `json:"categoryName"`
	Count        *int64  `json:"count"`
}

func (p *RankingNamespacePutDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespacePutDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespacePutDistributionSegment{}
	} else {
		*p = RankingNamespacePutDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["categoryName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.CategoryName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.CategoryName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.CategoryName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.CategoryName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.CategoryName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.CategoryName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewRankingNamespacePutDistributionSegmentFromJson(data string) RankingNamespacePutDistributionSegment {
	req := RankingNamespacePutDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespacePutDistributionSegmentFromDict(data map[string]interface{}) RankingNamespacePutDistributionSegment {
	return RankingNamespacePutDistributionSegment{
		CategoryName: func() *string {
			v, ok := data["categoryName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["categoryName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p RankingNamespacePutDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.CategoryName != nil {
		m["categoryName"] = p.CategoryName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p RankingNamespacePutDistributionSegment) Pointer() *RankingNamespacePutDistributionSegment {
	return &p
}

func CastRankingNamespacePutDistributionSegments(data []interface{}) []RankingNamespacePutDistributionSegment {
	v := make([]RankingNamespacePutDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespacePutDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespacePutDistributionSegmentsFromDict(data []RankingNamespacePutDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespacePutDistribution struct {
	Statistics   *RankingNamespacePutDistributionStatistics `json:"statistics"`
	Distribution []RankingNamespacePutDistributionSegment   `json:"distribution"`
}

func (p *RankingNamespacePutDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespacePutDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespacePutDistribution{}
	} else {
		*p = RankingNamespacePutDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewRankingNamespacePutDistributionFromJson(data string) RankingNamespacePutDistribution {
	req := RankingNamespacePutDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespacePutDistributionFromDict(data map[string]interface{}) RankingNamespacePutDistribution {
	return RankingNamespacePutDistribution{
		Statistics: func() *RankingNamespacePutDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewRankingNamespacePutDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []RankingNamespacePutDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastRankingNamespacePutDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p RankingNamespacePutDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastRankingNamespacePutDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p RankingNamespacePutDistribution) Pointer() *RankingNamespacePutDistribution {
	return &p
}

func CastRankingNamespacePutDistributions(data []interface{}) []RankingNamespacePutDistribution {
	v := make([]RankingNamespacePutDistribution, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespacePutDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespacePutDistributionsFromDict(data []RankingNamespacePutDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespaceDistributions struct {
	Put *RankingNamespacePutDistribution `json:"put"`
}

func (p *RankingNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespaceDistributions{}
	} else {
		*p = RankingNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["put"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Put)
		}
	}
	return nil
}

func NewRankingNamespaceDistributionsFromJson(data string) RankingNamespaceDistributions {
	req := RankingNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespaceDistributionsFromDict(data map[string]interface{}) RankingNamespaceDistributions {
	return RankingNamespaceDistributions{
		Put: func() *RankingNamespacePutDistribution {
			v, ok := data["put"]
			if !ok || v == nil {
				return nil
			}
			return NewRankingNamespacePutDistributionFromDict(core.CastMap(data["put"])).Pointer()
		}(),
	}
}

func (p RankingNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Put != nil {
		m["put"] = func() map[string]interface{} {
			if p.Put == nil {
				return nil
			}
			return p.Put.ToDict()
		}()
	}
	return m
}

func (p RankingNamespaceDistributions) Pointer() *RankingNamespaceDistributions {
	return &p
}

func CastRankingNamespaceDistributionses(data []interface{}) []RankingNamespaceDistributions {
	v := make([]RankingNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespaceDistributionsesFromDict(data []RankingNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type RankingNamespace struct {
	NamespaceId    *string                        `json:"namespaceId"`
	Year           *int32                         `json:"year"`
	Month          *int32                         `json:"month"`
	Day            *int32                         `json:"day"`
	NamespaceName  *string                        `json:"namespaceName"`
	Statistics     *RankingNamespaceStatistics    `json:"statistics"`
	Distributions  *RankingNamespaceDistributions `json:"distributions"`
	CategoryModels []RankingCategoryModel         `json:"categoryModels"`
}

func (p *RankingNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = RankingNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = RankingNamespace{}
	} else {
		*p = RankingNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["categoryModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.CategoryModels)
		}
	}
	return nil
}

func NewRankingNamespaceFromJson(data string) RankingNamespace {
	req := RankingNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewRankingNamespaceFromDict(data map[string]interface{}) RankingNamespace {
	return RankingNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *RankingNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewRankingNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *RankingNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewRankingNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		CategoryModels: func() []RankingCategoryModel {
			if data["categoryModels"] == nil {
				return nil
			}
			return CastRankingCategoryModels(core.CastArray(data["categoryModels"]))
		}(),
	}
}

func (p RankingNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.CategoryModels != nil {
		m["categoryModels"] = CastRankingCategoryModelsFromDict(
			p.CategoryModels,
		)
	}
	return m
}

func (p RankingNamespace) Pointer() *RankingNamespace {
	return &p
}

func CastRankingNamespaces(data []interface{}) []RankingNamespace {
	v := make([]RankingNamespace, 0)
	for _, d := range data {
		v = append(v, NewRankingNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastRankingNamespacesFromDict(data []RankingNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItemStatistics struct {
	Buy *int64 `json:"buy"`
}

func (p *ShowcaseDisplayItemStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItemStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItemStatistics{}
	} else {
		*p = ShowcaseDisplayItemStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["buy"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Buy)
		}
	}
	return nil
}

func NewShowcaseDisplayItemStatisticsFromJson(data string) ShowcaseDisplayItemStatistics {
	req := ShowcaseDisplayItemStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemStatisticsFromDict(data map[string]interface{}) ShowcaseDisplayItemStatistics {
	return ShowcaseDisplayItemStatistics{
		Buy: func() *int64 {
			v, ok := data["buy"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["buy"])
		}(),
	}
}

func (p ShowcaseDisplayItemStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Buy != nil {
		m["buy"] = p.Buy
	}
	return m
}

func (p ShowcaseDisplayItemStatistics) Pointer() *ShowcaseDisplayItemStatistics {
	return &p
}

func CastShowcaseDisplayItemStatisticses(data []interface{}) []ShowcaseDisplayItemStatistics {
	v := make([]ShowcaseDisplayItemStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemStatisticsesFromDict(data []ShowcaseDisplayItemStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItemQuantityDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ShowcaseDisplayItemQuantityDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItemQuantityDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItemQuantityDistributionStatistics{}
	} else {
		*p = ShowcaseDisplayItemQuantityDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewShowcaseDisplayItemQuantityDistributionStatisticsFromJson(data string) ShowcaseDisplayItemQuantityDistributionStatistics {
	req := ShowcaseDisplayItemQuantityDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemQuantityDistributionStatisticsFromDict(data map[string]interface{}) ShowcaseDisplayItemQuantityDistributionStatistics {
	return ShowcaseDisplayItemQuantityDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ShowcaseDisplayItemQuantityDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ShowcaseDisplayItemQuantityDistributionStatistics) Pointer() *ShowcaseDisplayItemQuantityDistributionStatistics {
	return &p
}

func CastShowcaseDisplayItemQuantityDistributionStatisticses(data []interface{}) []ShowcaseDisplayItemQuantityDistributionStatistics {
	v := make([]ShowcaseDisplayItemQuantityDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemQuantityDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemQuantityDistributionStatisticsesFromDict(data []ShowcaseDisplayItemQuantityDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItemQuantityDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *ShowcaseDisplayItemQuantityDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItemQuantityDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItemQuantityDistributionSegment{}
	} else {
		*p = ShowcaseDisplayItemQuantityDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewShowcaseDisplayItemQuantityDistributionSegmentFromJson(data string) ShowcaseDisplayItemQuantityDistributionSegment {
	req := ShowcaseDisplayItemQuantityDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemQuantityDistributionSegmentFromDict(data map[string]interface{}) ShowcaseDisplayItemQuantityDistributionSegment {
	return ShowcaseDisplayItemQuantityDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ShowcaseDisplayItemQuantityDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ShowcaseDisplayItemQuantityDistributionSegment) Pointer() *ShowcaseDisplayItemQuantityDistributionSegment {
	return &p
}

func CastShowcaseDisplayItemQuantityDistributionSegments(data []interface{}) []ShowcaseDisplayItemQuantityDistributionSegment {
	v := make([]ShowcaseDisplayItemQuantityDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemQuantityDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemQuantityDistributionSegmentsFromDict(data []ShowcaseDisplayItemQuantityDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItemQuantityDistribution struct {
	Statistics   *ShowcaseDisplayItemQuantityDistributionStatistics `json:"statistics"`
	Distribution []ShowcaseDisplayItemQuantityDistributionSegment   `json:"distribution"`
}

func (p *ShowcaseDisplayItemQuantityDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItemQuantityDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItemQuantityDistribution{}
	} else {
		*p = ShowcaseDisplayItemQuantityDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewShowcaseDisplayItemQuantityDistributionFromJson(data string) ShowcaseDisplayItemQuantityDistribution {
	req := ShowcaseDisplayItemQuantityDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemQuantityDistributionFromDict(data map[string]interface{}) ShowcaseDisplayItemQuantityDistribution {
	return ShowcaseDisplayItemQuantityDistribution{
		Statistics: func() *ShowcaseDisplayItemQuantityDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseDisplayItemQuantityDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ShowcaseDisplayItemQuantityDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastShowcaseDisplayItemQuantityDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ShowcaseDisplayItemQuantityDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastShowcaseDisplayItemQuantityDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ShowcaseDisplayItemQuantityDistribution) Pointer() *ShowcaseDisplayItemQuantityDistribution {
	return &p
}

func CastShowcaseDisplayItemQuantityDistributions(data []interface{}) []ShowcaseDisplayItemQuantityDistribution {
	v := make([]ShowcaseDisplayItemQuantityDistribution, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemQuantityDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemQuantityDistributionsFromDict(data []ShowcaseDisplayItemQuantityDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItemDistributions struct {
	Quantity *ShowcaseDisplayItemQuantityDistribution `json:"quantity"`
}

func (p *ShowcaseDisplayItemDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItemDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItemDistributions{}
	} else {
		*p = ShowcaseDisplayItemDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["quantity"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Quantity)
		}
	}
	return nil
}

func NewShowcaseDisplayItemDistributionsFromJson(data string) ShowcaseDisplayItemDistributions {
	req := ShowcaseDisplayItemDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemDistributionsFromDict(data map[string]interface{}) ShowcaseDisplayItemDistributions {
	return ShowcaseDisplayItemDistributions{
		Quantity: func() *ShowcaseDisplayItemQuantityDistribution {
			v, ok := data["quantity"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseDisplayItemQuantityDistributionFromDict(core.CastMap(data["quantity"])).Pointer()
		}(),
	}
}

func (p ShowcaseDisplayItemDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Quantity != nil {
		m["quantity"] = func() map[string]interface{} {
			if p.Quantity == nil {
				return nil
			}
			return p.Quantity.ToDict()
		}()
	}
	return m
}

func (p ShowcaseDisplayItemDistributions) Pointer() *ShowcaseDisplayItemDistributions {
	return &p
}

func CastShowcaseDisplayItemDistributionses(data []interface{}) []ShowcaseDisplayItemDistributions {
	v := make([]ShowcaseDisplayItemDistributions, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemDistributionsesFromDict(data []ShowcaseDisplayItemDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseDisplayItem struct {
	DisplayItemId *string                           `json:"displayItemId"`
	Statistics    *ShowcaseDisplayItemStatistics    `json:"statistics"`
	Distributions *ShowcaseDisplayItemDistributions `json:"distributions"`
}

func (p *ShowcaseDisplayItem) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseDisplayItem{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseDisplayItem{}
	} else {
		*p = ShowcaseDisplayItem{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["displayItemId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.DisplayItemId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.DisplayItemId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.DisplayItemId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.DisplayItemId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.DisplayItemId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.DisplayItemId)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewShowcaseDisplayItemFromJson(data string) ShowcaseDisplayItem {
	req := ShowcaseDisplayItem{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseDisplayItemFromDict(data map[string]interface{}) ShowcaseDisplayItem {
	return ShowcaseDisplayItem{
		DisplayItemId: func() *string {
			v, ok := data["displayItemId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["displayItemId"])
		}(),
		Statistics: func() *ShowcaseDisplayItemStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseDisplayItemStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *ShowcaseDisplayItemDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseDisplayItemDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p ShowcaseDisplayItem) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.DisplayItemId != nil {
		m["displayItemId"] = p.DisplayItemId
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p ShowcaseDisplayItem) Pointer() *ShowcaseDisplayItem {
	return &p
}

func CastShowcaseDisplayItems(data []interface{}) []ShowcaseDisplayItem {
	v := make([]ShowcaseDisplayItem, 0)
	for _, d := range data {
		v = append(v, NewShowcaseDisplayItemFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseDisplayItemsFromDict(data []ShowcaseDisplayItem) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcaseStatistics struct {
	Buy *int64 `json:"buy"`
}

func (p *ShowcaseShowcaseStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcaseStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcaseStatistics{}
	} else {
		*p = ShowcaseShowcaseStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["buy"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Buy)
		}
	}
	return nil
}

func NewShowcaseShowcaseStatisticsFromJson(data string) ShowcaseShowcaseStatistics {
	req := ShowcaseShowcaseStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseStatisticsFromDict(data map[string]interface{}) ShowcaseShowcaseStatistics {
	return ShowcaseShowcaseStatistics{
		Buy: func() *int64 {
			v, ok := data["buy"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["buy"])
		}(),
	}
}

func (p ShowcaseShowcaseStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Buy != nil {
		m["buy"] = p.Buy
	}
	return m
}

func (p ShowcaseShowcaseStatistics) Pointer() *ShowcaseShowcaseStatistics {
	return &p
}

func CastShowcaseShowcaseStatisticses(data []interface{}) []ShowcaseShowcaseStatistics {
	v := make([]ShowcaseShowcaseStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcaseStatisticsesFromDict(data []ShowcaseShowcaseStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcaseBuyDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ShowcaseShowcaseBuyDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcaseBuyDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcaseBuyDistributionStatistics{}
	} else {
		*p = ShowcaseShowcaseBuyDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewShowcaseShowcaseBuyDistributionStatisticsFromJson(data string) ShowcaseShowcaseBuyDistributionStatistics {
	req := ShowcaseShowcaseBuyDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseBuyDistributionStatisticsFromDict(data map[string]interface{}) ShowcaseShowcaseBuyDistributionStatistics {
	return ShowcaseShowcaseBuyDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ShowcaseShowcaseBuyDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ShowcaseShowcaseBuyDistributionStatistics) Pointer() *ShowcaseShowcaseBuyDistributionStatistics {
	return &p
}

func CastShowcaseShowcaseBuyDistributionStatisticses(data []interface{}) []ShowcaseShowcaseBuyDistributionStatistics {
	v := make([]ShowcaseShowcaseBuyDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseBuyDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcaseBuyDistributionStatisticsesFromDict(data []ShowcaseShowcaseBuyDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcaseBuyDistributionSegment struct {
	DisplayItemId *string `json:"displayItemId"`
	Count         *int64  `json:"count"`
}

func (p *ShowcaseShowcaseBuyDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcaseBuyDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcaseBuyDistributionSegment{}
	} else {
		*p = ShowcaseShowcaseBuyDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["displayItemId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.DisplayItemId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.DisplayItemId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.DisplayItemId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.DisplayItemId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.DisplayItemId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.DisplayItemId)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewShowcaseShowcaseBuyDistributionSegmentFromJson(data string) ShowcaseShowcaseBuyDistributionSegment {
	req := ShowcaseShowcaseBuyDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseBuyDistributionSegmentFromDict(data map[string]interface{}) ShowcaseShowcaseBuyDistributionSegment {
	return ShowcaseShowcaseBuyDistributionSegment{
		DisplayItemId: func() *string {
			v, ok := data["displayItemId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["displayItemId"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ShowcaseShowcaseBuyDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.DisplayItemId != nil {
		m["displayItemId"] = p.DisplayItemId
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ShowcaseShowcaseBuyDistributionSegment) Pointer() *ShowcaseShowcaseBuyDistributionSegment {
	return &p
}

func CastShowcaseShowcaseBuyDistributionSegments(data []interface{}) []ShowcaseShowcaseBuyDistributionSegment {
	v := make([]ShowcaseShowcaseBuyDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseBuyDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcaseBuyDistributionSegmentsFromDict(data []ShowcaseShowcaseBuyDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcaseBuyDistribution struct {
	Statistics   *ShowcaseShowcaseBuyDistributionStatistics `json:"statistics"`
	Distribution []ShowcaseShowcaseBuyDistributionSegment   `json:"distribution"`
}

func (p *ShowcaseShowcaseBuyDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcaseBuyDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcaseBuyDistribution{}
	} else {
		*p = ShowcaseShowcaseBuyDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewShowcaseShowcaseBuyDistributionFromJson(data string) ShowcaseShowcaseBuyDistribution {
	req := ShowcaseShowcaseBuyDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseBuyDistributionFromDict(data map[string]interface{}) ShowcaseShowcaseBuyDistribution {
	return ShowcaseShowcaseBuyDistribution{
		Statistics: func() *ShowcaseShowcaseBuyDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseShowcaseBuyDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ShowcaseShowcaseBuyDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastShowcaseShowcaseBuyDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ShowcaseShowcaseBuyDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastShowcaseShowcaseBuyDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ShowcaseShowcaseBuyDistribution) Pointer() *ShowcaseShowcaseBuyDistribution {
	return &p
}

func CastShowcaseShowcaseBuyDistributions(data []interface{}) []ShowcaseShowcaseBuyDistribution {
	v := make([]ShowcaseShowcaseBuyDistribution, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseBuyDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcaseBuyDistributionsFromDict(data []ShowcaseShowcaseBuyDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcaseDistributions struct {
	Buy *ShowcaseShowcaseBuyDistribution `json:"buy"`
}

func (p *ShowcaseShowcaseDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcaseDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcaseDistributions{}
	} else {
		*p = ShowcaseShowcaseDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["buy"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Buy)
		}
	}
	return nil
}

func NewShowcaseShowcaseDistributionsFromJson(data string) ShowcaseShowcaseDistributions {
	req := ShowcaseShowcaseDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseDistributionsFromDict(data map[string]interface{}) ShowcaseShowcaseDistributions {
	return ShowcaseShowcaseDistributions{
		Buy: func() *ShowcaseShowcaseBuyDistribution {
			v, ok := data["buy"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseShowcaseBuyDistributionFromDict(core.CastMap(data["buy"])).Pointer()
		}(),
	}
}

func (p ShowcaseShowcaseDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Buy != nil {
		m["buy"] = func() map[string]interface{} {
			if p.Buy == nil {
				return nil
			}
			return p.Buy.ToDict()
		}()
	}
	return m
}

func (p ShowcaseShowcaseDistributions) Pointer() *ShowcaseShowcaseDistributions {
	return &p
}

func CastShowcaseShowcaseDistributionses(data []interface{}) []ShowcaseShowcaseDistributions {
	v := make([]ShowcaseShowcaseDistributions, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcaseDistributionsesFromDict(data []ShowcaseShowcaseDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseShowcase struct {
	ShowcaseId    *string                        `json:"showcaseId"`
	ShowcaseName  *string                        `json:"showcaseName"`
	Statistics    *ShowcaseShowcaseStatistics    `json:"statistics"`
	Distributions *ShowcaseShowcaseDistributions `json:"distributions"`
	DisplayItems  []ShowcaseDisplayItem          `json:"displayItems"`
}

func (p *ShowcaseShowcase) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseShowcase{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseShowcase{}
	} else {
		*p = ShowcaseShowcase{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["showcaseId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ShowcaseId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ShowcaseId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ShowcaseId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ShowcaseId)
				}
			}
		}
		if v, ok := d["showcaseName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ShowcaseName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ShowcaseName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ShowcaseName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ShowcaseName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["displayItems"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.DisplayItems)
		}
	}
	return nil
}

func NewShowcaseShowcaseFromJson(data string) ShowcaseShowcase {
	req := ShowcaseShowcase{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseShowcaseFromDict(data map[string]interface{}) ShowcaseShowcase {
	return ShowcaseShowcase{
		ShowcaseId: func() *string {
			v, ok := data["showcaseId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["showcaseId"])
		}(),
		ShowcaseName: func() *string {
			v, ok := data["showcaseName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["showcaseName"])
		}(),
		Statistics: func() *ShowcaseShowcaseStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseShowcaseStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *ShowcaseShowcaseDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseShowcaseDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		DisplayItems: func() []ShowcaseDisplayItem {
			if data["displayItems"] == nil {
				return nil
			}
			return CastShowcaseDisplayItems(core.CastArray(data["displayItems"]))
		}(),
	}
}

func (p ShowcaseShowcase) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ShowcaseId != nil {
		m["showcaseId"] = p.ShowcaseId
	}
	if p.ShowcaseName != nil {
		m["showcaseName"] = p.ShowcaseName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.DisplayItems != nil {
		m["displayItems"] = CastShowcaseDisplayItemsFromDict(
			p.DisplayItems,
		)
	}
	return m
}

func (p ShowcaseShowcase) Pointer() *ShowcaseShowcase {
	return &p
}

func CastShowcaseShowcases(data []interface{}) []ShowcaseShowcase {
	v := make([]ShowcaseShowcase, 0)
	for _, d := range data {
		v = append(v, NewShowcaseShowcaseFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseShowcasesFromDict(data []ShowcaseShowcase) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespaceStatistics struct {
	Buy *int64 `json:"buy"`
}

func (p *ShowcaseNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespaceStatistics{}
	} else {
		*p = ShowcaseNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["buy"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Buy)
		}
	}
	return nil
}

func NewShowcaseNamespaceStatisticsFromJson(data string) ShowcaseNamespaceStatistics {
	req := ShowcaseNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceStatisticsFromDict(data map[string]interface{}) ShowcaseNamespaceStatistics {
	return ShowcaseNamespaceStatistics{
		Buy: func() *int64 {
			v, ok := data["buy"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["buy"])
		}(),
	}
}

func (p ShowcaseNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Buy != nil {
		m["buy"] = p.Buy
	}
	return m
}

func (p ShowcaseNamespaceStatistics) Pointer() *ShowcaseNamespaceStatistics {
	return &p
}

func CastShowcaseNamespaceStatisticses(data []interface{}) []ShowcaseNamespaceStatistics {
	v := make([]ShowcaseNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespaceStatisticsesFromDict(data []ShowcaseNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespaceBuyDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *ShowcaseNamespaceBuyDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespaceBuyDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespaceBuyDistributionStatistics{}
	} else {
		*p = ShowcaseNamespaceBuyDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewShowcaseNamespaceBuyDistributionStatisticsFromJson(data string) ShowcaseNamespaceBuyDistributionStatistics {
	req := ShowcaseNamespaceBuyDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceBuyDistributionStatisticsFromDict(data map[string]interface{}) ShowcaseNamespaceBuyDistributionStatistics {
	return ShowcaseNamespaceBuyDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p ShowcaseNamespaceBuyDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p ShowcaseNamespaceBuyDistributionStatistics) Pointer() *ShowcaseNamespaceBuyDistributionStatistics {
	return &p
}

func CastShowcaseNamespaceBuyDistributionStatisticses(data []interface{}) []ShowcaseNamespaceBuyDistributionStatistics {
	v := make([]ShowcaseNamespaceBuyDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceBuyDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespaceBuyDistributionStatisticsesFromDict(data []ShowcaseNamespaceBuyDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespaceBuyDistributionSegment struct {
	ShowcaseName *string `json:"showcaseName"`
	Count        *int64  `json:"count"`
}

func (p *ShowcaseNamespaceBuyDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespaceBuyDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespaceBuyDistributionSegment{}
	} else {
		*p = ShowcaseNamespaceBuyDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["showcaseName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.ShowcaseName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.ShowcaseName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.ShowcaseName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.ShowcaseName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.ShowcaseName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewShowcaseNamespaceBuyDistributionSegmentFromJson(data string) ShowcaseNamespaceBuyDistributionSegment {
	req := ShowcaseNamespaceBuyDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceBuyDistributionSegmentFromDict(data map[string]interface{}) ShowcaseNamespaceBuyDistributionSegment {
	return ShowcaseNamespaceBuyDistributionSegment{
		ShowcaseName: func() *string {
			v, ok := data["showcaseName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["showcaseName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p ShowcaseNamespaceBuyDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.ShowcaseName != nil {
		m["showcaseName"] = p.ShowcaseName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p ShowcaseNamespaceBuyDistributionSegment) Pointer() *ShowcaseNamespaceBuyDistributionSegment {
	return &p
}

func CastShowcaseNamespaceBuyDistributionSegments(data []interface{}) []ShowcaseNamespaceBuyDistributionSegment {
	v := make([]ShowcaseNamespaceBuyDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceBuyDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespaceBuyDistributionSegmentsFromDict(data []ShowcaseNamespaceBuyDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespaceBuyDistribution struct {
	Statistics   *ShowcaseNamespaceBuyDistributionStatistics `json:"statistics"`
	Distribution []ShowcaseNamespaceBuyDistributionSegment   `json:"distribution"`
}

func (p *ShowcaseNamespaceBuyDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespaceBuyDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespaceBuyDistribution{}
	} else {
		*p = ShowcaseNamespaceBuyDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewShowcaseNamespaceBuyDistributionFromJson(data string) ShowcaseNamespaceBuyDistribution {
	req := ShowcaseNamespaceBuyDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceBuyDistributionFromDict(data map[string]interface{}) ShowcaseNamespaceBuyDistribution {
	return ShowcaseNamespaceBuyDistribution{
		Statistics: func() *ShowcaseNamespaceBuyDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseNamespaceBuyDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []ShowcaseNamespaceBuyDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastShowcaseNamespaceBuyDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p ShowcaseNamespaceBuyDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastShowcaseNamespaceBuyDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p ShowcaseNamespaceBuyDistribution) Pointer() *ShowcaseNamespaceBuyDistribution {
	return &p
}

func CastShowcaseNamespaceBuyDistributions(data []interface{}) []ShowcaseNamespaceBuyDistribution {
	v := make([]ShowcaseNamespaceBuyDistribution, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceBuyDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespaceBuyDistributionsFromDict(data []ShowcaseNamespaceBuyDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespaceDistributions struct {
	Buy *ShowcaseNamespaceBuyDistribution `json:"buy"`
}

func (p *ShowcaseNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespaceDistributions{}
	} else {
		*p = ShowcaseNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["buy"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Buy)
		}
	}
	return nil
}

func NewShowcaseNamespaceDistributionsFromJson(data string) ShowcaseNamespaceDistributions {
	req := ShowcaseNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceDistributionsFromDict(data map[string]interface{}) ShowcaseNamespaceDistributions {
	return ShowcaseNamespaceDistributions{
		Buy: func() *ShowcaseNamespaceBuyDistribution {
			v, ok := data["buy"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseNamespaceBuyDistributionFromDict(core.CastMap(data["buy"])).Pointer()
		}(),
	}
}

func (p ShowcaseNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Buy != nil {
		m["buy"] = func() map[string]interface{} {
			if p.Buy == nil {
				return nil
			}
			return p.Buy.ToDict()
		}()
	}
	return m
}

func (p ShowcaseNamespaceDistributions) Pointer() *ShowcaseNamespaceDistributions {
	return &p
}

func CastShowcaseNamespaceDistributionses(data []interface{}) []ShowcaseNamespaceDistributions {
	v := make([]ShowcaseNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespaceDistributionsesFromDict(data []ShowcaseNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type ShowcaseNamespace struct {
	NamespaceId   *string                         `json:"namespaceId"`
	Year          *int32                          `json:"year"`
	Month         *int32                          `json:"month"`
	Day           *int32                          `json:"day"`
	NamespaceName *string                         `json:"namespaceName"`
	Statistics    *ShowcaseNamespaceStatistics    `json:"statistics"`
	Distributions *ShowcaseNamespaceDistributions `json:"distributions"`
	Showcases     []ShowcaseShowcase              `json:"showcases"`
}

func (p *ShowcaseNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = ShowcaseNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = ShowcaseNamespace{}
	} else {
		*p = ShowcaseNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["showcases"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Showcases)
		}
	}
	return nil
}

func NewShowcaseNamespaceFromJson(data string) ShowcaseNamespace {
	req := ShowcaseNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewShowcaseNamespaceFromDict(data map[string]interface{}) ShowcaseNamespace {
	return ShowcaseNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *ShowcaseNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *ShowcaseNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewShowcaseNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		Showcases: func() []ShowcaseShowcase {
			if data["showcases"] == nil {
				return nil
			}
			return CastShowcaseShowcases(core.CastArray(data["showcases"]))
		}(),
	}
}

func (p ShowcaseNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.Showcases != nil {
		m["showcases"] = CastShowcaseShowcasesFromDict(
			p.Showcases,
		)
	}
	return m
}

func (p ShowcaseNamespace) Pointer() *ShowcaseNamespace {
	return &p
}

func CastShowcaseNamespaces(data []interface{}) []ShowcaseNamespace {
	v := make([]ShowcaseNamespace, 0)
	for _, d := range data {
		v = append(v, NewShowcaseNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastShowcaseNamespacesFromDict(data []ShowcaseNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelStatistics struct {
	Consume       *int64 `json:"consume"`
	ConsumeAmount *int64 `json:"consumeAmount"`
	Recover       *int64 `json:"recover"`
	RecoverAmount *int64 `json:"recoverAmount"`
}

func (p *StaminaStaminaModelStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelStatistics{}
	} else {
		*p = StaminaStaminaModelStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["consumeAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.ConsumeAmount)
		}
		if v, ok := d["recover"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Recover)
		}
		if v, ok := d["recoverAmount"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.RecoverAmount)
		}
	}
	return nil
}

func NewStaminaStaminaModelStatisticsFromJson(data string) StaminaStaminaModelStatistics {
	req := StaminaStaminaModelStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelStatisticsFromDict(data map[string]interface{}) StaminaStaminaModelStatistics {
	return StaminaStaminaModelStatistics{
		Consume: func() *int64 {
			v, ok := data["consume"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["consume"])
		}(),
		ConsumeAmount: func() *int64 {
			v, ok := data["consumeAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["consumeAmount"])
		}(),
		Recover: func() *int64 {
			v, ok := data["recover"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["recover"])
		}(),
		RecoverAmount: func() *int64 {
			v, ok := data["recoverAmount"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["recoverAmount"])
		}(),
	}
}

func (p StaminaStaminaModelStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Consume != nil {
		m["consume"] = p.Consume
	}
	if p.ConsumeAmount != nil {
		m["consumeAmount"] = p.ConsumeAmount
	}
	if p.Recover != nil {
		m["recover"] = p.Recover
	}
	if p.RecoverAmount != nil {
		m["recoverAmount"] = p.RecoverAmount
	}
	return m
}

func (p StaminaStaminaModelStatistics) Pointer() *StaminaStaminaModelStatistics {
	return &p
}

func CastStaminaStaminaModelStatisticses(data []interface{}) []StaminaStaminaModelStatistics {
	v := make([]StaminaStaminaModelStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelStatisticsesFromDict(data []StaminaStaminaModelStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelConsumeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *StaminaStaminaModelConsumeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelConsumeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelConsumeDistributionStatistics{}
	} else {
		*p = StaminaStaminaModelConsumeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewStaminaStaminaModelConsumeDistributionStatisticsFromJson(data string) StaminaStaminaModelConsumeDistributionStatistics {
	req := StaminaStaminaModelConsumeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelConsumeDistributionStatisticsFromDict(data map[string]interface{}) StaminaStaminaModelConsumeDistributionStatistics {
	return StaminaStaminaModelConsumeDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p StaminaStaminaModelConsumeDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p StaminaStaminaModelConsumeDistributionStatistics) Pointer() *StaminaStaminaModelConsumeDistributionStatistics {
	return &p
}

func CastStaminaStaminaModelConsumeDistributionStatisticses(data []interface{}) []StaminaStaminaModelConsumeDistributionStatistics {
	v := make([]StaminaStaminaModelConsumeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelConsumeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelConsumeDistributionStatisticsesFromDict(data []StaminaStaminaModelConsumeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelConsumeDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *StaminaStaminaModelConsumeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelConsumeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelConsumeDistributionSegment{}
	} else {
		*p = StaminaStaminaModelConsumeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewStaminaStaminaModelConsumeDistributionSegmentFromJson(data string) StaminaStaminaModelConsumeDistributionSegment {
	req := StaminaStaminaModelConsumeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelConsumeDistributionSegmentFromDict(data map[string]interface{}) StaminaStaminaModelConsumeDistributionSegment {
	return StaminaStaminaModelConsumeDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p StaminaStaminaModelConsumeDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p StaminaStaminaModelConsumeDistributionSegment) Pointer() *StaminaStaminaModelConsumeDistributionSegment {
	return &p
}

func CastStaminaStaminaModelConsumeDistributionSegments(data []interface{}) []StaminaStaminaModelConsumeDistributionSegment {
	v := make([]StaminaStaminaModelConsumeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelConsumeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelConsumeDistributionSegmentsFromDict(data []StaminaStaminaModelConsumeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelConsumeDistribution struct {
	Statistics   *StaminaStaminaModelConsumeDistributionStatistics `json:"statistics"`
	Distribution []StaminaStaminaModelConsumeDistributionSegment   `json:"distribution"`
}

func (p *StaminaStaminaModelConsumeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelConsumeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelConsumeDistribution{}
	} else {
		*p = StaminaStaminaModelConsumeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewStaminaStaminaModelConsumeDistributionFromJson(data string) StaminaStaminaModelConsumeDistribution {
	req := StaminaStaminaModelConsumeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelConsumeDistributionFromDict(data map[string]interface{}) StaminaStaminaModelConsumeDistribution {
	return StaminaStaminaModelConsumeDistribution{
		Statistics: func() *StaminaStaminaModelConsumeDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaStaminaModelConsumeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []StaminaStaminaModelConsumeDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastStaminaStaminaModelConsumeDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p StaminaStaminaModelConsumeDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastStaminaStaminaModelConsumeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p StaminaStaminaModelConsumeDistribution) Pointer() *StaminaStaminaModelConsumeDistribution {
	return &p
}

func CastStaminaStaminaModelConsumeDistributions(data []interface{}) []StaminaStaminaModelConsumeDistribution {
	v := make([]StaminaStaminaModelConsumeDistribution, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelConsumeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelConsumeDistributionsFromDict(data []StaminaStaminaModelConsumeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelRecoverDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *StaminaStaminaModelRecoverDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelRecoverDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelRecoverDistributionStatistics{}
	} else {
		*p = StaminaStaminaModelRecoverDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewStaminaStaminaModelRecoverDistributionStatisticsFromJson(data string) StaminaStaminaModelRecoverDistributionStatistics {
	req := StaminaStaminaModelRecoverDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelRecoverDistributionStatisticsFromDict(data map[string]interface{}) StaminaStaminaModelRecoverDistributionStatistics {
	return StaminaStaminaModelRecoverDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p StaminaStaminaModelRecoverDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p StaminaStaminaModelRecoverDistributionStatistics) Pointer() *StaminaStaminaModelRecoverDistributionStatistics {
	return &p
}

func CastStaminaStaminaModelRecoverDistributionStatisticses(data []interface{}) []StaminaStaminaModelRecoverDistributionStatistics {
	v := make([]StaminaStaminaModelRecoverDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelRecoverDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelRecoverDistributionStatisticsesFromDict(data []StaminaStaminaModelRecoverDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelRecoverDistributionSegment struct {
	Min   *int64 `json:"min"`
	Max   *int64 `json:"max"`
	Count *int64 `json:"count"`
}

func (p *StaminaStaminaModelRecoverDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelRecoverDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelRecoverDistributionSegment{}
	} else {
		*p = StaminaStaminaModelRecoverDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewStaminaStaminaModelRecoverDistributionSegmentFromJson(data string) StaminaStaminaModelRecoverDistributionSegment {
	req := StaminaStaminaModelRecoverDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelRecoverDistributionSegmentFromDict(data map[string]interface{}) StaminaStaminaModelRecoverDistributionSegment {
	return StaminaStaminaModelRecoverDistributionSegment{
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p StaminaStaminaModelRecoverDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p StaminaStaminaModelRecoverDistributionSegment) Pointer() *StaminaStaminaModelRecoverDistributionSegment {
	return &p
}

func CastStaminaStaminaModelRecoverDistributionSegments(data []interface{}) []StaminaStaminaModelRecoverDistributionSegment {
	v := make([]StaminaStaminaModelRecoverDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelRecoverDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelRecoverDistributionSegmentsFromDict(data []StaminaStaminaModelRecoverDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelRecoverDistribution struct {
	Statistics   *StaminaStaminaModelRecoverDistributionStatistics `json:"statistics"`
	Distribution []StaminaStaminaModelRecoverDistributionSegment   `json:"distribution"`
}

func (p *StaminaStaminaModelRecoverDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelRecoverDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelRecoverDistribution{}
	} else {
		*p = StaminaStaminaModelRecoverDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewStaminaStaminaModelRecoverDistributionFromJson(data string) StaminaStaminaModelRecoverDistribution {
	req := StaminaStaminaModelRecoverDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelRecoverDistributionFromDict(data map[string]interface{}) StaminaStaminaModelRecoverDistribution {
	return StaminaStaminaModelRecoverDistribution{
		Statistics: func() *StaminaStaminaModelRecoverDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaStaminaModelRecoverDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []StaminaStaminaModelRecoverDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastStaminaStaminaModelRecoverDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p StaminaStaminaModelRecoverDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastStaminaStaminaModelRecoverDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p StaminaStaminaModelRecoverDistribution) Pointer() *StaminaStaminaModelRecoverDistribution {
	return &p
}

func CastStaminaStaminaModelRecoverDistributions(data []interface{}) []StaminaStaminaModelRecoverDistribution {
	v := make([]StaminaStaminaModelRecoverDistribution, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelRecoverDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelRecoverDistributionsFromDict(data []StaminaStaminaModelRecoverDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModelDistributions struct {
	Consume *StaminaStaminaModelConsumeDistribution `json:"consume"`
	Recover *StaminaStaminaModelRecoverDistribution `json:"recover"`
}

func (p *StaminaStaminaModelDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModelDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModelDistributions{}
	} else {
		*p = StaminaStaminaModelDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["recover"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Recover)
		}
	}
	return nil
}

func NewStaminaStaminaModelDistributionsFromJson(data string) StaminaStaminaModelDistributions {
	req := StaminaStaminaModelDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelDistributionsFromDict(data map[string]interface{}) StaminaStaminaModelDistributions {
	return StaminaStaminaModelDistributions{
		Consume: func() *StaminaStaminaModelConsumeDistribution {
			v, ok := data["consume"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaStaminaModelConsumeDistributionFromDict(core.CastMap(data["consume"])).Pointer()
		}(),
		Recover: func() *StaminaStaminaModelRecoverDistribution {
			v, ok := data["recover"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaStaminaModelRecoverDistributionFromDict(core.CastMap(data["recover"])).Pointer()
		}(),
	}
}

func (p StaminaStaminaModelDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Consume != nil {
		m["consume"] = func() map[string]interface{} {
			if p.Consume == nil {
				return nil
			}
			return p.Consume.ToDict()
		}()
	}
	if p.Recover != nil {
		m["recover"] = func() map[string]interface{} {
			if p.Recover == nil {
				return nil
			}
			return p.Recover.ToDict()
		}()
	}
	return m
}

func (p StaminaStaminaModelDistributions) Pointer() *StaminaStaminaModelDistributions {
	return &p
}

func CastStaminaStaminaModelDistributionses(data []interface{}) []StaminaStaminaModelDistributions {
	v := make([]StaminaStaminaModelDistributions, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelDistributionsesFromDict(data []StaminaStaminaModelDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaStaminaModel struct {
	StaminaModelId *string                           `json:"staminaModelId"`
	StaminaName    *string                           `json:"staminaName"`
	Statistics     *StaminaStaminaModelStatistics    `json:"statistics"`
	Distributions  *StaminaStaminaModelDistributions `json:"distributions"`
}

func (p *StaminaStaminaModel) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaStaminaModel{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaStaminaModel{}
	} else {
		*p = StaminaStaminaModel{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["staminaModelId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.StaminaModelId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.StaminaModelId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.StaminaModelId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.StaminaModelId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.StaminaModelId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.StaminaModelId)
				}
			}
		}
		if v, ok := d["staminaName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.StaminaName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.StaminaName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.StaminaName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.StaminaName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
	}
	return nil
}

func NewStaminaStaminaModelFromJson(data string) StaminaStaminaModel {
	req := StaminaStaminaModel{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaStaminaModelFromDict(data map[string]interface{}) StaminaStaminaModel {
	return StaminaStaminaModel{
		StaminaModelId: func() *string {
			v, ok := data["staminaModelId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["staminaModelId"])
		}(),
		StaminaName: func() *string {
			v, ok := data["staminaName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["staminaName"])
		}(),
		Statistics: func() *StaminaStaminaModelStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaStaminaModelStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *StaminaStaminaModelDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaStaminaModelDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
	}
}

func (p StaminaStaminaModel) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.StaminaModelId != nil {
		m["staminaModelId"] = p.StaminaModelId
	}
	if p.StaminaName != nil {
		m["staminaName"] = p.StaminaName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	return m
}

func (p StaminaStaminaModel) Pointer() *StaminaStaminaModel {
	return &p
}

func CastStaminaStaminaModels(data []interface{}) []StaminaStaminaModel {
	v := make([]StaminaStaminaModel, 0)
	for _, d := range data {
		v = append(v, NewStaminaStaminaModelFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaStaminaModelsFromDict(data []StaminaStaminaModel) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceStatistics struct {
	Consume *int64 `json:"consume"`
	Recover *int64 `json:"recover"`
}

func (p *StaminaNamespaceStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceStatistics{}
	} else {
		*p = StaminaNamespaceStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["recover"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Recover)
		}
	}
	return nil
}

func NewStaminaNamespaceStatisticsFromJson(data string) StaminaNamespaceStatistics {
	req := StaminaNamespaceStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceStatisticsFromDict(data map[string]interface{}) StaminaNamespaceStatistics {
	return StaminaNamespaceStatistics{
		Consume: func() *int64 {
			v, ok := data["consume"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["consume"])
		}(),
		Recover: func() *int64 {
			v, ok := data["recover"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["recover"])
		}(),
	}
}

func (p StaminaNamespaceStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Consume != nil {
		m["consume"] = p.Consume
	}
	if p.Recover != nil {
		m["recover"] = p.Recover
	}
	return m
}

func (p StaminaNamespaceStatistics) Pointer() *StaminaNamespaceStatistics {
	return &p
}

func CastStaminaNamespaceStatisticses(data []interface{}) []StaminaNamespaceStatistics {
	v := make([]StaminaNamespaceStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceStatisticsesFromDict(data []StaminaNamespaceStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceConsumeDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *StaminaNamespaceConsumeDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceConsumeDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceConsumeDistributionStatistics{}
	} else {
		*p = StaminaNamespaceConsumeDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewStaminaNamespaceConsumeDistributionStatisticsFromJson(data string) StaminaNamespaceConsumeDistributionStatistics {
	req := StaminaNamespaceConsumeDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceConsumeDistributionStatisticsFromDict(data map[string]interface{}) StaminaNamespaceConsumeDistributionStatistics {
	return StaminaNamespaceConsumeDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p StaminaNamespaceConsumeDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p StaminaNamespaceConsumeDistributionStatistics) Pointer() *StaminaNamespaceConsumeDistributionStatistics {
	return &p
}

func CastStaminaNamespaceConsumeDistributionStatisticses(data []interface{}) []StaminaNamespaceConsumeDistributionStatistics {
	v := make([]StaminaNamespaceConsumeDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceConsumeDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceConsumeDistributionStatisticsesFromDict(data []StaminaNamespaceConsumeDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceConsumeDistributionSegment struct {
	StaminaName *string `json:"staminaName"`
	Count       *int64  `json:"count"`
}

func (p *StaminaNamespaceConsumeDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceConsumeDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceConsumeDistributionSegment{}
	} else {
		*p = StaminaNamespaceConsumeDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["staminaName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.StaminaName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.StaminaName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.StaminaName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.StaminaName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewStaminaNamespaceConsumeDistributionSegmentFromJson(data string) StaminaNamespaceConsumeDistributionSegment {
	req := StaminaNamespaceConsumeDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceConsumeDistributionSegmentFromDict(data map[string]interface{}) StaminaNamespaceConsumeDistributionSegment {
	return StaminaNamespaceConsumeDistributionSegment{
		StaminaName: func() *string {
			v, ok := data["staminaName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["staminaName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p StaminaNamespaceConsumeDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.StaminaName != nil {
		m["staminaName"] = p.StaminaName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p StaminaNamespaceConsumeDistributionSegment) Pointer() *StaminaNamespaceConsumeDistributionSegment {
	return &p
}

func CastStaminaNamespaceConsumeDistributionSegments(data []interface{}) []StaminaNamespaceConsumeDistributionSegment {
	v := make([]StaminaNamespaceConsumeDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceConsumeDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceConsumeDistributionSegmentsFromDict(data []StaminaNamespaceConsumeDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceConsumeDistribution struct {
	Statistics   *StaminaNamespaceConsumeDistributionStatistics `json:"statistics"`
	Distribution []StaminaNamespaceConsumeDistributionSegment   `json:"distribution"`
}

func (p *StaminaNamespaceConsumeDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceConsumeDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceConsumeDistribution{}
	} else {
		*p = StaminaNamespaceConsumeDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewStaminaNamespaceConsumeDistributionFromJson(data string) StaminaNamespaceConsumeDistribution {
	req := StaminaNamespaceConsumeDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceConsumeDistributionFromDict(data map[string]interface{}) StaminaNamespaceConsumeDistribution {
	return StaminaNamespaceConsumeDistribution{
		Statistics: func() *StaminaNamespaceConsumeDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaNamespaceConsumeDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []StaminaNamespaceConsumeDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastStaminaNamespaceConsumeDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p StaminaNamespaceConsumeDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastStaminaNamespaceConsumeDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p StaminaNamespaceConsumeDistribution) Pointer() *StaminaNamespaceConsumeDistribution {
	return &p
}

func CastStaminaNamespaceConsumeDistributions(data []interface{}) []StaminaNamespaceConsumeDistribution {
	v := make([]StaminaNamespaceConsumeDistribution, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceConsumeDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceConsumeDistributionsFromDict(data []StaminaNamespaceConsumeDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceRecoverDistributionStatistics struct {
	Count  *int64   `json:"count"`
	Min    *int64   `json:"min"`
	Max    *int64   `json:"max"`
	Avg    *float32 `json:"avg"`
	Median *int64   `json:"median"`
	Stddev *float32 `json:"stddev"`
}

func (p *StaminaNamespaceRecoverDistributionStatistics) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceRecoverDistributionStatistics{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceRecoverDistributionStatistics{}
	} else {
		*p = StaminaNamespaceRecoverDistributionStatistics{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
		if v, ok := d["min"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Min)
		}
		if v, ok := d["max"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Max)
		}
		if v, ok := d["avg"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Avg)
		}
		if v, ok := d["median"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Median)
		}
		if v, ok := d["stddev"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Stddev)
		}
	}
	return nil
}

func NewStaminaNamespaceRecoverDistributionStatisticsFromJson(data string) StaminaNamespaceRecoverDistributionStatistics {
	req := StaminaNamespaceRecoverDistributionStatistics{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceRecoverDistributionStatisticsFromDict(data map[string]interface{}) StaminaNamespaceRecoverDistributionStatistics {
	return StaminaNamespaceRecoverDistributionStatistics{
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
		Min: func() *int64 {
			v, ok := data["min"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["min"])
		}(),
		Max: func() *int64 {
			v, ok := data["max"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["max"])
		}(),
		Avg: func() *float32 {
			v, ok := data["avg"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["avg"])
		}(),
		Median: func() *int64 {
			v, ok := data["median"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["median"])
		}(),
		Stddev: func() *float32 {
			v, ok := data["stddev"]
			if !ok || v == nil {
				return nil
			}
			return core.CastFloat32(data["stddev"])
		}(),
	}
}

func (p StaminaNamespaceRecoverDistributionStatistics) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Count != nil {
		m["count"] = p.Count
	}
	if p.Min != nil {
		m["min"] = p.Min
	}
	if p.Max != nil {
		m["max"] = p.Max
	}
	if p.Avg != nil {
		m["avg"] = p.Avg
	}
	if p.Median != nil {
		m["median"] = p.Median
	}
	if p.Stddev != nil {
		m["stddev"] = p.Stddev
	}
	return m
}

func (p StaminaNamespaceRecoverDistributionStatistics) Pointer() *StaminaNamespaceRecoverDistributionStatistics {
	return &p
}

func CastStaminaNamespaceRecoverDistributionStatisticses(data []interface{}) []StaminaNamespaceRecoverDistributionStatistics {
	v := make([]StaminaNamespaceRecoverDistributionStatistics, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceRecoverDistributionStatisticsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceRecoverDistributionStatisticsesFromDict(data []StaminaNamespaceRecoverDistributionStatistics) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceRecoverDistributionSegment struct {
	StaminaName *string `json:"staminaName"`
	Count       *int64  `json:"count"`
}

func (p *StaminaNamespaceRecoverDistributionSegment) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceRecoverDistributionSegment{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceRecoverDistributionSegment{}
	} else {
		*p = StaminaNamespaceRecoverDistributionSegment{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["staminaName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.StaminaName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.StaminaName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.StaminaName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.StaminaName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.StaminaName)
				}
			}
		}
		if v, ok := d["count"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Count)
		}
	}
	return nil
}

func NewStaminaNamespaceRecoverDistributionSegmentFromJson(data string) StaminaNamespaceRecoverDistributionSegment {
	req := StaminaNamespaceRecoverDistributionSegment{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceRecoverDistributionSegmentFromDict(data map[string]interface{}) StaminaNamespaceRecoverDistributionSegment {
	return StaminaNamespaceRecoverDistributionSegment{
		StaminaName: func() *string {
			v, ok := data["staminaName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["staminaName"])
		}(),
		Count: func() *int64 {
			v, ok := data["count"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt64(data["count"])
		}(),
	}
}

func (p StaminaNamespaceRecoverDistributionSegment) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.StaminaName != nil {
		m["staminaName"] = p.StaminaName
	}
	if p.Count != nil {
		m["count"] = p.Count
	}
	return m
}

func (p StaminaNamespaceRecoverDistributionSegment) Pointer() *StaminaNamespaceRecoverDistributionSegment {
	return &p
}

func CastStaminaNamespaceRecoverDistributionSegments(data []interface{}) []StaminaNamespaceRecoverDistributionSegment {
	v := make([]StaminaNamespaceRecoverDistributionSegment, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceRecoverDistributionSegmentFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceRecoverDistributionSegmentsFromDict(data []StaminaNamespaceRecoverDistributionSegment) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceRecoverDistribution struct {
	Statistics   *StaminaNamespaceRecoverDistributionStatistics `json:"statistics"`
	Distribution []StaminaNamespaceRecoverDistributionSegment   `json:"distribution"`
}

func (p *StaminaNamespaceRecoverDistribution) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceRecoverDistribution{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceRecoverDistribution{}
	} else {
		*p = StaminaNamespaceRecoverDistribution{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distribution"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distribution)
		}
	}
	return nil
}

func NewStaminaNamespaceRecoverDistributionFromJson(data string) StaminaNamespaceRecoverDistribution {
	req := StaminaNamespaceRecoverDistribution{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceRecoverDistributionFromDict(data map[string]interface{}) StaminaNamespaceRecoverDistribution {
	return StaminaNamespaceRecoverDistribution{
		Statistics: func() *StaminaNamespaceRecoverDistributionStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaNamespaceRecoverDistributionStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distribution: func() []StaminaNamespaceRecoverDistributionSegment {
			if data["distribution"] == nil {
				return nil
			}
			return CastStaminaNamespaceRecoverDistributionSegments(core.CastArray(data["distribution"]))
		}(),
	}
}

func (p StaminaNamespaceRecoverDistribution) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distribution != nil {
		m["distribution"] = CastStaminaNamespaceRecoverDistributionSegmentsFromDict(
			p.Distribution,
		)
	}
	return m
}

func (p StaminaNamespaceRecoverDistribution) Pointer() *StaminaNamespaceRecoverDistribution {
	return &p
}

func CastStaminaNamespaceRecoverDistributions(data []interface{}) []StaminaNamespaceRecoverDistribution {
	v := make([]StaminaNamespaceRecoverDistribution, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceRecoverDistributionFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceRecoverDistributionsFromDict(data []StaminaNamespaceRecoverDistribution) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespaceDistributions struct {
	Consume *StaminaNamespaceConsumeDistribution `json:"consume"`
	Recover *StaminaNamespaceRecoverDistribution `json:"recover"`
}

func (p *StaminaNamespaceDistributions) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespaceDistributions{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespaceDistributions{}
	} else {
		*p = StaminaNamespaceDistributions{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["consume"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Consume)
		}
		if v, ok := d["recover"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Recover)
		}
	}
	return nil
}

func NewStaminaNamespaceDistributionsFromJson(data string) StaminaNamespaceDistributions {
	req := StaminaNamespaceDistributions{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceDistributionsFromDict(data map[string]interface{}) StaminaNamespaceDistributions {
	return StaminaNamespaceDistributions{
		Consume: func() *StaminaNamespaceConsumeDistribution {
			v, ok := data["consume"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaNamespaceConsumeDistributionFromDict(core.CastMap(data["consume"])).Pointer()
		}(),
		Recover: func() *StaminaNamespaceRecoverDistribution {
			v, ok := data["recover"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaNamespaceRecoverDistributionFromDict(core.CastMap(data["recover"])).Pointer()
		}(),
	}
}

func (p StaminaNamespaceDistributions) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.Consume != nil {
		m["consume"] = func() map[string]interface{} {
			if p.Consume == nil {
				return nil
			}
			return p.Consume.ToDict()
		}()
	}
	if p.Recover != nil {
		m["recover"] = func() map[string]interface{} {
			if p.Recover == nil {
				return nil
			}
			return p.Recover.ToDict()
		}()
	}
	return m
}

func (p StaminaNamespaceDistributions) Pointer() *StaminaNamespaceDistributions {
	return &p
}

func CastStaminaNamespaceDistributionses(data []interface{}) []StaminaNamespaceDistributions {
	v := make([]StaminaNamespaceDistributions, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceDistributionsFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespaceDistributionsesFromDict(data []StaminaNamespaceDistributions) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}

type StaminaNamespace struct {
	NamespaceId   *string                        `json:"namespaceId"`
	Year          *int32                         `json:"year"`
	Month         *int32                         `json:"month"`
	Day           *int32                         `json:"day"`
	NamespaceName *string                        `json:"namespaceName"`
	Statistics    *StaminaNamespaceStatistics    `json:"statistics"`
	Distributions *StaminaNamespaceDistributions `json:"distributions"`
	StaminaModels []StaminaStaminaModel          `json:"staminaModels"`
}

func (p *StaminaNamespace) UnmarshalJSON(data []byte) error {
	str := string(data)
	if len(str) == 0 {
		*p = StaminaNamespace{}
		return nil
	}
	if str[0] == '"' {
		var strVal string
		err := json.Unmarshal(data, &strVal)
		if err != nil {
			return err
		}
		str = strVal
	}
	if str == "null" {
		*p = StaminaNamespace{}
	} else {
		*p = StaminaNamespace{}
		d := map[string]*json.RawMessage{}
		if err := json.Unmarshal([]byte(str), &d); err != nil {
			return err
		}
		if v, ok := d["namespaceId"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceId = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceId = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceId = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceId = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceId)
				}
			}
		}
		if v, ok := d["year"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Year)
		}
		if v, ok := d["month"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Month)
		}
		if v, ok := d["day"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Day)
		}
		if v, ok := d["namespaceName"]; ok && v != nil {
			var temp interface{}
			if err := json.Unmarshal(*v, &temp); err == nil {
				switch v2 := temp.(type) {
				case string:
					p.NamespaceName = &v2
				case float64:
					strValue := strconv.FormatFloat(v2, 'f', -1, 64)
					p.NamespaceName = &strValue
				case int:
					strValue := strconv.Itoa(v2)
					p.NamespaceName = &strValue
				case int32:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				case int64:
					strValue := strconv.Itoa(int(v2))
					p.NamespaceName = &strValue
				default:
					_ = json.Unmarshal(*v, &p.NamespaceName)
				}
			}
		}
		if v, ok := d["statistics"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Statistics)
		}
		if v, ok := d["distributions"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.Distributions)
		}
		if v, ok := d["staminaModels"]; ok && v != nil {
			_ = json.Unmarshal(*v, &p.StaminaModels)
		}
	}
	return nil
}

func NewStaminaNamespaceFromJson(data string) StaminaNamespace {
	req := StaminaNamespace{}
	_ = json.Unmarshal([]byte(data), &req)
	return req
}

func NewStaminaNamespaceFromDict(data map[string]interface{}) StaminaNamespace {
	return StaminaNamespace{
		NamespaceId: func() *string {
			v, ok := data["namespaceId"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceId"])
		}(),
		Year: func() *int32 {
			v, ok := data["year"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["year"])
		}(),
		Month: func() *int32 {
			v, ok := data["month"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["month"])
		}(),
		Day: func() *int32 {
			v, ok := data["day"]
			if !ok || v == nil {
				return nil
			}
			return core.CastInt32(data["day"])
		}(),
		NamespaceName: func() *string {
			v, ok := data["namespaceName"]
			if !ok || v == nil {
				return nil
			}
			return core.CastString(data["namespaceName"])
		}(),
		Statistics: func() *StaminaNamespaceStatistics {
			v, ok := data["statistics"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaNamespaceStatisticsFromDict(core.CastMap(data["statistics"])).Pointer()
		}(),
		Distributions: func() *StaminaNamespaceDistributions {
			v, ok := data["distributions"]
			if !ok || v == nil {
				return nil
			}
			return NewStaminaNamespaceDistributionsFromDict(core.CastMap(data["distributions"])).Pointer()
		}(),
		StaminaModels: func() []StaminaStaminaModel {
			if data["staminaModels"] == nil {
				return nil
			}
			return CastStaminaStaminaModels(core.CastArray(data["staminaModels"]))
		}(),
	}
}

func (p StaminaNamespace) ToDict() map[string]interface{} {
	m := map[string]interface{}{}
	if p.NamespaceId != nil {
		m["namespaceId"] = p.NamespaceId
	}
	if p.Year != nil {
		m["year"] = p.Year
	}
	if p.Month != nil {
		m["month"] = p.Month
	}
	if p.Day != nil {
		m["day"] = p.Day
	}
	if p.NamespaceName != nil {
		m["namespaceName"] = p.NamespaceName
	}
	if p.Statistics != nil {
		m["statistics"] = func() map[string]interface{} {
			if p.Statistics == nil {
				return nil
			}
			return p.Statistics.ToDict()
		}()
	}
	if p.Distributions != nil {
		m["distributions"] = func() map[string]interface{} {
			if p.Distributions == nil {
				return nil
			}
			return p.Distributions.ToDict()
		}()
	}
	if p.StaminaModels != nil {
		m["staminaModels"] = CastStaminaStaminaModelsFromDict(
			p.StaminaModels,
		)
	}
	return m
}

func (p StaminaNamespace) Pointer() *StaminaNamespace {
	return &p
}

func CastStaminaNamespaces(data []interface{}) []StaminaNamespace {
	v := make([]StaminaNamespace, 0)
	for _, d := range data {
		v = append(v, NewStaminaNamespaceFromDict(d.(map[string]interface{})))
	}
	return v
}

func CastStaminaNamespacesFromDict(data []StaminaNamespace) []interface{} {
	v := make([]interface{}, 0)
	for _, d := range data {
		v = append(v, d.ToDict())
	}
	return v
}
